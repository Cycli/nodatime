id: NodaTime
language: CSharp
name:
  Default: NodaTime
qualifiedName:
  Default: NodaTime
type: Assembly
modifiers: {}
items:
- id: NodaTime
  commentId: N:NodaTime
  language: CSharp
  name:
    CSharp: NodaTime
    VB: NodaTime
  nameWithType:
    CSharp: NodaTime
    VB: NodaTime
  qualifiedName:
    CSharp: NodaTime
    VB: NodaTime
  type: Namespace
  assemblies:
  - NodaTime
  modifiers: {}
  items:
  - id: NodaTime.CalendarSystem
    commentId: T:NodaTime.CalendarSystem
    language: CSharp
    name:
      CSharp: CalendarSystem
      VB: CalendarSystem
    nameWithType:
      CSharp: CalendarSystem
      VB: CalendarSystem
    qualifiedName:
      CSharp: NodaTime.CalendarSystem
      VB: NodaTime.CalendarSystem
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/CalendarSystem.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: CalendarSystem
      path: src/NodaTime/CalendarSystem.cs
      startLine: 42
    summary: "\nA calendar system maps the non-calendar-specific \"local time line\" to human concepts\nsuch as years, months and days.\n"
    remarks: "\n<p>\nMany developers will never need to touch this class, other than to potentially ask a calendar\nhow many days are in a particular year/month and the like. Noda Time defaults to using the ISO-8601\ncalendar anywhere that a calendar system is required but hasn't been explicitly specified.\n</p>\n<p>\nIf you need to obtain a <xref href=\"NodaTime.CalendarSystem\" data-throw-if-not-resolved=\"false\"></xref> instance, use one of the static properties or methods in this\nclass, such as the <xref href=\"NodaTime.CalendarSystem.Iso\" data-throw-if-not-resolved=\"false\"></xref> property or the <xref href=\"NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.\n</p>\n<p>Although this class is currently sealed (as of Noda Time 1.2), in the future this decision may\nbe reversed. In any case, there is no current intention for third-party developers to be able to implement\ntheir own calendar systems (for various reasons). If you require a calendar system which is not\ncurrently supported, please file a feature request and we'll see what we can do.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: public sealed class CalendarSystem
        VB: Public NotInheritable Class CalendarSystem
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.CalendarSystem.ForId(System.String)
      commentId: M:NodaTime.CalendarSystem.ForId(System.String)
      language: CSharp
      name:
        CSharp: ForId(String)
        VB: ForId(String)
      nameWithType:
        CSharp: CalendarSystem.ForId(String)
        VB: CalendarSystem.ForId(String)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.ForId(System.String)
        VB: NodaTime.CalendarSystem.ForId(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ForId
        path: src/NodaTime/CalendarSystem.cs
        startLine: 99
      summary: "\nFetches a calendar system by its unique identifier. This provides full round-tripping of a calendar\nsystem. It is not guaranteed that calling this method twice with the same identifier will return\nidentical references, but the references objects will be equal.\n"
      example: []
      syntax:
        content:
          CSharp: public static CalendarSystem ForId(string id)
          VB: Public Shared Function ForId(id As String) As CalendarSystem
        parameters:
        - id: id
          type: System.String
          description: The ID of the calendar system. This is case-sensitive.
        return:
          type: NodaTime.CalendarSystem
          description: The calendar system with the given ID.
      overload: NodaTime.CalendarSystem.ForId*
      exceptions:
      - type: System.Collections.Generic.KeyNotFoundException
        commentId: T:System.Collections.Generic.KeyNotFoundException
        description: No calendar system for the specified ID can be found.
      seealso:
      - linkId: NodaTime.CalendarSystem.Id
        commentId: P:NodaTime.CalendarSystem.Id
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.CalendarSystem.Id: 
    - id: NodaTime.CalendarSystem.Ids
      commentId: P:NodaTime.CalendarSystem.Ids
      language: CSharp
      name:
        CSharp: Ids
        VB: Ids
      nameWithType:
        CSharp: CalendarSystem.Ids
        VB: CalendarSystem.Ids
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.Ids
        VB: NodaTime.CalendarSystem.Ids
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Ids
        path: src/NodaTime/CalendarSystem.cs
        startLine: 112
      summary: "\nReturns the IDs of all calendar systems available within Noda Time. The order of the keys is not guaranteed.\n"
      example: []
      syntax:
        content:
          CSharp: public static IEnumerable<string> Ids { get; }
          VB: Public Shared ReadOnly Property Ids As IEnumerable(Of String)
        parameters: []
        return:
          type: System.Collections.Generic.IEnumerable{System.String}
      overload: NodaTime.CalendarSystem.Ids*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.CalendarSystem.Iso
      commentId: P:NodaTime.CalendarSystem.Iso
      language: CSharp
      name:
        CSharp: Iso
        VB: Iso
      nameWithType:
        CSharp: CalendarSystem.Iso
        VB: CalendarSystem.Iso
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.Iso
        VB: NodaTime.CalendarSystem.Iso
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Iso
        path: src/NodaTime/CalendarSystem.cs
        startLine: 164
      summary: "\nReturns a calendar system that follows the rules of the ISO-8601 standard,\nwhich is compatible with Gregorian for all modern dates.\n"
      remarks: "\n<p>\nWhen ISO does not define a field, but it can be determined (such as AM/PM) it is included.\n</p>\n<p>\nWith the exception of century related fields, the ISO calendar is exactly the\nsame as the Gregorian calendar system. In the ISO system, centuries and year\nof century are zero based. For all years, the century is determined by\ndropping the last two digits of the year, ignoring sign. The year of century\nis the value of the last two year digits.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public static CalendarSystem Iso { get; }
          VB: Public Shared ReadOnly Property Iso As CalendarSystem
        parameters: []
        return:
          type: NodaTime.CalendarSystem
      overload: NodaTime.CalendarSystem.Iso*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)
      commentId: M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)
      language: CSharp
      name:
        CSharp: GetGregorianCalendar(Int32)
        VB: GetGregorianCalendar(Int32)
      nameWithType:
        CSharp: CalendarSystem.GetGregorianCalendar(Int32)
        VB: CalendarSystem.GetGregorianCalendar(Int32)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)
        VB: NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetGregorianCalendar
        path: src/NodaTime/CalendarSystem.cs
        startLine: 181
      summary: "\nReturns a pure proleptic Gregorian calendar system, which defines every\nfourth year as leap, unless the year is divisible by 100 and not by 400.\nThis improves upon the Julian calendar leap year rule.\n"
      remarks: "\nAlthough the Gregorian calendar did not exist before 1582 CE, this\ncalendar system assumes it did, thus it is proleptic. This implementation also\nfixes the start of the year at January 1.\n"
      example: []
      syntax:
        content:
          CSharp: public static CalendarSystem GetGregorianCalendar(int minDaysInFirstWeek)
          VB: Public Shared Function GetGregorianCalendar(minDaysInFirstWeek As Integer) As CalendarSystem
        parameters:
        - id: minDaysInFirstWeek
          type: System.Int32
          description: >-
            The minimum number of days in the first week of the year.

            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is

            used to decide at what point the week year changes.
        return:
          type: NodaTime.CalendarSystem
          description: >-
            A suitable Gregorian calendar reference; the same reference may be returned by several

            calls as the object is immutable and thread-safe.
      overload: NodaTime.CalendarSystem.GetGregorianCalendar*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)
      commentId: M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)
      language: CSharp
      name:
        CSharp: GetJulianCalendar(Int32)
        VB: GetJulianCalendar(Int32)
      nameWithType:
        CSharp: CalendarSystem.GetJulianCalendar(Int32)
        VB: CalendarSystem.GetJulianCalendar(Int32)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)
        VB: NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetJulianCalendar
        path: src/NodaTime/CalendarSystem.cs
        startLine: 203
      summary: "\nReturns a pure proleptic Julian calendar system, which defines every\nfourth year as a leap year. This implementation follows the leap year rule\nstrictly, even for dates before 8 CE, where leap years were actually\nirregular.\n"
      remarks: "\nAlthough the Julian calendar did not exist before 45 BCE, this calendar\nassumes it did, thus it is proleptic. This implementation also fixes the\nstart of the year at January 1.\n"
      example: []
      syntax:
        content:
          CSharp: public static CalendarSystem GetJulianCalendar(int minDaysInFirstWeek)
          VB: Public Shared Function GetJulianCalendar(minDaysInFirstWeek As Integer) As CalendarSystem
        parameters:
        - id: minDaysInFirstWeek
          type: System.Int32
          description: >-
            The minimum number of days in the first week of the year.

            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is

            used to decide at what point the week year changes.
        return:
          type: NodaTime.CalendarSystem
          description: >-
            A suitable Julian calendar reference; the same reference may be returned by several

            calls as the object is immutable and thread-safe.
      overload: NodaTime.CalendarSystem.GetJulianCalendar*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)
      commentId: M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)
      language: CSharp
      name:
        CSharp: GetCopticCalendar(Int32)
        VB: GetCopticCalendar(Int32)
      nameWithType:
        CSharp: CalendarSystem.GetCopticCalendar(Int32)
        VB: CalendarSystem.GetCopticCalendar(Int32)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)
        VB: NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetCopticCalendar
        path: src/NodaTime/CalendarSystem.cs
        startLine: 233
      summary: "\nReturns a Coptic calendar system, which defines every fourth year as\nleap, much like the Julian calendar. The year is broken down into 12 months,\neach 30 days in length. An extra period at the end of the year is either 5\nor 6 days in length. In this implementation, it is considered a 13th month.\n"
      remarks: "\n<p>\nYear 1 in the Coptic calendar began on August 29, 284 CE (Julian), thus\nCoptic years do not begin at the same time as Julian years. This calendar\nis not proleptic, as it does not allow dates before the first Coptic year.\n</p>\n<p>\nThis implementation defines a day as midnight to midnight exactly as per\nthe ISO calendar. Some references indicate that a Coptic day starts at\nsunset on the previous ISO day, but this has not been confirmed and is not\nimplemented.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public static CalendarSystem GetCopticCalendar(int minDaysInFirstWeek)
          VB: Public Shared Function GetCopticCalendar(minDaysInFirstWeek As Integer) As CalendarSystem
        parameters:
        - id: minDaysInFirstWeek
          type: System.Int32
          description: >-
            The minimum number of days in the first week of the year.

            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is

            used to decide at what point the week year changes.
        return:
          type: NodaTime.CalendarSystem
          description: >-
            A suitable Coptic calendar reference; the same reference may be returned by several

            calls as the object is immutable and thread-safe.
      overload: NodaTime.CalendarSystem.GetCopticCalendar*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)
      commentId: M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)
      language: CSharp
      name:
        CSharp: GetIslamicCalendar(IslamicLeapYearPattern, IslamicEpoch)
        VB: GetIslamicCalendar(IslamicLeapYearPattern, IslamicEpoch)
      nameWithType:
        CSharp: CalendarSystem.GetIslamicCalendar(IslamicLeapYearPattern, IslamicEpoch)
        VB: CalendarSystem.GetIslamicCalendar(IslamicLeapYearPattern, IslamicEpoch)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern, NodaTime.Calendars.IslamicEpoch)
        VB: NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern, NodaTime.Calendars.IslamicEpoch)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetIslamicCalendar
        path: src/NodaTime/CalendarSystem.cs
        startLine: 296
      summary: "\nReturns an Islamic, or Hijri, calendar system.\n"
      remarks: "\n<p>\nThis returns a tablular calendar, rather than one based on lunar observation. This calendar is a\nlunar calendar with 12 months, each of 29 or 30 days, resulting in a year of 354 days (or 355 on a leap\nyear).\n</p>\n<p>\nYear 1 in the Islamic calendar began on July 15th or 16th, 622 CE (Julian), thus\nIslamic years do not begin at the same time as Julian years. This calendar\nis not proleptic, as it does not allow dates before the first Islamic year.\n</p>\n<p>\nThere are two basic forms of the Islamic calendar, the tabular and the\nobserved. The observed form cannot easily be used by computers as it\nrelies on human observation of the new moon. The tabular calendar, implemented here, is an\narithmetic approximation of the observed form that follows relatively simple rules.\n</p>\n<p>You should choose an epoch based on which external system you wish\nto be compatible with. The epoch beginning on July 16th is the more common\none for the tabular calendar, so using <xref href=\"NodaTime.Calendars.IslamicEpoch.Civil\" data-throw-if-not-resolved=\"false\"></xref>\nwould usually be a logical choice. However, Windows uses July 15th, so\nif you need to be compatible with other Windows systems, you may wish to use\n<xref href=\"NodaTime.Calendars.IslamicEpoch.Astronomical\" data-throw-if-not-resolved=\"false\"></xref>. The fact that the Islamic calendar\ntraditionally starts at dusk, a Julian day traditionally starts at noon,\nand all calendar systems in Noda Time start their days at midnight adds\nsomewhat inevitable confusion to the mix, unfortunately.</p>\n<p>\nThe tabular form of the calendar defines 12 months of alternately\n30 and 29 days. The last month is extended to 30 days in a leap year.\nLeap years occur according to a 30 year cycle. There are four recognised\npatterns of leap years in the 30 year cycle:\n</p>\n<table><thead><tr><th>Origin</th><th>Leap years</th></tr></thead><tbody><tr><td>Kūshyār ibn Labbān</td><td>2, 5, 7, 10, 13, 15, 18, 21, 24, 26, 29</td></tr><tr><td>al-Fazārī</td><td>2, 5, 7, 10, 13, 16, 18, 21, 24, 26, 29</td></tr><tr><td>Fātimid (also known as Misri or Bohra)</td><td>2, 5, 8, 10, 13, 16, 19, 21, 24, 27, 29</td></tr><tr><td>Habash al-Hasib</td><td>2, 5, 8, 11, 13, 16, 19, 21, 24, 27, 30</td></tr></tbody></table>\n<p>\nThe leap year pattern to use is determined from the first parameter to this factory method.\nThe second parameter determines which epoch is used - the \"astronomical\" or \"Thursday\" epoch\n(July 15th 622CE) or the \"civil\" or \"Friday\" epoch (July 16th 622CE).\n</p>\n<p>\nThis implementation defines a day as midnight to midnight exactly as per\nthe ISO calendar. This correct start of day is at sunset on the previous\nday, however this cannot readily be modelled and has been ignored.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public static CalendarSystem GetIslamicCalendar(IslamicLeapYearPattern leapYearPattern, IslamicEpoch epoch)
          VB: Public Shared Function GetIslamicCalendar(leapYearPattern As IslamicLeapYearPattern, epoch As IslamicEpoch) As CalendarSystem
        parameters:
        - id: leapYearPattern
          type: NodaTime.Calendars.IslamicLeapYearPattern
          description: The pattern of years in the 30-year cycle to consider as leap years
        - id: epoch
          type: NodaTime.Calendars.IslamicEpoch
          description: The kind of epoch to use (astronomical or civil)
        return:
          type: NodaTime.CalendarSystem
          description: >-
            A suitable Islamic calendar reference; the same reference may be returned by several

            calls as the object is immutable and thread-safe.
      overload: NodaTime.CalendarSystem.GetIslamicCalendar*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Calendars.IslamicEpoch.Civil: 
        NodaTime.Calendars.IslamicEpoch.Astronomical: 
    - id: NodaTime.CalendarSystem.Id
      commentId: P:NodaTime.CalendarSystem.Id
      language: CSharp
      name:
        CSharp: Id
        VB: Id
      nameWithType:
        CSharp: CalendarSystem.Id
        VB: CalendarSystem.Id
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.Id
        VB: NodaTime.CalendarSystem.Id
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Id
        path: src/NodaTime/CalendarSystem.cs
        startLine: 397
      summary: "\nReturns the unique identifier for this calendar system. This is provides full round-trip capability\nusing <xref href=\"NodaTime.CalendarSystem.ForId(System.String)\" data-throw-if-not-resolved=\"false\"></xref> to retrieve the calendar system from the identifier.\n"
      remarks: "\n<p>\nA unique ID for a calendar is required when serializing types which include a <xref href=\"NodaTime.CalendarSystem\" data-throw-if-not-resolved=\"false\"></xref>.\nAs of 2 Nov 2012 (ISO calendar) there are no ISO or RFC standards for naming a calendar system. As such,\nthe identifiers provided here are specific to Noda Time, and are not guaranteed to interoperate with any other\ndate and time API.\n</p>\n<table><thead><tr><th>Calendar ID</th><th>Equivalent factory method</th></tr></thead><tbody><tr><td>ISO</td><td><xref href=\"NodaTime.CalendarSystem.Iso\" data-throw-if-not-resolved=\"false\"></xref></td></tr><tr><td>Gregorian 1</td><td><xref href=\"NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(1)</td></tr><tr><td>Gregorian 2</td><td><xref href=\"NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(2)</td></tr><tr><td>Gregorian 3</td><td><xref href=\"NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(3)</td></tr><tr><td>Gregorian 3</td><td><xref href=\"NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(4)</td></tr><tr><td>Gregorian 5</td><td><xref href=\"NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(5)</td></tr><tr><td>Gregorian 6</td><td><xref href=\"NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(6)</td></tr><tr><td>Gregorian 7</td><td><xref href=\"NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(7)</td></tr><tr><td>Coptic 1</td><td><xref href=\"NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(1)</td></tr><tr><td>Coptic 2</td><td><xref href=\"NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(2)</td></tr><tr><td>Coptic 3</td><td><xref href=\"NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(3)</td></tr><tr><td>Coptic 4</td><td><xref href=\"NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(4)</td></tr><tr><td>Coptic 5</td><td><xref href=\"NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(5)</td></tr><tr><td>Coptic 6</td><td><xref href=\"NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(6)</td></tr><tr><td>Coptic 7</td><td><xref href=\"NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(7)</td></tr><tr><td>Julian 1</td><td><xref href=\"NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(1)</td></tr><tr><td>Julian 2</td><td><xref href=\"NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(2)</td></tr><tr><td>Julian 3</td><td><xref href=\"NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(3)</td></tr><tr><td>Julian 4</td><td><xref href=\"NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(4)</td></tr><tr><td>Julian 5</td><td><xref href=\"NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(5)</td></tr><tr><td>Julian 6</td><td><xref href=\"NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(6)</td></tr><tr><td>Julian 7</td><td><xref href=\"NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>(7)</td></tr><tr><td>Hijri Civil-Indian</td><td><xref href=\"NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern%2cNodaTime.Calendars.IslamicEpoch)\" data-throw-if-not-resolved=\"false\"></xref>(IslamicLeapYearPattern.Indian, IslamicEpoch.Civil)</td></tr><tr><td>Hijri Civil-Base15</td><td><xref href=\"NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern%2cNodaTime.Calendars.IslamicEpoch)\" data-throw-if-not-resolved=\"false\"></xref>(IslamicLeapYearPattern.Base15, IslamicEpoch.Civil)</td></tr><tr><td>Hijri Civil-Base16</td><td><xref href=\"NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern%2cNodaTime.Calendars.IslamicEpoch)\" data-throw-if-not-resolved=\"false\"></xref>(IslamicLeapYearPattern.Base16, IslamicEpoch.Civil)</td></tr><tr><td>Hijri Civil-HabashAlHasib</td><td><xref href=\"NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern%2cNodaTime.Calendars.IslamicEpoch)\" data-throw-if-not-resolved=\"false\"></xref>(IslamicLeapYearPattern.HabashAlHasib, IslamicEpoch.Civil)</td></tr><tr><td>Hijri Astronomical-Indian</td><td><xref href=\"NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern%2cNodaTime.Calendars.IslamicEpoch)\" data-throw-if-not-resolved=\"false\"></xref>(IslamicLeapYearPattern.Indian, IslamicEpoch.Astronomical)</td></tr><tr><td>Hijri Astronomical-Base15</td><td><xref href=\"NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern%2cNodaTime.Calendars.IslamicEpoch)\" data-throw-if-not-resolved=\"false\"></xref>(IslamicLeapYearPattern.Base15, IslamicEpoch.Astronomical)</td></tr><tr><td>Hijri Astronomical-Base16</td><td><xref href=\"NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern%2cNodaTime.Calendars.IslamicEpoch)\" data-throw-if-not-resolved=\"false\"></xref>(IslamicLeapYearPattern.Base16, IslamicEpoch.Astronomical)</td></tr><tr><td>Hijri Astronomical-HabashAlHasib</td><td><xref href=\"NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern%2cNodaTime.Calendars.IslamicEpoch)\" data-throw-if-not-resolved=\"false\"></xref>(IslamicLeapYearPattern.HabashAlHasib, IslamicEpoch.Astronomical)</td></tr></tbody></table>\n"
      example: []
      syntax:
        content:
          CSharp: public string Id { get; }
          VB: Public ReadOnly Property Id As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.CalendarSystem.Id*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.CalendarSystem.ForId(System.String): 
        NodaTime.CalendarSystem: 
        NodaTime.CalendarSystem.Iso: 
        NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32): 
        NodaTime.CalendarSystem.GetCopticCalendar(System.Int32): 
        NodaTime.CalendarSystem.GetJulianCalendar(System.Int32): 
        NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch): 
    - id: NodaTime.CalendarSystem.Name
      commentId: P:NodaTime.CalendarSystem.Name
      language: CSharp
      name:
        CSharp: Name
        VB: Name
      nameWithType:
        CSharp: CalendarSystem.Name
        VB: CalendarSystem.Name
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.Name
        VB: NodaTime.CalendarSystem.Name
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Name
        path: src/NodaTime/CalendarSystem.cs
        startLine: 405
      summary: "\nReturns the name of this calendar system. Each kind of calendar system has a unique name, but this\ndoes not usually provide enough information for round-tripping. (For example, the name of an\nIslamic calendar system does not indicate which kind of leap cycle it uses, and other calendars\nspecify the minimum number of days in the first week of a year.)\n"
      example: []
      syntax:
        content:
          CSharp: public string Name { get; }
          VB: Public ReadOnly Property Name As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.CalendarSystem.Name*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.CalendarSystem.UsesIsoDayOfWeek
      commentId: P:NodaTime.CalendarSystem.UsesIsoDayOfWeek
      language: CSharp
      name:
        CSharp: UsesIsoDayOfWeek
        VB: UsesIsoDayOfWeek
      nameWithType:
        CSharp: CalendarSystem.UsesIsoDayOfWeek
        VB: CalendarSystem.UsesIsoDayOfWeek
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.UsesIsoDayOfWeek
        VB: NodaTime.CalendarSystem.UsesIsoDayOfWeek
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: UsesIsoDayOfWeek
        path: src/NodaTime/CalendarSystem.cs
        startLine: 412
      summary: "\nReturns whether the day-of-week field refers to ISO days. If true, types such as <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref>\ncan use the <xref href=\"NodaTime.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref> property to avoid using magic numbers.\nThis defaults to true, but can be overridden by specific calendars.\n"
      example: []
      syntax:
        content:
          CSharp: public bool UsesIsoDayOfWeek { get; }
          VB: Public ReadOnly Property UsesIsoDayOfWeek As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: NodaTime.CalendarSystem.UsesIsoDayOfWeek*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDateTime: 
        NodaTime.IsoDayOfWeek: 
    - id: NodaTime.CalendarSystem.MinYear
      commentId: P:NodaTime.CalendarSystem.MinYear
      language: CSharp
      name:
        CSharp: MinYear
        VB: MinYear
      nameWithType:
        CSharp: CalendarSystem.MinYear
        VB: CalendarSystem.MinYear
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.MinYear
        VB: NodaTime.CalendarSystem.MinYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MinYear
        path: src/NodaTime/CalendarSystem.cs
        startLine: 417
      summary: "\nThe minimum valid year (inclusive) within this calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public int MinYear { get; }
          VB: Public ReadOnly Property MinYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.CalendarSystem.MinYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.CalendarSystem.MaxYear
      commentId: P:NodaTime.CalendarSystem.MaxYear
      language: CSharp
      name:
        CSharp: MaxYear
        VB: MaxYear
      nameWithType:
        CSharp: CalendarSystem.MaxYear
        VB: CalendarSystem.MaxYear
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.MaxYear
        VB: NodaTime.CalendarSystem.MaxYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MaxYear
        path: src/NodaTime/CalendarSystem.cs
        startLine: 422
      summary: "\nThe maximum valid year (inclusive) within this calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public int MaxYear { get; }
          VB: Public ReadOnly Property MaxYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.CalendarSystem.MaxYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.CalendarSystem.Eras
      commentId: P:NodaTime.CalendarSystem.Eras
      language: CSharp
      name:
        CSharp: Eras
        VB: Eras
      nameWithType:
        CSharp: CalendarSystem.Eras
        VB: CalendarSystem.Eras
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.Eras
        VB: NodaTime.CalendarSystem.Eras
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Eras
        path: src/NodaTime/CalendarSystem.cs
        startLine: 438
      summary: "\nReturns a read-only list of eras used in this calendar system.\n"
      example: []
      syntax:
        content:
          CSharp: public IList<Era> Eras { get; }
          VB: Public ReadOnly Property Eras As IList(Of Era)
        parameters: []
        return:
          type: System.Collections.Generic.IList{NodaTime.Calendars.Era}
      overload: NodaTime.CalendarSystem.Eras*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32,NodaTime.Calendars.Era)
      commentId: M:NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32,NodaTime.Calendars.Era)
      language: CSharp
      name:
        CSharp: GetAbsoluteYear(Int32, Era)
        VB: GetAbsoluteYear(Int32, Era)
      nameWithType:
        CSharp: CalendarSystem.GetAbsoluteYear(Int32, Era)
        VB: CalendarSystem.GetAbsoluteYear(Int32, Era)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32, NodaTime.Calendars.Era)
        VB: NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32, NodaTime.Calendars.Era)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetAbsoluteYear
        path: src/NodaTime/CalendarSystem.cs
        startLine: 456
      summary: "\nReturns the \"absolute year\" (the one used throughout most of the API, without respect to eras)\nfrom a year-of-era and an era.\n"
      remarks: "\nFor example, in the Gregorian and Julian calendar systems, the BCE era starts at year 1, which is\nequivalent to an \"absolute year\" of 0 (then BCE year 2 has an absolute year of -1, and so on).  The absolute\nyear is the year that is used throughout the API; year-of-era is typically used primarily when formatting\nand parsing date values to and from text.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetAbsoluteYear(int yearOfEra, Era era)
          VB: Public Function GetAbsoluteYear(yearOfEra As Integer, era As Era) As Integer
        parameters:
        - id: yearOfEra
          type: System.Int32
          description: The year within the era.
        - id: era
          type: NodaTime.Calendars.Era
          description: The era in which to consider the year
        return:
          type: System.Int32
          description: The absolute year represented by the specified year of era.
      overload: NodaTime.CalendarSystem.GetAbsoluteYear*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">era</span> is null.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: <span class="paramref">yearOfEra</span> is out of the range of years for the given era.
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">era</span> is not an era used in this calendar.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)
      commentId: M:NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)
      language: CSharp
      name:
        CSharp: GetMaxYearOfEra(Era)
        VB: GetMaxYearOfEra(Era)
      nameWithType:
        CSharp: CalendarSystem.GetMaxYearOfEra(Era)
        VB: CalendarSystem.GetMaxYearOfEra(Era)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)
        VB: NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetMaxYearOfEra
        path: src/NodaTime/CalendarSystem.cs
        startLine: 468
      summary: "\nReturns the maximum valid year-of-era in the given era.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetMaxYearOfEra(Era era)
          VB: Public Function GetMaxYearOfEra(era As Era) As Integer
        parameters:
        - id: era
          type: NodaTime.Calendars.Era
          description: The era in which to find the greatest year
        return:
          type: System.Int32
          description: The maximum valid year in the given era.
      overload: NodaTime.CalendarSystem.GetMaxYearOfEra*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">era</span> is null.
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">era</span> is not an era used in this calendar.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)
      commentId: M:NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)
      language: CSharp
      name:
        CSharp: GetMinYearOfEra(Era)
        VB: GetMinYearOfEra(Era)
      nameWithType:
        CSharp: CalendarSystem.GetMinYearOfEra(Era)
        VB: CalendarSystem.GetMinYearOfEra(Era)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)
        VB: NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetMinYearOfEra
        path: src/NodaTime/CalendarSystem.cs
        startLine: 480
      summary: "\nReturns the minimum valid year-of-era in the given era.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetMinYearOfEra(Era era)
          VB: Public Function GetMinYearOfEra(era As Era) As Integer
        parameters:
        - id: era
          type: NodaTime.Calendars.Era
          description: The era in which to find the greatest year
        return:
          type: System.Int32
          description: The minimum valid year in the given eraera.
      overload: NodaTime.CalendarSystem.GetMinYearOfEra*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">era</span> is null.
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">era</span> is not an era used in this calendar.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.CalendarSystem.ToString
      commentId: M:NodaTime.CalendarSystem.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: CalendarSystem.ToString()
        VB: CalendarSystem.ToString()
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.ToString()
        VB: NodaTime.CalendarSystem.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/CalendarSystem.cs
        startLine: 572
      summary: "\nConverts this calendar system to text by simply returning its unique ID.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: The ID of this calendar system.
      overload: NodaTime.CalendarSystem.ToString*
      overridden: System.Object.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.CalendarSystem.GetDaysInMonth(System.Int32,System.Int32)
      commentId: M:NodaTime.CalendarSystem.GetDaysInMonth(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: GetDaysInMonth(Int32, Int32)
        VB: GetDaysInMonth(Int32, Int32)
      nameWithType:
        CSharp: CalendarSystem.GetDaysInMonth(Int32, Int32)
        VB: CalendarSystem.GetDaysInMonth(Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.GetDaysInMonth(System.Int32, System.Int32)
        VB: NodaTime.CalendarSystem.GetDaysInMonth(System.Int32, System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetDaysInMonth
        path: src/NodaTime/CalendarSystem.cs
        startLine: 601
      summary: "\nReturns the number of days in the given month within the given year.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetDaysInMonth(int year, int month)
          VB: Public Function GetDaysInMonth(year As Integer, month As Integer) As Integer
        parameters:
        - id: year
          type: System.Int32
          description: The year in which to consider the month
        - id: month
          type: System.Int32
          description: The month to determine the number of days in
        return:
          type: System.Int32
          description: The number of days in the given month and year.
      overload: NodaTime.CalendarSystem.GetDaysInMonth*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: >-
          The given year / month combination

          is invalid for this calendar.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.CalendarSystem.IsLeapYear(System.Int32)
      commentId: M:NodaTime.CalendarSystem.IsLeapYear(System.Int32)
      language: CSharp
      name:
        CSharp: IsLeapYear(Int32)
        VB: IsLeapYear(Int32)
      nameWithType:
        CSharp: CalendarSystem.IsLeapYear(Int32)
        VB: CalendarSystem.IsLeapYear(Int32)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.IsLeapYear(System.Int32)
        VB: NodaTime.CalendarSystem.IsLeapYear(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: IsLeapYear
        path: src/NodaTime/CalendarSystem.cs
        startLine: 614
      summary: "\nReturns whether or not the given year is a leap year in this calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public bool IsLeapYear(int year)
          VB: Public Function IsLeapYear(year As Integer) As Boolean
        parameters:
        - id: year
          type: System.Int32
          description: The year to consider.
        return:
          type: System.Boolean
          description: True if the given year is a leap year; false otherwise.
      overload: NodaTime.CalendarSystem.IsLeapYear*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: >-
          The given year is invalid for this calendar.

          Note that some implementations may return a value rather than throw this exception. Failure to throw an

          exception should not be treated as an indication that the year is valid.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.CalendarSystem.GetMaxMonth(System.Int32)
      commentId: M:NodaTime.CalendarSystem.GetMaxMonth(System.Int32)
      language: CSharp
      name:
        CSharp: GetMaxMonth(Int32)
        VB: GetMaxMonth(Int32)
      nameWithType:
        CSharp: CalendarSystem.GetMaxMonth(Int32)
        VB: CalendarSystem.GetMaxMonth(Int32)
      qualifiedName:
        CSharp: NodaTime.CalendarSystem.GetMaxMonth(System.Int32)
        VB: NodaTime.CalendarSystem.GetMaxMonth(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/CalendarSystem.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetMaxMonth
        path: src/NodaTime/CalendarSystem.cs
        startLine: 629
      summary: "\nThe maximum valid month (inclusive) within this calendar in the given year. It is assumed that\nall calendars start with month 1 and go up to this month number in any valid year.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetMaxMonth(int year)
          VB: Public Function GetMaxMonth(year As Integer) As Integer
        parameters:
        - id: year
          type: System.Int32
          description: The year to consider.
        return:
          type: System.Int32
          description: The maximum month number within the given year.
      overload: NodaTime.CalendarSystem.GetMaxMonth*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: >-
          The given year is invalid for this calendar.

          Note that some implementations may return a month rather than throw this exception (for example, if all

          years have the same number of months in this calendar system). Failure to throw an exception should not be

          treated as an indication that the year is valid.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.CalendarSystem: 
      NodaTime.CalendarSystem.Iso: 
      NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32): 
  - id: NodaTime.AmbiguousTimeException
    commentId: T:NodaTime.AmbiguousTimeException
    language: CSharp
    name:
      CSharp: AmbiguousTimeException
      VB: AmbiguousTimeException
    nameWithType:
      CSharp: AmbiguousTimeException
      VB: AmbiguousTimeException
    qualifiedName:
      CSharp: NodaTime.AmbiguousTimeException
      VB: NodaTime.AmbiguousTimeException
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/AmbiguousTimeException.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: AmbiguousTimeException
      path: src/NodaTime/AmbiguousTimeException.cs
      startLine: 36
    summary: "\nException thrown to indicate that the specified local date/time occurs twice\nin a particular time zone due to daylight saving time changes.\n"
    remarks: "\n<p>\nThis occurs for transitions where the clock goes backward (usually by\nan hour). For example, suppose the time zone goes backward\nat 2am, so the second after 01:59:59 becomes 01:00:00. In that case,\ntimes such as 01:30:00 occur twice.\n</p>\n<p>\nThis exception is used to indicate such problems, as they're usually\nnot the same as other <xref href=\"System.ArgumentOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> causes,\nsuch as entering \"15\" for a month number.\n</p>\n<p>\nIn theory this isn't calendar-specific; the local value will be ambiguous in\nthis time zone regardless of the calendar used. However, this exception is\nalways created in conjunction with a specific calendar, which leads to a more\nnatural way of examining its information and constructing an error message.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public sealed class AmbiguousTimeException : ArgumentOutOfRangeException, _Exception, ISerializable
        VB: >-
          <Serializable>

          Public NotInheritable Class AmbiguousTimeException

              Inherits ArgumentOutOfRangeException

              Implements _Exception, ISerializable
    inheritance:
    - System.Object
    - System.Exception
    - System.SystemException
    - System.ArgumentException
    - System.ArgumentOutOfRangeException
    implements:
    - System.Runtime.InteropServices._Exception
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.ArgumentOutOfRangeException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    - System.ArgumentOutOfRangeException.Message
    - System.ArgumentOutOfRangeException.ActualValue
    - System.ArgumentException.ParamName
    - System.Exception.GetBaseException
    - System.Exception.ToString
    - System.Exception.GetType
    - System.Exception.Data
    - System.Exception.InnerException
    - System.Exception.TargetSite
    - System.Exception.StackTrace
    - System.Exception.HelpLink
    - System.Exception.Source
    - System.Exception.HResult
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.MemberwiseClone
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.AmbiguousTimeException.Zone
      commentId: P:NodaTime.AmbiguousTimeException.Zone
      language: CSharp
      name:
        CSharp: Zone
        VB: Zone
      nameWithType:
        CSharp: AmbiguousTimeException.Zone
        VB: AmbiguousTimeException.Zone
      qualifiedName:
        CSharp: NodaTime.AmbiguousTimeException.Zone
        VB: NodaTime.AmbiguousTimeException.Zone
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/AmbiguousTimeException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Zone
        path: src/NodaTime/AmbiguousTimeException.cs
        startLine: 51
      summary: "\nThe time zone in which the local date and time is ambiguous.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTimeZone Zone { get; }
          VB: Public ReadOnly Property Zone As DateTimeZone
        parameters: []
        return:
          type: NodaTime.DateTimeZone
      overload: NodaTime.AmbiguousTimeException.Zone*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.AmbiguousTimeException.EarlierMapping
      commentId: P:NodaTime.AmbiguousTimeException.EarlierMapping
      language: CSharp
      name:
        CSharp: EarlierMapping
        VB: EarlierMapping
      nameWithType:
        CSharp: AmbiguousTimeException.EarlierMapping
        VB: AmbiguousTimeException.EarlierMapping
      qualifiedName:
        CSharp: NodaTime.AmbiguousTimeException.EarlierMapping
        VB: NodaTime.AmbiguousTimeException.EarlierMapping
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/AmbiguousTimeException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: EarlierMapping
        path: src/NodaTime/AmbiguousTimeException.cs
        startLine: 56
      summary: "\nThe earlier of the two occurrences of the local date and time within the time zone.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime EarlierMapping { get; }
          VB: Public ReadOnly Property EarlierMapping As ZonedDateTime
        parameters: []
        return:
          type: NodaTime.ZonedDateTime
      overload: NodaTime.AmbiguousTimeException.EarlierMapping*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.AmbiguousTimeException.LaterMapping
      commentId: P:NodaTime.AmbiguousTimeException.LaterMapping
      language: CSharp
      name:
        CSharp: LaterMapping
        VB: LaterMapping
      nameWithType:
        CSharp: AmbiguousTimeException.LaterMapping
        VB: AmbiguousTimeException.LaterMapping
      qualifiedName:
        CSharp: NodaTime.AmbiguousTimeException.LaterMapping
        VB: NodaTime.AmbiguousTimeException.LaterMapping
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/AmbiguousTimeException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: LaterMapping
        path: src/NodaTime/AmbiguousTimeException.cs
        startLine: 61
      summary: "\nThe later of the two occurrences of the local date and time within the time zone.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime LaterMapping { get; }
          VB: Public ReadOnly Property LaterMapping As ZonedDateTime
        parameters: []
        return:
          type: NodaTime.ZonedDateTime
      overload: NodaTime.AmbiguousTimeException.LaterMapping*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.AmbiguousTimeException.#ctor(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      commentId: M:NodaTime.AmbiguousTimeException.#ctor(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: AmbiguousTimeException(ZonedDateTime, ZonedDateTime)
        VB: AmbiguousTimeException(ZonedDateTime, ZonedDateTime)
      nameWithType:
        CSharp: AmbiguousTimeException.AmbiguousTimeException(ZonedDateTime, ZonedDateTime)
        VB: AmbiguousTimeException.AmbiguousTimeException(ZonedDateTime, ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.AmbiguousTimeException.AmbiguousTimeException(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
        VB: NodaTime.AmbiguousTimeException.AmbiguousTimeException(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/AmbiguousTimeException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/AmbiguousTimeException.cs
        startLine: 77
      summary: "\nConstructs an instance from the given information.\n"
      remarks: "\n<p>\nUser code is unlikely to need to deliberately call this constructor except\npossibly for testing.\n</p>\n<p>\nThe two mappings must have the same local time and time zone.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public AmbiguousTimeException(ZonedDateTime earlierMapping, ZonedDateTime laterMapping)
          VB: Public Sub New(earlierMapping As ZonedDateTime, laterMapping As ZonedDateTime)
        parameters:
        - id: earlierMapping
          type: NodaTime.ZonedDateTime
          description: The earlier possible mapping
        - id: laterMapping
          type: NodaTime.ZonedDateTime
          description: The later possible mapping
      overload: NodaTime.AmbiguousTimeException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      System.ArgumentOutOfRangeException: 
  - id: NodaTime.DateTimeZoneProviders
    commentId: T:NodaTime.DateTimeZoneProviders
    language: CSharp
    name:
      CSharp: DateTimeZoneProviders
      VB: DateTimeZoneProviders
    nameWithType:
      CSharp: DateTimeZoneProviders
      VB: DateTimeZoneProviders
    qualifiedName:
      CSharp: NodaTime.DateTimeZoneProviders
      VB: NodaTime.DateTimeZoneProviders
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/DateTimeZoneProviders.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: DateTimeZoneProviders
      path: src/NodaTime/DateTimeZoneProviders.cs
      startLine: 14
    summary: "\nStatic access to date/time zone providers built into Noda Time and for global configuration where this is unavoidable.\nAll properties are thread-safe, and the providers returned by the read-only properties cache their results.\n"
    example: []
    syntax:
      content:
        CSharp: public static class DateTimeZoneProviders
        VB: Public Module DateTimeZoneProviders
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: NodaTime.DateTimeZoneProviders.Tzdb
      commentId: P:NodaTime.DateTimeZoneProviders.Tzdb
      language: CSharp
      name:
        CSharp: Tzdb
        VB: Tzdb
      nameWithType:
        CSharp: DateTimeZoneProviders.Tzdb
        VB: DateTimeZoneProviders.Tzdb
      qualifiedName:
        CSharp: NodaTime.DateTimeZoneProviders.Tzdb
        VB: NodaTime.DateTimeZoneProviders.Tzdb
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZoneProviders.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Tzdb
        path: src/NodaTime/DateTimeZoneProviders.cs
        startLine: 21
      summary: "\nGets a time zone provider which uses a <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref>.\nThe underlying source is <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource.Default\" data-throw-if-not-resolved=\"false\"></xref>, which is initialized from\nresources within the NodaTime assembly.\n"
      example: []
      syntax:
        content:
          CSharp: public static IDateTimeZoneProvider Tzdb { get; }
          VB: Public Shared ReadOnly Property Tzdb As IDateTimeZoneProvider
        parameters: []
        return:
          type: NodaTime.IDateTimeZoneProvider
      overload: NodaTime.DateTimeZoneProviders.Tzdb*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource: 
        NodaTime.TimeZones.TzdbDateTimeZoneSource.Default: 
    - id: NodaTime.DateTimeZoneProviders.Default
      commentId: P:NodaTime.DateTimeZoneProviders.Default
      language: CSharp
      name:
        CSharp: Default
        VB: Default
      nameWithType:
        CSharp: DateTimeZoneProviders.Default
        VB: DateTimeZoneProviders.Default
      qualifiedName:
        CSharp: NodaTime.DateTimeZoneProviders.Default
        VB: NodaTime.DateTimeZoneProviders.Default
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZoneProviders.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Default
        path: src/NodaTime/DateTimeZoneProviders.cs
        startLine: 39
      summary: "\nGets the TZDB time zone provider.\nThis always returns the same value as the <xref href=\"NodaTime.DateTimeZoneProviders.Tzdb\" data-throw-if-not-resolved=\"false\"></xref> property.\n"
      remarks: This method is not available in the PCL version, as it was made obsolete in Noda Time 1.1.
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("Use DateTimeZoneProviders.Tzdb instead")]

            public static IDateTimeZoneProvider Default { get; }
          VB: >-
            <Obsolete("Use DateTimeZoneProviders.Tzdb instead")>

            Public Shared ReadOnly Property Default As IDateTimeZoneProvider
        parameters: []
        return:
          type: NodaTime.IDateTimeZoneProvider
      overload: NodaTime.DateTimeZoneProviders.Default*
      seealso:
      - linkId: NodaTime.DateTimeZoneProviders.Tzdb
        commentId: P:NodaTime.DateTimeZoneProviders.Tzdb
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: Use DateTimeZoneProviders.Tzdb instead
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.DateTimeZoneProviders.Tzdb: 
    - id: NodaTime.DateTimeZoneProviders.Bcl
      commentId: P:NodaTime.DateTimeZoneProviders.Bcl
      language: CSharp
      name:
        CSharp: Bcl
        VB: Bcl
      nameWithType:
        CSharp: DateTimeZoneProviders.Bcl
        VB: DateTimeZoneProviders.Bcl
      qualifiedName:
        CSharp: NodaTime.DateTimeZoneProviders.Bcl
        VB: NodaTime.DateTimeZoneProviders.Bcl
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZoneProviders.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Bcl
        path: src/NodaTime/DateTimeZoneProviders.cs
        startLine: 55
      summary: "\nGets a time zone provider which uses a <xref href=\"NodaTime.TimeZones.BclDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref>.\nThis property is not available on the PCL build of Noda Time.\n"
      example: []
      syntax:
        content:
          CSharp: public static IDateTimeZoneProvider Bcl { get; }
          VB: Public Shared ReadOnly Property Bcl As IDateTimeZoneProvider
        parameters: []
        return:
          type: NodaTime.IDateTimeZoneProvider
      overload: NodaTime.DateTimeZoneProviders.Bcl*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.BclDateTimeZoneSource: 
    - id: NodaTime.DateTimeZoneProviders.Serialization
      commentId: P:NodaTime.DateTimeZoneProviders.Serialization
      language: CSharp
      name:
        CSharp: Serialization
        VB: Serialization
      nameWithType:
        CSharp: DateTimeZoneProviders.Serialization
        VB: DateTimeZoneProviders.Serialization
      qualifiedName:
        CSharp: NodaTime.DateTimeZoneProviders.Serialization
        VB: NodaTime.DateTimeZoneProviders.Serialization
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZoneProviders.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Serialization
        path: src/NodaTime/DateTimeZoneProviders.cs
        startLine: 71
      summary: "\nThe <xref href=\"NodaTime.IDateTimeZoneProvider\" data-throw-if-not-resolved=\"false\"></xref> to use to interpret a time zone ID read as part of\nXML or binary serialization.\n"
      remarks: "\nThis property defaults to <xref href=\"NodaTime.DateTimeZoneProviders.Tzdb\" data-throw-if-not-resolved=\"false\"></xref>. The mere existence of\nthis property is unfortunate, but XML and binary serialization in .NET provide no simple way of configuring\nappropriate context. It is expected that any single application is unlikely to want to serialize\n<code>ZonedDateTime</code> values using different time zone providers.\n"
      example: []
      syntax:
        content:
          CSharp: public static IDateTimeZoneProvider Serialization { get; set; }
          VB: Public Shared Property Serialization As IDateTimeZoneProvider
        parameters: []
        return:
          type: NodaTime.IDateTimeZoneProvider
      overload: NodaTime.DateTimeZoneProviders.Serialization*
      modifiers:
        CSharp:
        - public
        - static
        - get
        - set
        VB:
        - Public
        - Shared
      references:
        NodaTime.IDateTimeZoneProvider: 
        NodaTime.DateTimeZoneProviders.Tzdb: 
  - id: NodaTime.OffsetDateTime
    commentId: T:NodaTime.OffsetDateTime
    language: CSharp
    name:
      CSharp: OffsetDateTime
      VB: OffsetDateTime
    nameWithType:
      CSharp: OffsetDateTime
      VB: OffsetDateTime
    qualifiedName:
      CSharp: NodaTime.OffsetDateTime
      VB: NodaTime.OffsetDateTime
    type: Struct
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/OffsetDateTime.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: OffsetDateTime
      path: src/NodaTime/OffsetDateTime.cs
      startLine: 31
    summary: "\nA local date and time in a particular calendar system, combined with an offset from UTC. This is\nbroadly similar to <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> in the BCL.\n"
    remarks: "\n<p>\nA value of this type unambiguously represents both a local time and an instant on the timeline,\nbut does not have a well-defined time zone. This means you cannot reliably know what the local\ntime would be five minutes later, for example. While this doesn't sound terribly useful, it's very common\nin text representations.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public struct OffsetDateTime : IEquatable<OffsetDateTime>, IFormattable, IXmlSerializable, ISerializable
        VB: >-
          <Serializable>

          Public Structure OffsetDateTime

              Implements IEquatable(Of OffsetDateTime), IFormattable, IXmlSerializable, ISerializable
    implements:
    - System.IEquatable{NodaTime.OffsetDateTime}
    - System.IFormattable
    - System.Xml.Serialization.IXmlSerializable
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: NodaTime.OffsetDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.Offset)
      commentId: M:NodaTime.OffsetDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: OffsetDateTime(LocalDateTime, Offset)
        VB: OffsetDateTime(LocalDateTime, Offset)
      nameWithType:
        CSharp: OffsetDateTime.OffsetDateTime(LocalDateTime, Offset)
        VB: OffsetDateTime.OffsetDateTime(LocalDateTime, Offset)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.OffsetDateTime(NodaTime.LocalDateTime, NodaTime.Offset)
        VB: NodaTime.OffsetDateTime.OffsetDateTime(NodaTime.LocalDateTime, NodaTime.Offset)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 46
      summary: "\nConstructs a new offset date/time with the given local date and time, and the given offset from UTC.\n"
      example: []
      syntax:
        content:
          CSharp: public OffsetDateTime(LocalDateTime localDateTime, Offset offset)
          VB: Public Sub New(localDateTime As LocalDateTime, offset As Offset)
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: Local date and time to represent
        - id: offset
          type: NodaTime.Offset
          description: Offset from UTC
      overload: NodaTime.OffsetDateTime.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.OffsetDateTime.Calendar
      commentId: P:NodaTime.OffsetDateTime.Calendar
      language: CSharp
      name:
        CSharp: Calendar
        VB: Calendar
      nameWithType:
        CSharp: OffsetDateTime.Calendar
        VB: OffsetDateTime.Calendar
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Calendar
        VB: NodaTime.OffsetDateTime.Calendar
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Calendar
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 53
      summary: Gets the calendar system associated with this local date and time.
      example: []
      syntax:
        content:
          CSharp: public CalendarSystem Calendar { get; }
          VB: Public ReadOnly Property Calendar As CalendarSystem
        parameters: []
        return:
          type: NodaTime.CalendarSystem
      overload: NodaTime.OffsetDateTime.Calendar*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.Year
      commentId: P:NodaTime.OffsetDateTime.Year
      language: CSharp
      name:
        CSharp: Year
        VB: Year
      nameWithType:
        CSharp: OffsetDateTime.Year
        VB: OffsetDateTime.Year
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Year
        VB: NodaTime.OffsetDateTime.Year
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Year
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 58
      summary: Gets the year of this offset date and time.
      remarks: >-
        This returns the "absolute year", so, for the ISO calendar,

        a value of 0 means 1 BC, for example.
      example: []
      syntax:
        content:
          CSharp: public int Year { get; }
          VB: Public ReadOnly Property Year As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.Year*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.Month
      commentId: P:NodaTime.OffsetDateTime.Month
      language: CSharp
      name:
        CSharp: Month
        VB: Month
      nameWithType:
        CSharp: OffsetDateTime.Month
        VB: OffsetDateTime.Month
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Month
        VB: NodaTime.OffsetDateTime.Month
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Month
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 61
      summary: Gets the month of this offset date and time within the year.
      example: []
      syntax:
        content:
          CSharp: public int Month { get; }
          VB: Public ReadOnly Property Month As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.Month*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.Day
      commentId: P:NodaTime.OffsetDateTime.Day
      language: CSharp
      name:
        CSharp: Day
        VB: Day
      nameWithType:
        CSharp: OffsetDateTime.Day
        VB: OffsetDateTime.Day
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Day
        VB: NodaTime.OffsetDateTime.Day
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Day
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 64
      summary: Gets the day of this offset date and time within the month.
      example: []
      syntax:
        content:
          CSharp: public int Day { get; }
          VB: Public ReadOnly Property Day As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.Day*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.IsoDayOfWeek
      commentId: P:NodaTime.OffsetDateTime.IsoDayOfWeek
      language: CSharp
      name:
        CSharp: IsoDayOfWeek
        VB: IsoDayOfWeek
      nameWithType:
        CSharp: OffsetDateTime.IsoDayOfWeek
        VB: OffsetDateTime.IsoDayOfWeek
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.IsoDayOfWeek
        VB: NodaTime.OffsetDateTime.IsoDayOfWeek
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: IsoDayOfWeek
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 72
      summary: "\nGets the week day of this offset date and time expressed as an <xref href=\"NodaTime.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref> value,\nfor calendars which use ISO days of the week.\n"
      example: []
      syntax:
        content:
          CSharp: public IsoDayOfWeek IsoDayOfWeek { get; }
          VB: Public ReadOnly Property IsoDayOfWeek As IsoDayOfWeek
        parameters: []
        return:
          type: NodaTime.IsoDayOfWeek
      overload: NodaTime.OffsetDateTime.IsoDayOfWeek*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The underlying calendar doesn't use ISO days of the week.
      seealso:
      - linkId: NodaTime.OffsetDateTime.DayOfWeek
        commentId: P:NodaTime.OffsetDateTime.DayOfWeek
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.IsoDayOfWeek: 
        NodaTime.OffsetDateTime.DayOfWeek: 
    - id: NodaTime.OffsetDateTime.DayOfWeek
      commentId: P:NodaTime.OffsetDateTime.DayOfWeek
      language: CSharp
      name:
        CSharp: DayOfWeek
        VB: DayOfWeek
      nameWithType:
        CSharp: OffsetDateTime.DayOfWeek
        VB: OffsetDateTime.DayOfWeek
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.DayOfWeek
        VB: NodaTime.OffsetDateTime.DayOfWeek
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DayOfWeek
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 81
      summary: "\nGets the week day of this offset date and time as a number.\n"
      remarks: "\nFor calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.\n"
      example: []
      syntax:
        content:
          CSharp: public int DayOfWeek { get; }
          VB: Public ReadOnly Property DayOfWeek As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.DayOfWeek*
      seealso:
      - linkId: NodaTime.OffsetDateTime.IsoDayOfWeek
        commentId: P:NodaTime.OffsetDateTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.OffsetDateTime.IsoDayOfWeek: 
    - id: NodaTime.OffsetDateTime.WeekYear
      commentId: P:NodaTime.OffsetDateTime.WeekYear
      language: CSharp
      name:
        CSharp: WeekYear
        VB: WeekYear
      nameWithType:
        CSharp: OffsetDateTime.WeekYear
        VB: OffsetDateTime.WeekYear
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.WeekYear
        VB: NodaTime.OffsetDateTime.WeekYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WeekYear
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 101
      summary: "\nGets the \"week year\" of this offset date and time.\n"
      remarks: "\n<p>\nThe WeekYear is the year that matches with the <xref href=\"NodaTime.OffsetDateTime.WeekOfWeekYear\" data-throw-if-not-resolved=\"false\"></xref> field.\nIn the standard ISO8601 week algorithm, the first week of the year\nis that in which at least 4 days are in the year. As a result of this\ndefinition, day 1 of the first week may be in the previous year.\nThe WeekYear allows you to query the effective year for that day.\n</p>\n<p>\nFor example, January 1st 2011 was a Saturday, so only two days of that week\n(Saturday and Sunday) were in 2011. Therefore January 1st is part of\nweek 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,\nso is part of week 1 of WeekYear 2013.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public int WeekYear { get; }
          VB: Public ReadOnly Property WeekYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.WeekYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.OffsetDateTime.WeekOfWeekYear: 
    - id: NodaTime.OffsetDateTime.WeekOfWeekYear
      commentId: P:NodaTime.OffsetDateTime.WeekOfWeekYear
      language: CSharp
      name:
        CSharp: WeekOfWeekYear
        VB: WeekOfWeekYear
      nameWithType:
        CSharp: OffsetDateTime.WeekOfWeekYear
        VB: OffsetDateTime.WeekOfWeekYear
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.WeekOfWeekYear
        VB: NodaTime.OffsetDateTime.WeekOfWeekYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WeekOfWeekYear
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 104
      summary: Gets the week within the WeekYear. See <xref href="NodaTime.OffsetDateTime.WeekYear" data-throw-if-not-resolved="false"></xref> for more details.
      example: []
      syntax:
        content:
          CSharp: public int WeekOfWeekYear { get; }
          VB: Public ReadOnly Property WeekOfWeekYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.WeekOfWeekYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.OffsetDateTime.WeekYear: 
    - id: NodaTime.OffsetDateTime.YearOfCentury
      commentId: P:NodaTime.OffsetDateTime.YearOfCentury
      language: CSharp
      name:
        CSharp: YearOfCentury
        VB: YearOfCentury
      nameWithType:
        CSharp: OffsetDateTime.YearOfCentury
        VB: OffsetDateTime.YearOfCentury
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.YearOfCentury
        VB: NodaTime.OffsetDateTime.YearOfCentury
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: YearOfCentury
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 108
      summary: Gets the year of this offset date and time within the century.
      remarks: This always returns a value in the range 0 to 99 inclusive.
      example: []
      syntax:
        content:
          CSharp: public int YearOfCentury { get; }
          VB: Public ReadOnly Property YearOfCentury As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.YearOfCentury*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.YearOfEra
      commentId: P:NodaTime.OffsetDateTime.YearOfEra
      language: CSharp
      name:
        CSharp: YearOfEra
        VB: YearOfEra
      nameWithType:
        CSharp: OffsetDateTime.YearOfEra
        VB: OffsetDateTime.YearOfEra
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.YearOfEra
        VB: NodaTime.OffsetDateTime.YearOfEra
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: YearOfEra
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 111
      summary: Gets the year of this offset date and time within the era.
      example: []
      syntax:
        content:
          CSharp: public int YearOfEra { get; }
          VB: Public ReadOnly Property YearOfEra As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.YearOfEra*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.Era
      commentId: P:NodaTime.OffsetDateTime.Era
      language: CSharp
      name:
        CSharp: Era
        VB: Era
      nameWithType:
        CSharp: OffsetDateTime.Era
        VB: OffsetDateTime.Era
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Era
        VB: NodaTime.OffsetDateTime.Era
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Era
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 114
      summary: Gets the era of this offset date and time.
      example: []
      syntax:
        content:
          CSharp: public Era Era { get; }
          VB: Public ReadOnly Property Era As Era
        parameters: []
        return:
          type: NodaTime.Calendars.Era
      overload: NodaTime.OffsetDateTime.Era*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.DayOfYear
      commentId: P:NodaTime.OffsetDateTime.DayOfYear
      language: CSharp
      name:
        CSharp: DayOfYear
        VB: DayOfYear
      nameWithType:
        CSharp: OffsetDateTime.DayOfYear
        VB: OffsetDateTime.DayOfYear
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.DayOfYear
        VB: NodaTime.OffsetDateTime.DayOfYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DayOfYear
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 117
      summary: Gets the day of this offset date and time within the year.
      example: []
      syntax:
        content:
          CSharp: public int DayOfYear { get; }
          VB: Public ReadOnly Property DayOfYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.DayOfYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.Hour
      commentId: P:NodaTime.OffsetDateTime.Hour
      language: CSharp
      name:
        CSharp: Hour
        VB: Hour
      nameWithType:
        CSharp: OffsetDateTime.Hour
        VB: OffsetDateTime.Hour
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Hour
        VB: NodaTime.OffsetDateTime.Hour
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Hour
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 122
      summary: "\nGets the hour of day of this offset date and time, in the range 0 to 23 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Hour { get; }
          VB: Public ReadOnly Property Hour As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.Hour*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.ClockHourOfHalfDay
      commentId: P:NodaTime.OffsetDateTime.ClockHourOfHalfDay
      language: CSharp
      name:
        CSharp: ClockHourOfHalfDay
        VB: ClockHourOfHalfDay
      nameWithType:
        CSharp: OffsetDateTime.ClockHourOfHalfDay
        VB: OffsetDateTime.ClockHourOfHalfDay
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.ClockHourOfHalfDay
        VB: NodaTime.OffsetDateTime.ClockHourOfHalfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ClockHourOfHalfDay
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 127
      summary: "\nGets the hour of the half-day of this date and time, in the range 1 to 12 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int ClockHourOfHalfDay { get; }
          VB: Public ReadOnly Property ClockHourOfHalfDay As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.ClockHourOfHalfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.Minute
      commentId: P:NodaTime.OffsetDateTime.Minute
      language: CSharp
      name:
        CSharp: Minute
        VB: Minute
      nameWithType:
        CSharp: OffsetDateTime.Minute
        VB: OffsetDateTime.Minute
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Minute
        VB: NodaTime.OffsetDateTime.Minute
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minute
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 132
      summary: "\nGets the minute of this offset date and time, in the range 0 to 59 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Minute { get; }
          VB: Public ReadOnly Property Minute As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.Minute*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.Second
      commentId: P:NodaTime.OffsetDateTime.Second
      language: CSharp
      name:
        CSharp: Second
        VB: Second
      nameWithType:
        CSharp: OffsetDateTime.Second
        VB: OffsetDateTime.Second
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Second
        VB: NodaTime.OffsetDateTime.Second
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Second
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 137
      summary: "\nGets the second of this offset date and time within the minute, in the range 0 to 59 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Second { get; }
          VB: Public ReadOnly Property Second As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.Second*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.Millisecond
      commentId: P:NodaTime.OffsetDateTime.Millisecond
      language: CSharp
      name:
        CSharp: Millisecond
        VB: Millisecond
      nameWithType:
        CSharp: OffsetDateTime.Millisecond
        VB: OffsetDateTime.Millisecond
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Millisecond
        VB: NodaTime.OffsetDateTime.Millisecond
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Millisecond
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 142
      summary: "\nGets the millisecond of this offset date and time within the second, in the range 0 to 999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Millisecond { get; }
          VB: Public ReadOnly Property Millisecond As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.Millisecond*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.TickOfSecond
      commentId: P:NodaTime.OffsetDateTime.TickOfSecond
      language: CSharp
      name:
        CSharp: TickOfSecond
        VB: TickOfSecond
      nameWithType:
        CSharp: OffsetDateTime.TickOfSecond
        VB: OffsetDateTime.TickOfSecond
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.TickOfSecond
        VB: NodaTime.OffsetDateTime.TickOfSecond
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TickOfSecond
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 147
      summary: "\nGets the tick of this offset date and time within the second, in the range 0 to 9,999,999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int TickOfSecond { get; }
          VB: Public ReadOnly Property TickOfSecond As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.OffsetDateTime.TickOfSecond*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.TickOfDay
      commentId: P:NodaTime.OffsetDateTime.TickOfDay
      language: CSharp
      name:
        CSharp: TickOfDay
        VB: TickOfDay
      nameWithType:
        CSharp: OffsetDateTime.TickOfDay
        VB: OffsetDateTime.TickOfDay
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.TickOfDay
        VB: NodaTime.OffsetDateTime.TickOfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TickOfDay
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 152
      summary: "\nGets the tick of this offset date and time within the day, in the range 0 to 863,999,999,999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public long TickOfDay { get; }
          VB: Public ReadOnly Property TickOfDay As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.OffsetDateTime.TickOfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.LocalDateTime
      commentId: P:NodaTime.OffsetDateTime.LocalDateTime
      language: CSharp
      name:
        CSharp: LocalDateTime
        VB: LocalDateTime
      nameWithType:
        CSharp: OffsetDateTime.LocalDateTime
        VB: OffsetDateTime.LocalDateTime
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.LocalDateTime
        VB: NodaTime.OffsetDateTime.LocalDateTime
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: LocalDateTime
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 157
      summary: "\nReturns the local date and time represented within this offset date and time.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime LocalDateTime { get; }
          VB: Public ReadOnly Property LocalDateTime As LocalDateTime
        parameters: []
        return:
          type: NodaTime.LocalDateTime
      overload: NodaTime.OffsetDateTime.LocalDateTime*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.Date
      commentId: P:NodaTime.OffsetDateTime.Date
      language: CSharp
      name:
        CSharp: Date
        VB: Date
      nameWithType:
        CSharp: OffsetDateTime.Date
        VB: OffsetDateTime.Date
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Date
        VB: NodaTime.OffsetDateTime.Date
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Date
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 164
      summary: "\nGets the local date represented by this offset date and time. The returned <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref>\nwill have the same calendar system and return the same values for each of the date-based calendar\nproperties (Year, MonthOfYear and so on), but will not have any offset information.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate Date { get; }
          VB: Public ReadOnly Property Date As LocalDate
        parameters: []
        return:
          type: NodaTime.LocalDate
      overload: NodaTime.OffsetDateTime.Date*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDate: 
    - id: NodaTime.OffsetDateTime.TimeOfDay
      commentId: P:NodaTime.OffsetDateTime.TimeOfDay
      language: CSharp
      name:
        CSharp: TimeOfDay
        VB: TimeOfDay
      nameWithType:
        CSharp: OffsetDateTime.TimeOfDay
        VB: OffsetDateTime.TimeOfDay
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.TimeOfDay
        VB: NodaTime.OffsetDateTime.TimeOfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TimeOfDay
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 171
      summary: "\nGets the time portion of this offset date and time. The returned <xref href=\"NodaTime.LocalTime\" data-throw-if-not-resolved=\"false\"></xref> will\nreturn the same values for each of the time-based properties (Hour, Minute and so on), but\nwill not have any offset information.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime TimeOfDay { get; }
          VB: Public ReadOnly Property TimeOfDay As LocalTime
        parameters: []
        return:
          type: NodaTime.LocalTime
      overload: NodaTime.OffsetDateTime.TimeOfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalTime: 
    - id: NodaTime.OffsetDateTime.Offset
      commentId: P:NodaTime.OffsetDateTime.Offset
      language: CSharp
      name:
        CSharp: Offset
        VB: Offset
      nameWithType:
        CSharp: OffsetDateTime.Offset
        VB: OffsetDateTime.Offset
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Offset
        VB: NodaTime.OffsetDateTime.Offset
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Offset
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 176
      summary: "\nReturns the offset from UTC.\n"
      example: []
      syntax:
        content:
          CSharp: public Offset Offset { get; }
          VB: Public ReadOnly Property Offset As Offset
        parameters: []
        return:
          type: NodaTime.Offset
      overload: NodaTime.OffsetDateTime.Offset*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.OffsetDateTime.ToInstant
      commentId: M:NodaTime.OffsetDateTime.ToInstant
      language: CSharp
      name:
        CSharp: ToInstant()
        VB: ToInstant()
      nameWithType:
        CSharp: OffsetDateTime.ToInstant()
        VB: OffsetDateTime.ToInstant()
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.ToInstant()
        VB: NodaTime.OffsetDateTime.ToInstant()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToInstant
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 182
      summary: "\nConverts this offset date and time to an instant in time by subtracting the offset from the local date and time.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant ToInstant()
          VB: Public Function ToInstant As Instant
        return:
          type: NodaTime.Instant
          description: The instant represented by this offset date and time
      overload: NodaTime.OffsetDateTime.ToInstant*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.OffsetDateTime.InFixedZone
      commentId: M:NodaTime.OffsetDateTime.InFixedZone
      language: CSharp
      name:
        CSharp: InFixedZone()
        VB: InFixedZone()
      nameWithType:
        CSharp: OffsetDateTime.InFixedZone()
        VB: OffsetDateTime.InFixedZone()
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.InFixedZone()
        VB: NodaTime.OffsetDateTime.InFixedZone()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: InFixedZone
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 201
      summary: "\nReturns this value as a <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      remarks: "\n<p>\nThis method returns a <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> with the same local date and time as this value, using a\nfixed time zone with the same offset as the offset for this value.\n</p>\n<p>\nNote that because the resulting <code>ZonedDateTime</code> has a fixed time zone, it is generally not useful to\nuse this result for arithmetic operations, as the zone will not adjust to account for daylight savings.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime InFixedZone()
          VB: Public Function InFixedZone As ZonedDateTime
        return:
          type: NodaTime.ZonedDateTime
          description: A zoned date/time with the same local time and a fixed time zone using the offset from this value.
      overload: NodaTime.OffsetDateTime.InFixedZone*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.OffsetDateTime.ToDateTimeOffset
      commentId: M:NodaTime.OffsetDateTime.ToDateTimeOffset
      language: CSharp
      name:
        CSharp: ToDateTimeOffset()
        VB: ToDateTimeOffset()
      nameWithType:
        CSharp: OffsetDateTime.ToDateTimeOffset()
        VB: OffsetDateTime.ToDateTimeOffset()
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.ToDateTimeOffset()
        VB: NodaTime.OffsetDateTime.ToDateTimeOffset()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToDateTimeOffset
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 211
      summary: "\nReturns the BCL <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> corresponding to this offset date and time.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTimeOffset ToDateTimeOffset()
          VB: Public Function ToDateTimeOffset As DateTimeOffset
        return:
          type: System.DateTimeOffset
          description: >-
            A DateTimeOffset with the same local date/time and offset as this. The <xref href="System.DateTime" data-throw-if-not-resolved="false"></xref> part of

            the result always has a "kind" of Unspecified.
      overload: NodaTime.OffsetDateTime.ToDateTimeOffset*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.DateTimeOffset: 
        System.DateTime: 
    - id: NodaTime.OffsetDateTime.FromDateTimeOffset(System.DateTimeOffset)
      commentId: M:NodaTime.OffsetDateTime.FromDateTimeOffset(System.DateTimeOffset)
      language: CSharp
      name:
        CSharp: FromDateTimeOffset(DateTimeOffset)
        VB: FromDateTimeOffset(DateTimeOffset)
      nameWithType:
        CSharp: OffsetDateTime.FromDateTimeOffset(DateTimeOffset)
        VB: OffsetDateTime.FromDateTimeOffset(DateTimeOffset)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.FromDateTimeOffset(System.DateTimeOffset)
        VB: NodaTime.OffsetDateTime.FromDateTimeOffset(System.DateTimeOffset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromDateTimeOffset
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 222
      summary: "\nBuilds an <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> from a BCL <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> by converting\nthe <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> part to a <xref href=\"NodaTime.OffsetDateTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref>, and the offset part to an <xref href=\"NodaTime.OffsetDateTime.Offset\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static OffsetDateTime FromDateTimeOffset(DateTimeOffset dateTimeOffset)
          VB: Public Shared Function FromDateTimeOffset(dateTimeOffset As DateTimeOffset) As OffsetDateTime
        parameters:
        - id: dateTimeOffset
          type: System.DateTimeOffset
          description: DateTimeOffset to convert
        return:
          type: NodaTime.OffsetDateTime
          description: The converted offset date and time
      overload: NodaTime.OffsetDateTime.FromDateTimeOffset*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.OffsetDateTime: 
        System.DateTimeOffset: 
        System.DateTime: 
        NodaTime.OffsetDateTime.LocalDateTime: 
        NodaTime.OffsetDateTime.Offset: 
    - id: NodaTime.OffsetDateTime.WithCalendar(NodaTime.CalendarSystem)
      commentId: M:NodaTime.OffsetDateTime.WithCalendar(NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: WithCalendar(CalendarSystem)
        VB: WithCalendar(CalendarSystem)
      nameWithType:
        CSharp: OffsetDateTime.WithCalendar(CalendarSystem)
        VB: OffsetDateTime.WithCalendar(CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.WithCalendar(NodaTime.CalendarSystem)
        VB: NodaTime.OffsetDateTime.WithCalendar(NodaTime.CalendarSystem)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCalendar
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 236
      summary: "\nCreates a new OffsetDateTime representing the same physical date, time and offset, but in a different calendar.\nThe returned OffsetDateTime is likely to have different date field values to this one.\nFor example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public OffsetDateTime WithCalendar(CalendarSystem calendarSystem)
          VB: Public Function WithCalendar(calendarSystem As CalendarSystem) As OffsetDateTime
        parameters:
        - id: calendarSystem
          type: NodaTime.CalendarSystem
          description: The calendar system to convert this local date to.
        return:
          type: NodaTime.OffsetDateTime
          description: The converted OffsetDateTime.
      overload: NodaTime.OffsetDateTime.WithCalendar*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">calendarSystem</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.OffsetDateTime.GetHashCode
      commentId: M:NodaTime.OffsetDateTime.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: OffsetDateTime.GetHashCode()
        VB: OffsetDateTime.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.GetHashCode()
        VB: NodaTime.OffsetDateTime.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 245
      summary: "\nReturns a hash code for this local date.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: A hash code for this local date.
      overload: NodaTime.OffsetDateTime.GetHashCode*
      overridden: System.ValueType.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.OffsetDateTime.Equals(System.Object)
      commentId: M:NodaTime.OffsetDateTime.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: OffsetDateTime.Equals(Object)
        VB: OffsetDateTime.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Equals(System.Object)
        VB: NodaTime.OffsetDateTime.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 259
      summary: "\nCompares two <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> values for equality. This requires\nthat the local date/time values be the same (in the same calendar) and the offsets.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: The object to compare this date with.
        return:
          type: System.Boolean
          description: True if the given value is another offset date/time equal to this one; false otherwise.
      overload: NodaTime.OffsetDateTime.Equals*
      overridden: System.ValueType.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        NodaTime.OffsetDateTime: 
    - id: NodaTime.OffsetDateTime.Equals(NodaTime.OffsetDateTime)
      commentId: M:NodaTime.OffsetDateTime.Equals(NodaTime.OffsetDateTime)
      language: CSharp
      name:
        CSharp: Equals(OffsetDateTime)
        VB: Equals(OffsetDateTime)
      nameWithType:
        CSharp: OffsetDateTime.Equals(OffsetDateTime)
        VB: OffsetDateTime.Equals(OffsetDateTime)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Equals(NodaTime.OffsetDateTime)
        VB: NodaTime.OffsetDateTime.Equals(NodaTime.OffsetDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 274
      summary: "\nCompares two <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> values for equality. This requires\nthat the local date/time values be the same (in the same calendar) and the offsets.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(OffsetDateTime other)
          VB: Public Function Equals(other As OffsetDateTime) As Boolean
        parameters:
        - id: other
          type: NodaTime.OffsetDateTime
          description: The value to compare this offset date/time with.
        return:
          type: System.Boolean
          description: True if the given value is another offset date/time equal to this one; false otherwise.
      overload: NodaTime.OffsetDateTime.Equals*
      implements:
      - System.IEquatable{NodaTime.OffsetDateTime}.Equals(NodaTime.OffsetDateTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.OffsetDateTime: 
    - id: NodaTime.OffsetDateTime.ToString
      commentId: M:NodaTime.OffsetDateTime.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: OffsetDateTime.ToString()
        VB: OffsetDateTime.ToString()
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.ToString()
        VB: NodaTime.OffsetDateTime.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 286
      summary: "\nReturns a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      overload: NodaTime.OffsetDateTime.ToString*
      overridden: System.ValueType.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.String: 
    - id: NodaTime.OffsetDateTime.ToString(System.String,System.IFormatProvider)
      commentId: M:NodaTime.OffsetDateTime.ToString(System.String,System.IFormatProvider)
      language: CSharp
      name:
        CSharp: ToString(String, IFormatProvider)
        VB: ToString(String, IFormatProvider)
      nameWithType:
        CSharp: OffsetDateTime.ToString(String, IFormatProvider)
        VB: OffsetDateTime.ToString(String, IFormatProvider)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.ToString(System.String, System.IFormatProvider)
        VB: NodaTime.OffsetDateTime.ToString(System.String, System.IFormatProvider)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 306
      summary: "\nFormats the value of the current instance using the specified format.\n"
      example: []
      syntax:
        content:
          CSharp: public string ToString(string patternText, IFormatProvider formatProvider)
          VB: Public Function ToString(patternText As String, formatProvider As IFormatProvider) As String
        parameters:
        - id: patternText
          type: System.String
          description: "The <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> specifying the pattern to use.\n  -or- \n  null to use the default pattern defined for the type of the <xref href=\"System.IFormattable\" data-throw-if-not-resolved=\"false\"></xref> implementation. \n"
        - id: formatProvider
          type: System.IFormatProvider
          description: "The <xref href=\"System.IFormatProvider\" data-throw-if-not-resolved=\"false\"></xref> to use to format the value.\n  -or- \n  null to obtain the numeric format information from the current locale setting of the operating system. \n"
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> containing the value of the current instance in the specified format.\n"
      overload: NodaTime.OffsetDateTime.ToString*
      implements:
      - System.IFormattable.ToString(System.String,System.IFormatProvider)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.String: 
        System.IFormattable: 
        System.IFormatProvider: 
    - id: NodaTime.OffsetDateTime.op_Equality(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)
      commentId: M:NodaTime.OffsetDateTime.op_Equality(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)
      language: CSharp
      name:
        CSharp: Equality(OffsetDateTime, OffsetDateTime)
        VB: Equality(OffsetDateTime, OffsetDateTime)
      nameWithType:
        CSharp: OffsetDateTime.Equality(OffsetDateTime, OffsetDateTime)
        VB: OffsetDateTime.Equality(OffsetDateTime, OffsetDateTime)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Equality(NodaTime.OffsetDateTime, NodaTime.OffsetDateTime)
        VB: NodaTime.OffsetDateTime.Equality(NodaTime.OffsetDateTime, NodaTime.OffsetDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Equality
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 319
      summary: "\nImplements the operator == (equality).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator ==(OffsetDateTime left, OffsetDateTime right)
          VB: Public Shared Operator =(left As OffsetDateTime, right As OffsetDateTime) As Boolean
        parameters:
        - id: left
          type: NodaTime.OffsetDateTime
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.OffsetDateTime
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if values are equal to each other, otherwise <code>false</code>.
      overload: NodaTime.OffsetDateTime.op_Equality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.OffsetDateTime.op_Inequality(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)
      commentId: M:NodaTime.OffsetDateTime.op_Inequality(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)
      language: CSharp
      name:
        CSharp: Inequality(OffsetDateTime, OffsetDateTime)
        VB: Inequality(OffsetDateTime, OffsetDateTime)
      nameWithType:
        CSharp: OffsetDateTime.Inequality(OffsetDateTime, OffsetDateTime)
        VB: OffsetDateTime.Inequality(OffsetDateTime, OffsetDateTime)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Inequality(NodaTime.OffsetDateTime, NodaTime.OffsetDateTime)
        VB: NodaTime.OffsetDateTime.Inequality(NodaTime.OffsetDateTime, NodaTime.OffsetDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Inequality
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 330
      summary: "\nImplements the operator != (inequality).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator !=(OffsetDateTime left, OffsetDateTime right)
          VB: Public Shared Operator <>(left As OffsetDateTime, right As OffsetDateTime) As Boolean
        parameters:
        - id: left
          type: NodaTime.OffsetDateTime
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.OffsetDateTime
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if values are not equal to each other, otherwise <code>false</code>.
      overload: NodaTime.OffsetDateTime.op_Inequality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isEii: true
      id: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema
      commentId: M:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema
      language: CSharp
      name:
        CSharp: IXmlSerializable.GetSchema()
        VB: System.Xml.Serialization.IXmlSerializable.GetSchema()
      nameWithType:
        CSharp: OffsetDateTime.IXmlSerializable.GetSchema()
        VB: OffsetDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
        VB: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.GetSchema
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 446
      example: []
      syntax:
        content:
          CSharp: XmlSchema IXmlSerializable.GetSchema()
          VB: Function System.Xml.Serialization.IXmlSerializable.GetSchema As XmlSchema Implements IXmlSerializable.GetSchema
        return:
          type: System.Xml.Schema.XmlSchema
      overload: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
      implements:
      - System.Xml.Serialization.IXmlSerializable.GetSchema
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      commentId: M:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      language: CSharp
      name:
        CSharp: IXmlSerializable.ReadXml(XmlReader)
        VB: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      nameWithType:
        CSharp: OffsetDateTime.IXmlSerializable.ReadXml(XmlReader)
        VB: OffsetDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        VB: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.ReadXml
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 452
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.ReadXml(XmlReader reader)
          VB: Sub System.Xml.Serialization.IXmlSerializable.ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
        parameters:
        - id: reader
          type: System.Xml.XmlReader
      overload: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      commentId: M:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      language: CSharp
      name:
        CSharp: IXmlSerializable.WriteXml(XmlWriter)
        VB: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      nameWithType:
        CSharp: OffsetDateTime.IXmlSerializable.WriteXml(XmlWriter)
        VB: OffsetDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        VB: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.WriteXml
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 469
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.WriteXml(XmlWriter writer)
          VB: Sub System.Xml.Serialization.IXmlSerializable.WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
        parameters:
        - id: writer
          type: System.Xml.XmlWriter
      overload: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.OffsetDateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:NodaTime.OffsetDateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: OffsetDateTime.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: OffsetDateTime.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: NodaTime.OffsetDateTime.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Runtime.Serialization.ISerializable.GetObjectData
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 503
      summary: "\nImplementation of <xref href=\"System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo%2cSystem.Runtime.Serialization.StreamingContext)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
          VB: Sub System.Runtime.Serialization.ISerializable.GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: The <xref href="System.Runtime.Serialization.SerializationInfo" data-throw-if-not-resolved="false"></xref> to populate with data.
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: The destination for this serialization.
      overload: NodaTime.OffsetDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*
      implements:
      - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      modifiers:
        CSharp: []
        VB: []
      references:
        ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        : 
        System.Runtime.Serialization.SerializationInfo: 
    references:
      System.DateTimeOffset: 
  - id: NodaTime.OffsetDateTime.Comparer
    commentId: T:NodaTime.OffsetDateTime.Comparer
    language: CSharp
    name:
      CSharp: OffsetDateTime.Comparer
      VB: OffsetDateTime.Comparer
    nameWithType:
      CSharp: OffsetDateTime.Comparer
      VB: OffsetDateTime.Comparer
    qualifiedName:
      CSharp: NodaTime.OffsetDateTime.Comparer
      VB: NodaTime.OffsetDateTime.Comparer
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/OffsetDateTime.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: Comparer
      path: src/NodaTime/OffsetDateTime.cs
      startLine: 346
    summary: "\nBase class for <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> comparers.\n"
    remarks: "\n<p>Use the static properties of this class to obtain instances.</p>\n<p>For the curious: this class only exists so that in the future, it can expose more functionality - probably\nimplementing <xref href=\"System.Collections.Generic.IEqualityComparer%601\" data-throw-if-not-resolved=\"false\"></xref>. If we simply provided properties on OffsetDateTime of type\n<xref href=\"System.Collections.Generic.IComparer%601\" data-throw-if-not-resolved=\"false\"></xref> we'd have no backward-compatible way of adding to the set of implemented interfaces.</p>\n"
    example: []
    syntax:
      content:
        CSharp: 'public abstract class Comparer : IComparer<OffsetDateTime>'
        VB: >-
          Public MustInherit Class Comparer

              Implements IComparer(Of OffsetDateTime)
    inheritance:
    - System.Object
    implements:
    - System.Collections.Generic.IComparer{NodaTime.OffsetDateTime}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - abstract
      - class
      VB:
      - Public
      - MustInherit
      - Class
    items:
    - id: NodaTime.OffsetDateTime.Comparer.Local
      commentId: P:NodaTime.OffsetDateTime.Comparer.Local
      language: CSharp
      name:
        CSharp: Local
        VB: Local
      nameWithType:
        CSharp: OffsetDateTime.Comparer.Local
        VB: OffsetDateTime.Comparer.Local
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Comparer.Local
        VB: NodaTime.OffsetDateTime.Comparer.Local
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Local
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 357
      summary: "\nReturns a comparer which compares <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> values by their local date/time, without reference to\neither the offset or the calendar system.\n"
      remarks: "\n<p>For example, this comparer considers 2013-03-04T20:21:00+0100 to be later than 2013-03-04T19:21:00-0700 even though\nthe second value represents a later instant in time.</p>\n<p>This property will return a reference to the same instance every time it is called.</p>\n"
      example: []
      syntax:
        content:
          CSharp: public static OffsetDateTime.Comparer Local { get; }
          VB: Public Shared ReadOnly Property Local As OffsetDateTime.Comparer
        parameters: []
        return:
          type: NodaTime.OffsetDateTime.Comparer
      overload: NodaTime.OffsetDateTime.Comparer.Local*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.OffsetDateTime: 
    - id: NodaTime.OffsetDateTime.Comparer.Instant
      commentId: P:NodaTime.OffsetDateTime.Comparer.Instant
      language: CSharp
      name:
        CSharp: Instant
        VB: Instant
      nameWithType:
        CSharp: OffsetDateTime.Comparer.Instant
        VB: OffsetDateTime.Comparer.Instant
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Comparer.Instant
        VB: NodaTime.OffsetDateTime.Comparer.Instant
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Instant
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 368
      summary: "\nReturns a comparer which compares <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> values by the instant values obtained by applying the offset to\nthe local date/time, ignoring the calendar system.\n"
      remarks: "\n<p>For example, this comparer considers 2013-03-04T20:21:00+0100 to be earlier than 2013-03-04T19:21:00-0700 even though\nthe second value has a local time which is earlier.</p>\n<p>This property will return a reference to the same instance every time it is called.</p>\n"
      example: []
      syntax:
        content:
          CSharp: public static OffsetDateTime.Comparer Instant { get; }
          VB: Public Shared ReadOnly Property Instant As OffsetDateTime.Comparer
        parameters: []
        return:
          type: NodaTime.OffsetDateTime.Comparer
      overload: NodaTime.OffsetDateTime.Comparer.Instant*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.OffsetDateTime: 
    - id: NodaTime.OffsetDateTime.Comparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)
      commentId: M:NodaTime.OffsetDateTime.Comparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)
      language: CSharp
      name:
        CSharp: Compare(OffsetDateTime, OffsetDateTime)
        VB: Compare(OffsetDateTime, OffsetDateTime)
      nameWithType:
        CSharp: OffsetDateTime.Comparer.Compare(OffsetDateTime, OffsetDateTime)
        VB: OffsetDateTime.Comparer.Compare(OffsetDateTime, OffsetDateTime)
      qualifiedName:
        CSharp: NodaTime.OffsetDateTime.Comparer.Compare(NodaTime.OffsetDateTime, NodaTime.OffsetDateTime)
        VB: NodaTime.OffsetDateTime.Comparer.Compare(NodaTime.OffsetDateTime, NodaTime.OffsetDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/OffsetDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Compare
        path: src/NodaTime/OffsetDateTime.cs
        startLine: 403
      summary: "\nCompares two <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> values and returns a value indicating whether one is less than, equal to, or greater than the other.\n"
      example: []
      syntax:
        content:
          CSharp: public abstract int Compare(OffsetDateTime x, OffsetDateTime y)
          VB: Public MustOverride Function Compare(x As OffsetDateTime, y As OffsetDateTime) As Integer
        parameters:
        - id: x
          type: NodaTime.OffsetDateTime
          description: The first value to compare.
        - id: y
          type: NodaTime.OffsetDateTime
          description: The second value to compare.
        return:
          type: System.Int32
          description: >
            A signed integer that indicates the relative values of <span class="paramref">x</span> and <span class="paramref">y</span>, as shown in the following table.

            <table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>Less than zero</td><td><span class="paramref">x</span> is less than <span class="paramref">y</span>.</td></tr><tr><td>Zero</td><td><span class="paramref">x</span> is equals to <span class="paramref">y</span>.</td></tr><tr><td>Greater than zero</td><td><span class="paramref">x</span> is greater than <span class="paramref">y</span>.</td></tr></tbody></table>
      overload: NodaTime.OffsetDateTime.Comparer.Compare*
      implements:
      - System.Collections.Generic.IComparer{NodaTime.OffsetDateTime}.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)
      modifiers:
        CSharp:
        - public
        - abstract
        VB:
        - Public
        - MustOverride
      references:
        NodaTime.OffsetDateTime: 
    references:
      NodaTime.OffsetDateTime: 
      System.Collections.Generic.IEqualityComparer`1: 
      System.Collections.Generic.IComparer`1: 
  - id: NodaTime.IDateTimeZoneProvider
    commentId: T:NodaTime.IDateTimeZoneProvider
    language: CSharp
    name:
      CSharp: IDateTimeZoneProvider
      VB: IDateTimeZoneProvider
    nameWithType:
      CSharp: IDateTimeZoneProvider
      VB: IDateTimeZoneProvider
    qualifiedName:
      CSharp: NodaTime.IDateTimeZoneProvider
      VB: NodaTime.IDateTimeZoneProvider
    type: Interface
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/IDateTimeZoneProvider.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: IDateTimeZoneProvider
      path: src/NodaTime/IDateTimeZoneProvider.cs
      startLine: 23
    summary: "\nProvides stable, performant time zone data.\n"
    remarks: "\n<p>Consumers should be able to treat an <xref href=\"NodaTime.IDateTimeZoneProvider\" data-throw-if-not-resolved=\"false\"></xref> like a cache: \nlookups should be quick (after at most one lookup of a given ID), and the data for a given ID should always be\nthe same (even if the specific instance returned is not).\nConsumers should not feel the need to cache data accessed through this interface.</p>\n<p>Implementations designed to work with any <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> implementation (such as\n<xref href=\"NodaTime.TimeZones.DateTimeZoneCache\" data-throw-if-not-resolved=\"false\"></xref>) should not attempt to handle exceptions thrown by the source. A source-specific\nprovider may do so, as it has more detailed knowledge of what can go wrong and how it can best be handled.</p>\n"
    example: []
    syntax:
      content:
        CSharp: public interface IDateTimeZoneProvider
        VB: Public Interface IDateTimeZoneProvider
    modifiers:
      CSharp:
      - public
      - interface
      VB:
      - Public
      - Interface
    items:
    - id: NodaTime.IDateTimeZoneProvider.VersionId
      commentId: P:NodaTime.IDateTimeZoneProvider.VersionId
      language: CSharp
      name:
        CSharp: VersionId
        VB: VersionId
      nameWithType:
        CSharp: IDateTimeZoneProvider.VersionId
        VB: IDateTimeZoneProvider.VersionId
      qualifiedName:
        CSharp: NodaTime.IDateTimeZoneProvider.VersionId
        VB: NodaTime.IDateTimeZoneProvider.VersionId
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IDateTimeZoneProvider.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: VersionId
        path: src/NodaTime/IDateTimeZoneProvider.cs
        startLine: 28
      summary: "\nThe version ID of this provider.\n"
      example: []
      syntax:
        content:
          CSharp: string VersionId { get; }
          VB: ReadOnly Property VersionId As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.IDateTimeZoneProvider.VersionId*
      modifiers:
        CSharp:
        - get
        VB:
        - ReadOnly
    - id: NodaTime.IDateTimeZoneProvider.Ids
      commentId: P:NodaTime.IDateTimeZoneProvider.Ids
      language: CSharp
      name:
        CSharp: Ids
        VB: Ids
      nameWithType:
        CSharp: IDateTimeZoneProvider.Ids
        VB: IDateTimeZoneProvider.Ids
      qualifiedName:
        CSharp: NodaTime.IDateTimeZoneProvider.Ids
        VB: NodaTime.IDateTimeZoneProvider.Ids
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IDateTimeZoneProvider.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Ids
        path: src/NodaTime/IDateTimeZoneProvider.cs
        startLine: 45
      summary: "\nGets the list of valid time zone ids advertised by this provider.\n"
      remarks: "\n<p>\nThis list will be sorted in ordinal lexicographic order. It cannot be modified by callers, and\nmust not be modified by the provider either: client code can safely treat it as thread-safe\nand deeply immutable.\n</p>\n<p>\nIn addition to the list returned here, providers always support the fixed-offset timezones with IDs \"UTC\"\nand \"UTC+/-Offset\". These may or may not be included explicitly in this list.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: ReadOnlyCollection<string> Ids { get; }
          VB: ReadOnly Property Ids As ReadOnlyCollection(Of String)
        parameters: []
        return:
          type: System.Collections.ObjectModel.ReadOnlyCollection{System.String}
          description: The <xref href="System.Collections.Generic.IEnumerable%601" data-throw-if-not-resolved="false"></xref> of string ids.
      overload: NodaTime.IDateTimeZoneProvider.Ids*
      modifiers:
        CSharp:
        - get
        VB:
        - ReadOnly
      references:
        System.Collections.Generic.IEnumerable`1: 
    - id: NodaTime.IDateTimeZoneProvider.GetSystemDefault
      commentId: M:NodaTime.IDateTimeZoneProvider.GetSystemDefault
      language: CSharp
      name:
        CSharp: GetSystemDefault()
        VB: GetSystemDefault()
      nameWithType:
        CSharp: IDateTimeZoneProvider.GetSystemDefault()
        VB: IDateTimeZoneProvider.GetSystemDefault()
      qualifiedName:
        CSharp: NodaTime.IDateTimeZoneProvider.GetSystemDefault()
        VB: NodaTime.IDateTimeZoneProvider.GetSystemDefault()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IDateTimeZoneProvider.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetSystemDefault
        path: src/NodaTime/IDateTimeZoneProvider.cs
        startLine: 93
      summary: "\nGets the time zone from this provider that matches the system default time zone, if a matching time zone is\navailable.\n"
      remarks: "\n<p>\nCallers should be aware that this method will throw <xref href=\"NodaTime.TimeZones.DateTimeZoneNotFoundException\" data-throw-if-not-resolved=\"false\"></xref> if no matching\ntime zone is found. For the built-in Noda Time providers, this is unlikely to occur in practice (assuming\nthe system is using a standard Windows time zone), but can occur even then, if no mapping is found. The TZDB\nsource contains mappings for almost all Windows system time zones, but a few (such as \"Mid-Atlantic Standard Time\")\nare unmappable.\n</p>\n<p>\nIf it is necessary to handle this case, callers can construct a\n<xref href=\"NodaTime.TimeZones.BclDateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> via <xref href=\"NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault\" data-throw-if-not-resolved=\"false\"></xref>, which returns a\n<xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> that wraps the system local <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref>, and which always\nsucceeds. Note that <code>BclDateTimeZone</code> is not available on the PCL build of Noda Time, so\nthis fallback strategy can only be used with the desktop version.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: DateTimeZone GetSystemDefault()
          VB: Function GetSystemDefault As DateTimeZone
        return:
          type: NodaTime.DateTimeZone
          description: "\nThe provider-specific representation of the system default time zone.\n"
      overload: NodaTime.IDateTimeZoneProvider.GetSystemDefault*
      exceptions:
      - type: NodaTime.TimeZones.DateTimeZoneNotFoundException
        commentId: T:NodaTime.TimeZones.DateTimeZoneNotFoundException
        description: >-
          The system default time zone is not mapped by

          this provider.
      modifiers:
        CSharp: []
        VB: []
      references:
        NodaTime.TimeZones.DateTimeZoneNotFoundException: 
        NodaTime.TimeZones.BclDateTimeZone: 
        NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault: 
        NodaTime.DateTimeZone: 
        System.TimeZoneInfo: 
    - id: NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)
      commentId: M:NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)
      language: CSharp
      name:
        CSharp: GetZoneOrNull(String)
        VB: GetZoneOrNull(String)
      nameWithType:
        CSharp: IDateTimeZoneProvider.GetZoneOrNull(String)
        VB: IDateTimeZoneProvider.GetZoneOrNull(String)
      qualifiedName:
        CSharp: NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)
        VB: NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IDateTimeZoneProvider.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetZoneOrNull
        path: src/NodaTime/IDateTimeZoneProvider.cs
        startLine: 118
      summary: "\nReturns the time zone for the given ID, if it's available.\n"
      remarks: "\n<p>\nNote that this may return a <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> that has a different ID to that requested, if the ID\nprovided is an alias.\n</p>\n<p>\nNote also that this method is not required to return the same <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> instance for\nsuccessive requests for the same ID; however, all instances returned for a given ID must compare\nas equal.\n</p>\n<p>\nThe fixed-offset timezones with IDs \"UTC\" and \"UTC+/-Offset\" are always available. These must\nreturn instances that are equal to those returned by <xref href=\"NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)\" data-throw-if-not-resolved=\"false\"></xref>.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: DateTimeZone GetZoneOrNull(string id)
          VB: Function GetZoneOrNull(id As String) As DateTimeZone
        parameters:
        - id: id
          type: System.String
          description: The time zone ID to find.
        return:
          type: NodaTime.DateTimeZone
          description: >-
            The <xref href="NodaTime.DateTimeZone" data-throw-if-not-resolved="false"></xref> for the given ID or null if the provider does not support

            the given ID.
      overload: NodaTime.IDateTimeZoneProvider.GetZoneOrNull*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">id</span> is null.
      modifiers:
        CSharp: []
        VB: []
      references:
        NodaTime.DateTimeZone: 
        NodaTime.DateTimeZone.ForOffset(NodaTime.Offset): 
    - id: NodaTime.IDateTimeZoneProvider.Item(System.String)
      commentId: P:NodaTime.IDateTimeZoneProvider.Item(System.String)
      language: CSharp
      name:
        CSharp: Item[String]
        VB: Item(String)
      nameWithType:
        CSharp: IDateTimeZoneProvider.Item[String]
        VB: IDateTimeZoneProvider.Item(String)
      qualifiedName:
        CSharp: NodaTime.IDateTimeZoneProvider.Item[System.String]
        VB: NodaTime.IDateTimeZoneProvider.Item(System.String)
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IDateTimeZoneProvider.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: this[]
        path: src/NodaTime/IDateTimeZoneProvider.cs
        startLine: 146
      summary: "\nReturns the time zone for the given ID.\n"
      remarks: "\n<p>\nUnlike <xref href=\"NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)\" data-throw-if-not-resolved=\"false\"></xref>, this indexer will never return a null reference. If the ID is not\nsupported by this provider, it will throw <xref href=\"NodaTime.TimeZones.DateTimeZoneNotFoundException\" data-throw-if-not-resolved=\"false\"></xref>.\n</p>\n<p>\nNote that this may return a <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> that has a different ID to that requested, if the ID\nprovided is an alias.\n</p>\n<p>\nNote also that this method is not required to return the same <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> instance for\nsuccessive requests for the same ID; however, all instances returned for a given ID must compare\nas equal.\n</p>\n<p>\nThe fixed-offset timezones with IDs \"UTC\" and \"UTC+/-Offset\" are always available. These must\nreturn instances that are equal to those returned by <xref href=\"NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)\" data-throw-if-not-resolved=\"false\"></xref>.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: DateTimeZone this[string id] { get; }
          VB: ReadOnly Property Item(id As String) As DateTimeZone
        parameters:
        - id: id
          type: System.String
          description: The time zone id to find.
        return:
          type: NodaTime.DateTimeZone
          description: The <xref href="NodaTime.DateTimeZone" data-throw-if-not-resolved="false"></xref> for the given ID.
      overload: NodaTime.IDateTimeZoneProvider.Item*
      exceptions:
      - type: NodaTime.TimeZones.DateTimeZoneNotFoundException
        commentId: T:NodaTime.TimeZones.DateTimeZoneNotFoundException
        description: This provider does not support the given ID.
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">id</span> is null.
      modifiers:
        CSharp:
        - get
        VB:
        - ReadOnly
      references:
        NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String): 
        NodaTime.TimeZones.DateTimeZoneNotFoundException: 
        NodaTime.DateTimeZone: 
        NodaTime.DateTimeZone.ForOffset(NodaTime.Offset): 
    references:
      NodaTime.IDateTimeZoneProvider: 
      NodaTime.TimeZones.IDateTimeZoneSource: 
      NodaTime.TimeZones.DateTimeZoneCache: 
  - id: NodaTime.PeriodBuilder
    commentId: T:NodaTime.PeriodBuilder
    language: CSharp
    name:
      CSharp: PeriodBuilder
      VB: PeriodBuilder
    nameWithType:
      CSharp: PeriodBuilder
      VB: PeriodBuilder
    qualifiedName:
      CSharp: NodaTime.PeriodBuilder
      VB: NodaTime.PeriodBuilder
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/PeriodBuilder.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: PeriodBuilder
      path: src/NodaTime/PeriodBuilder.cs
      startLine: 22
    summary: "\nA mutable builder class for <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref> values. Each property can\nbe set independently, and then a Period can be created from the result\nusing the <xref href=\"NodaTime.PeriodBuilder.Build\" data-throw-if-not-resolved=\"false\"></xref> method.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class PeriodBuilder : IXmlSerializable'
        VB: >-
          Public NotInheritable Class PeriodBuilder

              Implements IXmlSerializable
    inheritance:
    - System.Object
    implements:
    - System.Xml.Serialization.IXmlSerializable
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.PeriodBuilder.Years
      commentId: P:NodaTime.PeriodBuilder.Years
      language: CSharp
      name:
        CSharp: Years
        VB: Years
      nameWithType:
        CSharp: PeriodBuilder.Years
        VB: PeriodBuilder.Years
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Years
        VB: NodaTime.PeriodBuilder.Years
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Years
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 28
      summary: "\nGets or sets the number of years within the period.\n"
      example: []
      syntax:
        content:
          CSharp: public long Years { get; set; }
          VB: Public Property Years As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.PeriodBuilder.Years*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: NodaTime.PeriodBuilder.Months
      commentId: P:NodaTime.PeriodBuilder.Months
      language: CSharp
      name:
        CSharp: Months
        VB: Months
      nameWithType:
        CSharp: PeriodBuilder.Months
        VB: PeriodBuilder.Months
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Months
        VB: NodaTime.PeriodBuilder.Months
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Months
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 33
      summary: "\nGets or sets the number of months within the period.\n"
      example: []
      syntax:
        content:
          CSharp: public long Months { get; set; }
          VB: Public Property Months As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.PeriodBuilder.Months*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: NodaTime.PeriodBuilder.Weeks
      commentId: P:NodaTime.PeriodBuilder.Weeks
      language: CSharp
      name:
        CSharp: Weeks
        VB: Weeks
      nameWithType:
        CSharp: PeriodBuilder.Weeks
        VB: PeriodBuilder.Weeks
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Weeks
        VB: NodaTime.PeriodBuilder.Weeks
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Weeks
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 38
      summary: "\nGets or sets the number of weeks within the period.\n"
      example: []
      syntax:
        content:
          CSharp: public long Weeks { get; set; }
          VB: Public Property Weeks As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.PeriodBuilder.Weeks*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: NodaTime.PeriodBuilder.Days
      commentId: P:NodaTime.PeriodBuilder.Days
      language: CSharp
      name:
        CSharp: Days
        VB: Days
      nameWithType:
        CSharp: PeriodBuilder.Days
        VB: PeriodBuilder.Days
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Days
        VB: NodaTime.PeriodBuilder.Days
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Days
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 43
      summary: "\nGets or sets the number of days within the period.\n"
      example: []
      syntax:
        content:
          CSharp: public long Days { get; set; }
          VB: Public Property Days As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.PeriodBuilder.Days*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: NodaTime.PeriodBuilder.Hours
      commentId: P:NodaTime.PeriodBuilder.Hours
      language: CSharp
      name:
        CSharp: Hours
        VB: Hours
      nameWithType:
        CSharp: PeriodBuilder.Hours
        VB: PeriodBuilder.Hours
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Hours
        VB: NodaTime.PeriodBuilder.Hours
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Hours
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 48
      summary: "\nGets or sets the number of hours within the period.\n"
      example: []
      syntax:
        content:
          CSharp: public long Hours { get; set; }
          VB: Public Property Hours As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.PeriodBuilder.Hours*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: NodaTime.PeriodBuilder.Minutes
      commentId: P:NodaTime.PeriodBuilder.Minutes
      language: CSharp
      name:
        CSharp: Minutes
        VB: Minutes
      nameWithType:
        CSharp: PeriodBuilder.Minutes
        VB: PeriodBuilder.Minutes
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Minutes
        VB: NodaTime.PeriodBuilder.Minutes
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minutes
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 53
      summary: "\nGets or sets the number of minutes within the period.\n"
      example: []
      syntax:
        content:
          CSharp: public long Minutes { get; set; }
          VB: Public Property Minutes As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.PeriodBuilder.Minutes*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: NodaTime.PeriodBuilder.Seconds
      commentId: P:NodaTime.PeriodBuilder.Seconds
      language: CSharp
      name:
        CSharp: Seconds
        VB: Seconds
      nameWithType:
        CSharp: PeriodBuilder.Seconds
        VB: PeriodBuilder.Seconds
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Seconds
        VB: NodaTime.PeriodBuilder.Seconds
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Seconds
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 58
      summary: "\nGets or sets the number of seconds within the period.\n"
      example: []
      syntax:
        content:
          CSharp: public long Seconds { get; set; }
          VB: Public Property Seconds As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.PeriodBuilder.Seconds*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: NodaTime.PeriodBuilder.Milliseconds
      commentId: P:NodaTime.PeriodBuilder.Milliseconds
      language: CSharp
      name:
        CSharp: Milliseconds
        VB: Milliseconds
      nameWithType:
        CSharp: PeriodBuilder.Milliseconds
        VB: PeriodBuilder.Milliseconds
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Milliseconds
        VB: NodaTime.PeriodBuilder.Milliseconds
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Milliseconds
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 63
      summary: "\nGets or sets the number of milliseconds within the period.\n"
      example: []
      syntax:
        content:
          CSharp: public long Milliseconds { get; set; }
          VB: Public Property Milliseconds As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.PeriodBuilder.Milliseconds*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: NodaTime.PeriodBuilder.Ticks
      commentId: P:NodaTime.PeriodBuilder.Ticks
      language: CSharp
      name:
        CSharp: Ticks
        VB: Ticks
      nameWithType:
        CSharp: PeriodBuilder.Ticks
        VB: PeriodBuilder.Ticks
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Ticks
        VB: NodaTime.PeriodBuilder.Ticks
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Ticks
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 68
      summary: "\nGets or sets the number of ticks within the period.\n"
      example: []
      syntax:
        content:
          CSharp: public long Ticks { get; set; }
          VB: Public Property Ticks As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.PeriodBuilder.Ticks*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: NodaTime.PeriodBuilder.#ctor
      commentId: M:NodaTime.PeriodBuilder.#ctor
      language: CSharp
      name:
        CSharp: PeriodBuilder()
        VB: PeriodBuilder()
      nameWithType:
        CSharp: PeriodBuilder.PeriodBuilder()
        VB: PeriodBuilder.PeriodBuilder()
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.PeriodBuilder()
        VB: NodaTime.PeriodBuilder.PeriodBuilder()
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 74
      summary: "\nCreates a new period builder with an initially zero period.\n"
      example: []
      syntax:
        content:
          CSharp: public PeriodBuilder()
          VB: Public Sub New
      overload: NodaTime.PeriodBuilder.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.PeriodBuilder.#ctor(NodaTime.Period)
      commentId: M:NodaTime.PeriodBuilder.#ctor(NodaTime.Period)
      language: CSharp
      name:
        CSharp: PeriodBuilder(Period)
        VB: PeriodBuilder(Period)
      nameWithType:
        CSharp: PeriodBuilder.PeriodBuilder(Period)
        VB: PeriodBuilder.PeriodBuilder(Period)
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.PeriodBuilder(NodaTime.Period)
        VB: NodaTime.PeriodBuilder.PeriodBuilder(NodaTime.Period)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 85
      summary: "\nCreates a new period builder with the values from an existing\nperiod. Calling this constructor instead of <xref href=\"NodaTime.Period.ToBuilder\" data-throw-if-not-resolved=\"false\"></xref>\nallows object initializers to be used.\n"
      example: []
      syntax:
        content:
          CSharp: public PeriodBuilder(Period period)
          VB: Public Sub New(period As Period)
        parameters:
        - id: period
          type: NodaTime.Period
          description: An existing period to copy values from.
      overload: NodaTime.PeriodBuilder.#ctor*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">period</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Period.ToBuilder: 
    - id: NodaTime.PeriodBuilder.Item(NodaTime.PeriodUnits)
      commentId: P:NodaTime.PeriodBuilder.Item(NodaTime.PeriodUnits)
      language: CSharp
      name:
        CSharp: Item[PeriodUnits]
        VB: Item(PeriodUnits)
      nameWithType:
        CSharp: PeriodBuilder.Item[PeriodUnits]
        VB: PeriodBuilder.Item(PeriodUnits)
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Item[NodaTime.PeriodUnits]
        VB: NodaTime.PeriodBuilder.Item(NodaTime.PeriodUnits)
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: this[]
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 105
      summary: "\nGets or sets the value of a single unit.\n"
      example: []
      syntax:
        content:
          CSharp: public long this[PeriodUnits unit] { get; set; }
          VB: Public Property Item(unit As PeriodUnits) As Long
        parameters:
        - id: unit
          type: NodaTime.PeriodUnits
          description: A single value within the <xref href="NodaTime.PeriodUnits" data-throw-if-not-resolved="false"></xref> enumeration.
        return:
          type: System.Int64
          description: The value of the given unit within this period builder, or zero if the unit is unset.
      overload: NodaTime.PeriodBuilder.Item*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: <span class="paramref">unit</span> is not a single unit.
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
      references:
        NodaTime.PeriodUnits: 
    - id: NodaTime.PeriodBuilder.Build
      commentId: M:NodaTime.PeriodBuilder.Build
      language: CSharp
      name:
        CSharp: Build()
        VB: Build()
      nameWithType:
        CSharp: PeriodBuilder.Build()
        VB: PeriodBuilder.Build()
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.Build()
        VB: NodaTime.PeriodBuilder.Build()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Build
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 145
      summary: "\nBuilds a period from the properties in this builder.\n"
      example: []
      syntax:
        content:
          CSharp: public Period Build()
          VB: Public Function Build As Period
        return:
          type: NodaTime.Period
          description: A period containing the values from this builder.
      overload: NodaTime.PeriodBuilder.Build*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - isEii: true
      id: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#GetSchema
      commentId: M:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#GetSchema
      language: CSharp
      name:
        CSharp: IXmlSerializable.GetSchema()
        VB: System.Xml.Serialization.IXmlSerializable.GetSchema()
      nameWithType:
        CSharp: PeriodBuilder.IXmlSerializable.GetSchema()
        VB: PeriodBuilder.System.Xml.Serialization.IXmlSerializable.GetSchema()
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.GetSchema()
        VB: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.GetSchema()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.GetSchema
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 151
      example: []
      syntax:
        content:
          CSharp: XmlSchema IXmlSerializable.GetSchema()
          VB: Function System.Xml.Serialization.IXmlSerializable.GetSchema As XmlSchema Implements IXmlSerializable.GetSchema
        return:
          type: System.Xml.Schema.XmlSchema
      overload: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#GetSchema*
      implements:
      - System.Xml.Serialization.IXmlSerializable.GetSchema
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      commentId: M:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      language: CSharp
      name:
        CSharp: IXmlSerializable.ReadXml(XmlReader)
        VB: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      nameWithType:
        CSharp: PeriodBuilder.IXmlSerializable.ReadXml(XmlReader)
        VB: PeriodBuilder.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        VB: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.ReadXml
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 157
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.ReadXml(XmlReader reader)
          VB: Sub System.Xml.Serialization.IXmlSerializable.ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
        parameters:
        - id: reader
          type: System.Xml.XmlReader
      overload: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#ReadXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      commentId: M:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      language: CSharp
      name:
        CSharp: IXmlSerializable.WriteXml(XmlWriter)
        VB: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      nameWithType:
        CSharp: PeriodBuilder.IXmlSerializable.WriteXml(XmlWriter)
        VB: PeriodBuilder.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      qualifiedName:
        CSharp: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        VB: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodBuilder.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.WriteXml
        path: src/NodaTime/PeriodBuilder.cs
        startLine: 173
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.WriteXml(XmlWriter writer)
          VB: Sub System.Xml.Serialization.IXmlSerializable.WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
        parameters:
        - id: writer
          type: System.Xml.XmlWriter
      overload: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#WriteXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      modifiers:
        CSharp: []
        VB: []
    references:
      NodaTime.Period: 
      NodaTime.PeriodBuilder.Build: 
  - id: NodaTime.PeriodUnits
    commentId: T:NodaTime.PeriodUnits
    language: CSharp
    name:
      CSharp: PeriodUnits
      VB: PeriodUnits
    nameWithType:
      CSharp: PeriodUnits
      VB: PeriodUnits
    qualifiedName:
      CSharp: NodaTime.PeriodUnits
      VB: NodaTime.PeriodUnits
    type: Enum
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/PeriodUnits.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: PeriodUnits
      path: src/NodaTime/PeriodUnits.cs
      startLine: 15
    summary: "\nThe units within a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref>. When a period is created to find the difference between two local values,\nthe caller may specify which units are required - for example, you can ask for the difference between two dates\nin \"years and weeks\". Units are always applied largest-first in arithmetic.\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Flags]

          public enum PeriodUnits
        VB: >-
          <Flags>

          Public Enum PeriodUnits
    attributes:
    - type: System.FlagsAttribute
      ctor: System.FlagsAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: NodaTime.PeriodUnits.None
      commentId: F:NodaTime.PeriodUnits.None
      language: CSharp
      name:
        CSharp: None
        VB: None
      nameWithType:
        CSharp: PeriodUnits.None
        VB: PeriodUnits.None
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.None
        VB: NodaTime.PeriodUnits.None
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: None
        path: src/NodaTime/PeriodUnits.cs
        startLine: 21
      summary: "\nValue indicating no units - an empty period.\n"
      example: []
      syntax:
        content:
          CSharp: None = 0
          VB: None = 0
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.PeriodUnits.Years
      commentId: F:NodaTime.PeriodUnits.Years
      language: CSharp
      name:
        CSharp: Years
        VB: Years
      nameWithType:
        CSharp: PeriodUnits.Years
        VB: PeriodUnits.Years
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.Years
        VB: NodaTime.PeriodUnits.Years
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Years
        path: src/NodaTime/PeriodUnits.cs
        startLine: 26
      summary: "\nYears element within a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref>\n"
      example: []
      syntax:
        content:
          CSharp: Years = 1
          VB: Years = 1
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Period: 
    - id: NodaTime.PeriodUnits.Months
      commentId: F:NodaTime.PeriodUnits.Months
      language: CSharp
      name:
        CSharp: Months
        VB: Months
      nameWithType:
        CSharp: PeriodUnits.Months
        VB: PeriodUnits.Months
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.Months
        VB: NodaTime.PeriodUnits.Months
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Months
        path: src/NodaTime/PeriodUnits.cs
        startLine: 31
      summary: "\nMonths element within a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref>\n"
      example: []
      syntax:
        content:
          CSharp: Months = 2
          VB: Months = 2
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Period: 
    - id: NodaTime.PeriodUnits.Weeks
      commentId: F:NodaTime.PeriodUnits.Weeks
      language: CSharp
      name:
        CSharp: Weeks
        VB: Weeks
      nameWithType:
        CSharp: PeriodUnits.Weeks
        VB: PeriodUnits.Weeks
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.Weeks
        VB: NodaTime.PeriodUnits.Weeks
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Weeks
        path: src/NodaTime/PeriodUnits.cs
        startLine: 36
      summary: "\nWeeks element within a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref>\n"
      example: []
      syntax:
        content:
          CSharp: Weeks = 4
          VB: Weeks = 4
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Period: 
    - id: NodaTime.PeriodUnits.Days
      commentId: F:NodaTime.PeriodUnits.Days
      language: CSharp
      name:
        CSharp: Days
        VB: Days
      nameWithType:
        CSharp: PeriodUnits.Days
        VB: PeriodUnits.Days
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.Days
        VB: NodaTime.PeriodUnits.Days
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Days
        path: src/NodaTime/PeriodUnits.cs
        startLine: 41
      summary: "\nDays element within a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref>\n"
      example: []
      syntax:
        content:
          CSharp: Days = 8
          VB: Days = 8
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Period: 
    - id: NodaTime.PeriodUnits.AllDateUnits
      commentId: F:NodaTime.PeriodUnits.AllDateUnits
      language: CSharp
      name:
        CSharp: AllDateUnits
        VB: AllDateUnits
      nameWithType:
        CSharp: PeriodUnits.AllDateUnits
        VB: PeriodUnits.AllDateUnits
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.AllDateUnits
        VB: NodaTime.PeriodUnits.AllDateUnits
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: AllDateUnits
        path: src/NodaTime/PeriodUnits.cs
        startLine: 46
      summary: "\nCompound value representing the combination of <xref href=\"NodaTime.PeriodUnits.Years\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"NodaTime.PeriodUnits.Months\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"NodaTime.PeriodUnits.Weeks\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.PeriodUnits.Days\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: AllDateUnits = 15
          VB: AllDateUnits = 15
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.PeriodUnits.Years: 
        NodaTime.PeriodUnits.Months: 
        NodaTime.PeriodUnits.Weeks: 
        NodaTime.PeriodUnits.Days: 
    - id: NodaTime.PeriodUnits.YearMonthDay
      commentId: F:NodaTime.PeriodUnits.YearMonthDay
      language: CSharp
      name:
        CSharp: YearMonthDay
        VB: YearMonthDay
      nameWithType:
        CSharp: PeriodUnits.YearMonthDay
        VB: PeriodUnits.YearMonthDay
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.YearMonthDay
        VB: NodaTime.PeriodUnits.YearMonthDay
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: YearMonthDay
        path: src/NodaTime/PeriodUnits.cs
        startLine: 51
      summary: "\nCompound value representing the combination of <xref href=\"NodaTime.PeriodUnits.Years\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"NodaTime.PeriodUnits.Months\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.PeriodUnits.Days\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: YearMonthDay = 11
          VB: YearMonthDay = 11
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.PeriodUnits.Years: 
        NodaTime.PeriodUnits.Months: 
        NodaTime.PeriodUnits.Days: 
    - id: NodaTime.PeriodUnits.Hours
      commentId: F:NodaTime.PeriodUnits.Hours
      language: CSharp
      name:
        CSharp: Hours
        VB: Hours
      nameWithType:
        CSharp: PeriodUnits.Hours
        VB: PeriodUnits.Hours
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.Hours
        VB: NodaTime.PeriodUnits.Hours
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Hours
        path: src/NodaTime/PeriodUnits.cs
        startLine: 56
      summary: "\nHours element within a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref>\n"
      example: []
      syntax:
        content:
          CSharp: Hours = 16
          VB: Hours = 16
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Period: 
    - id: NodaTime.PeriodUnits.Minutes
      commentId: F:NodaTime.PeriodUnits.Minutes
      language: CSharp
      name:
        CSharp: Minutes
        VB: Minutes
      nameWithType:
        CSharp: PeriodUnits.Minutes
        VB: PeriodUnits.Minutes
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.Minutes
        VB: NodaTime.PeriodUnits.Minutes
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minutes
        path: src/NodaTime/PeriodUnits.cs
        startLine: 61
      summary: "\nMinutes element within a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref>\n"
      example: []
      syntax:
        content:
          CSharp: Minutes = 32
          VB: Minutes = 32
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Period: 
    - id: NodaTime.PeriodUnits.Seconds
      commentId: F:NodaTime.PeriodUnits.Seconds
      language: CSharp
      name:
        CSharp: Seconds
        VB: Seconds
      nameWithType:
        CSharp: PeriodUnits.Seconds
        VB: PeriodUnits.Seconds
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.Seconds
        VB: NodaTime.PeriodUnits.Seconds
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Seconds
        path: src/NodaTime/PeriodUnits.cs
        startLine: 66
      summary: "\nSeconds element within a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref>\n"
      example: []
      syntax:
        content:
          CSharp: Seconds = 64
          VB: Seconds = 64
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Period: 
    - id: NodaTime.PeriodUnits.Milliseconds
      commentId: F:NodaTime.PeriodUnits.Milliseconds
      language: CSharp
      name:
        CSharp: Milliseconds
        VB: Milliseconds
      nameWithType:
        CSharp: PeriodUnits.Milliseconds
        VB: PeriodUnits.Milliseconds
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.Milliseconds
        VB: NodaTime.PeriodUnits.Milliseconds
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Milliseconds
        path: src/NodaTime/PeriodUnits.cs
        startLine: 71
      summary: "\nMilliseconds element within a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref>\n"
      example: []
      syntax:
        content:
          CSharp: Milliseconds = 128
          VB: Milliseconds = 128
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Period: 
    - id: NodaTime.PeriodUnits.Ticks
      commentId: F:NodaTime.PeriodUnits.Ticks
      language: CSharp
      name:
        CSharp: Ticks
        VB: Ticks
      nameWithType:
        CSharp: PeriodUnits.Ticks
        VB: PeriodUnits.Ticks
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.Ticks
        VB: NodaTime.PeriodUnits.Ticks
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Ticks
        path: src/NodaTime/PeriodUnits.cs
        startLine: 76
      summary: "\nTick element within a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref>\n"
      example: []
      syntax:
        content:
          CSharp: Ticks = 256
          VB: Ticks = 256
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Period: 
    - id: NodaTime.PeriodUnits.HourMinuteSecond
      commentId: F:NodaTime.PeriodUnits.HourMinuteSecond
      language: CSharp
      name:
        CSharp: HourMinuteSecond
        VB: HourMinuteSecond
      nameWithType:
        CSharp: PeriodUnits.HourMinuteSecond
        VB: PeriodUnits.HourMinuteSecond
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.HourMinuteSecond
        VB: NodaTime.PeriodUnits.HourMinuteSecond
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: HourMinuteSecond
        path: src/NodaTime/PeriodUnits.cs
        startLine: 81
      summary: "\nCompound value representing the combination of <xref href=\"NodaTime.PeriodUnits.Hours\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"NodaTime.PeriodUnits.Minutes\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.PeriodUnits.Seconds\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: HourMinuteSecond = 112
          VB: HourMinuteSecond = 112
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.PeriodUnits.Hours: 
        NodaTime.PeriodUnits.Minutes: 
        NodaTime.PeriodUnits.Seconds: 
    - id: NodaTime.PeriodUnits.AllTimeUnits
      commentId: F:NodaTime.PeriodUnits.AllTimeUnits
      language: CSharp
      name:
        CSharp: AllTimeUnits
        VB: AllTimeUnits
      nameWithType:
        CSharp: PeriodUnits.AllTimeUnits
        VB: PeriodUnits.AllTimeUnits
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.AllTimeUnits
        VB: NodaTime.PeriodUnits.AllTimeUnits
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: AllTimeUnits
        path: src/NodaTime/PeriodUnits.cs
        startLine: 86
      summary: "\nCompound value representing the combination of all time elements.\n"
      example: []
      syntax:
        content:
          CSharp: AllTimeUnits = 496
          VB: AllTimeUnits = 496
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.PeriodUnits.DateAndTime
      commentId: F:NodaTime.PeriodUnits.DateAndTime
      language: CSharp
      name:
        CSharp: DateAndTime
        VB: DateAndTime
      nameWithType:
        CSharp: PeriodUnits.DateAndTime
        VB: PeriodUnits.DateAndTime
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.DateAndTime
        VB: NodaTime.PeriodUnits.DateAndTime
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DateAndTime
        path: src/NodaTime/PeriodUnits.cs
        startLine: 91
      summary: "\nCompound value representing the combination of all possible elements except weeks.\n"
      example: []
      syntax:
        content:
          CSharp: DateAndTime = 507
          VB: DateAndTime = 507
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.PeriodUnits.AllUnits
      commentId: F:NodaTime.PeriodUnits.AllUnits
      language: CSharp
      name:
        CSharp: AllUnits
        VB: AllUnits
      nameWithType:
        CSharp: PeriodUnits.AllUnits
        VB: PeriodUnits.AllUnits
      qualifiedName:
        CSharp: NodaTime.PeriodUnits.AllUnits
        VB: NodaTime.PeriodUnits.AllUnits
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/PeriodUnits.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: AllUnits
        path: src/NodaTime/PeriodUnits.cs
        startLine: 96
      summary: "\nCompound value representing the combination of all possible elements.\n"
      example: []
      syntax:
        content:
          CSharp: AllUnits = 511
          VB: AllUnits = 511
        return:
          type: NodaTime.PeriodUnits
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    references:
      NodaTime.Period: 
  - id: NodaTime.IClock
    commentId: T:NodaTime.IClock
    language: CSharp
    name:
      CSharp: IClock
      VB: IClock
    nameWithType:
      CSharp: IClock
      VB: IClock
    qualifiedName:
      CSharp: NodaTime.IClock
      VB: NodaTime.IClock
    type: Interface
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/IClock.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: IClock
      path: src/NodaTime/IClock.cs
      startLine: 24
    summary: "\nRepresents a clock which can return the current time as an <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    remarks: "\n<xref href=\"NodaTime.IClock\" data-throw-if-not-resolved=\"false\"></xref> is intended for use anywhere you need to have access to the current time.\nAlthough it's not strictly incorrect to call <code>SystemClock.Instance.Now</code> directly,\nin the same way as you might call <xref href=\"System.DateTime.UtcNow\" data-throw-if-not-resolved=\"false\"></xref>, it's strongly discouraged\nas a matter of style for production code. We recommend providing an instance of <xref href=\"NodaTime.IClock\" data-throw-if-not-resolved=\"false\"></xref>\nto anything that needs it, which allows you to write tests using the fake clock in the NodaTime.Testing\nassembly (or your own implementation).\n"
    example: []
    syntax:
      content:
        CSharp: public interface IClock
        VB: Public Interface IClock
    seealso:
    - linkId: NodaTime.SystemClock
      commentId: T:NodaTime.SystemClock
    - linkId: NodaTime.Testing.FakeClock
      commentId: T:NodaTime.Testing.FakeClock
    modifiers:
      CSharp:
      - public
      - interface
      VB:
      - Public
      - Interface
    items:
    - id: NodaTime.IClock.Now
      commentId: P:NodaTime.IClock.Now
      language: CSharp
      name:
        CSharp: Now
        VB: Now
      nameWithType:
        CSharp: IClock.Now
        VB: IClock.Now
      qualifiedName:
        CSharp: NodaTime.IClock.Now
        VB: NodaTime.IClock.Now
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IClock.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Now
        path: src/NodaTime/IClock.cs
        startLine: 29
      summary: "\nGets the current <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> on the time line according to this clock.\n"
      example: []
      syntax:
        content:
          CSharp: Instant Now { get; }
          VB: ReadOnly Property Now As Instant
        parameters: []
        return:
          type: NodaTime.Instant
      overload: NodaTime.IClock.Now*
      modifiers:
        CSharp:
        - get
        VB:
        - ReadOnly
      references:
        NodaTime.Instant: 
    references:
      NodaTime.Instant: 
      NodaTime.IClock: 
      System.DateTime.UtcNow: 
      NodaTime.SystemClock: 
      NodaTime.Testing.FakeClock: 
  - id: NodaTime.IsoDayOfWeek
    commentId: T:NodaTime.IsoDayOfWeek
    language: CSharp
    name:
      CSharp: IsoDayOfWeek
      VB: IsoDayOfWeek
    nameWithType:
      CSharp: IsoDayOfWeek
      VB: IsoDayOfWeek
    qualifiedName:
      CSharp: NodaTime.IsoDayOfWeek
      VB: NodaTime.IsoDayOfWeek
    type: Enum
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/IsoDayOfWeek.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: IsoDayOfWeek
      path: src/NodaTime/IsoDayOfWeek.cs
      startLine: 11
    summary: "\nEquates the days of the week with their numerical value according to\nISO-8601. This corresponds with System.DayOfWeek except for Sunday, which\nis 7 in the ISO numbering and 0 in System.DayOfWeek.\n"
    example: []
    syntax:
      content:
        CSharp: public enum IsoDayOfWeek
        VB: Public Enum IsoDayOfWeek
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: NodaTime.IsoDayOfWeek.None
      commentId: F:NodaTime.IsoDayOfWeek.None
      language: CSharp
      name:
        CSharp: None
        VB: None
      nameWithType:
        CSharp: IsoDayOfWeek.None
        VB: IsoDayOfWeek.None
      qualifiedName:
        CSharp: NodaTime.IsoDayOfWeek.None
        VB: NodaTime.IsoDayOfWeek.None
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IsoDayOfWeek.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: None
        path: src/NodaTime/IsoDayOfWeek.cs
        startLine: 18
      summary: "\nValue indicating no day of the week; this will never be returned\nby any IsoDayOfWeek property, and is not valid as an argument to\nany method.\n"
      example: []
      syntax:
        content:
          CSharp: None = 0
          VB: None = 0
        return:
          type: NodaTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.IsoDayOfWeek.Monday
      commentId: F:NodaTime.IsoDayOfWeek.Monday
      language: CSharp
      name:
        CSharp: Monday
        VB: Monday
      nameWithType:
        CSharp: IsoDayOfWeek.Monday
        VB: IsoDayOfWeek.Monday
      qualifiedName:
        CSharp: NodaTime.IsoDayOfWeek.Monday
        VB: NodaTime.IsoDayOfWeek.Monday
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IsoDayOfWeek.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Monday
        path: src/NodaTime/IsoDayOfWeek.cs
        startLine: 22
      summary: "\nValue representing Monday (1).\n"
      example: []
      syntax:
        content:
          CSharp: Monday = 1
          VB: Monday = 1
        return:
          type: NodaTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.IsoDayOfWeek.Tuesday
      commentId: F:NodaTime.IsoDayOfWeek.Tuesday
      language: CSharp
      name:
        CSharp: Tuesday
        VB: Tuesday
      nameWithType:
        CSharp: IsoDayOfWeek.Tuesday
        VB: IsoDayOfWeek.Tuesday
      qualifiedName:
        CSharp: NodaTime.IsoDayOfWeek.Tuesday
        VB: NodaTime.IsoDayOfWeek.Tuesday
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IsoDayOfWeek.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Tuesday
        path: src/NodaTime/IsoDayOfWeek.cs
        startLine: 26
      summary: "\nValue representing Tuesday (2).\n"
      example: []
      syntax:
        content:
          CSharp: Tuesday = 2
          VB: Tuesday = 2
        return:
          type: NodaTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.IsoDayOfWeek.Wednesday
      commentId: F:NodaTime.IsoDayOfWeek.Wednesday
      language: CSharp
      name:
        CSharp: Wednesday
        VB: Wednesday
      nameWithType:
        CSharp: IsoDayOfWeek.Wednesday
        VB: IsoDayOfWeek.Wednesday
      qualifiedName:
        CSharp: NodaTime.IsoDayOfWeek.Wednesday
        VB: NodaTime.IsoDayOfWeek.Wednesday
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IsoDayOfWeek.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Wednesday
        path: src/NodaTime/IsoDayOfWeek.cs
        startLine: 30
      summary: "\nValue representing Wednesday (3).\n"
      example: []
      syntax:
        content:
          CSharp: Wednesday = 3
          VB: Wednesday = 3
        return:
          type: NodaTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.IsoDayOfWeek.Thursday
      commentId: F:NodaTime.IsoDayOfWeek.Thursday
      language: CSharp
      name:
        CSharp: Thursday
        VB: Thursday
      nameWithType:
        CSharp: IsoDayOfWeek.Thursday
        VB: IsoDayOfWeek.Thursday
      qualifiedName:
        CSharp: NodaTime.IsoDayOfWeek.Thursday
        VB: NodaTime.IsoDayOfWeek.Thursday
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IsoDayOfWeek.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Thursday
        path: src/NodaTime/IsoDayOfWeek.cs
        startLine: 34
      summary: "\nValue representing Thursday (4).\n"
      example: []
      syntax:
        content:
          CSharp: Thursday = 4
          VB: Thursday = 4
        return:
          type: NodaTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.IsoDayOfWeek.Friday
      commentId: F:NodaTime.IsoDayOfWeek.Friday
      language: CSharp
      name:
        CSharp: Friday
        VB: Friday
      nameWithType:
        CSharp: IsoDayOfWeek.Friday
        VB: IsoDayOfWeek.Friday
      qualifiedName:
        CSharp: NodaTime.IsoDayOfWeek.Friday
        VB: NodaTime.IsoDayOfWeek.Friday
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IsoDayOfWeek.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Friday
        path: src/NodaTime/IsoDayOfWeek.cs
        startLine: 38
      summary: "\nValue representing Friday (5).\n"
      example: []
      syntax:
        content:
          CSharp: Friday = 5
          VB: Friday = 5
        return:
          type: NodaTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.IsoDayOfWeek.Saturday
      commentId: F:NodaTime.IsoDayOfWeek.Saturday
      language: CSharp
      name:
        CSharp: Saturday
        VB: Saturday
      nameWithType:
        CSharp: IsoDayOfWeek.Saturday
        VB: IsoDayOfWeek.Saturday
      qualifiedName:
        CSharp: NodaTime.IsoDayOfWeek.Saturday
        VB: NodaTime.IsoDayOfWeek.Saturday
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IsoDayOfWeek.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Saturday
        path: src/NodaTime/IsoDayOfWeek.cs
        startLine: 42
      summary: "\nValue representing Saturday (6).\n"
      example: []
      syntax:
        content:
          CSharp: Saturday = 6
          VB: Saturday = 6
        return:
          type: NodaTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.IsoDayOfWeek.Sunday
      commentId: F:NodaTime.IsoDayOfWeek.Sunday
      language: CSharp
      name:
        CSharp: Sunday
        VB: Sunday
      nameWithType:
        CSharp: IsoDayOfWeek.Sunday
        VB: IsoDayOfWeek.Sunday
      qualifiedName:
        CSharp: NodaTime.IsoDayOfWeek.Sunday
        VB: NodaTime.IsoDayOfWeek.Sunday
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/IsoDayOfWeek.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Sunday
        path: src/NodaTime/IsoDayOfWeek.cs
        startLine: 46
      summary: "\nValue representing Sunday (7).\n"
      example: []
      syntax:
        content:
          CSharp: Sunday = 7
          VB: Sunday = 7
        return:
          type: NodaTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: NodaTime.LocalDate
    commentId: T:NodaTime.LocalDate
    language: CSharp
    name:
      CSharp: LocalDate
      VB: LocalDate
    nameWithType:
      CSharp: LocalDate
      VB: LocalDate
    qualifiedName:
      CSharp: NodaTime.LocalDate
      VB: NodaTime.LocalDate
    type: Struct
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/LocalDate.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: LocalDate
      path: src/NodaTime/LocalDate.cs
      startLine: 37
    summary: "\nLocalDate is an immutable struct representing a date within the calendar,\nwith no reference to a particular time zone or time of day.\n"
    remarks: "\n<p>Comparisons of dates can be handled in a way which is either calendar-sensitive or calendar-insensitive.\nNoda Time implements all the operators (and the <xref href=\"NodaTime.LocalDate.Equals(NodaTime.LocalDate)\" data-throw-if-not-resolved=\"false\"></xref> method) such that all operators other than <xref href=\"NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate%2cNodaTime.LocalDate)\" data-throw-if-not-resolved=\"false\"></xref>\nwill return false if asked to compare two values in different calendar systems.\n</p>\n<p>\nHowever, the <xref href=\"NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)\" data-throw-if-not-resolved=\"false\"></xref> method (implementing <xref href=\"System.IComparable%601\" data-throw-if-not-resolved=\"false\"></xref>) is calendar-insensitive; it compares the two\ndates historically in terms of when they actually occurred, as if they're both converted to some \"neutral\" calendar system first.\n</p>\n<p>\nIt's unclear at the time of this writing whether this is the most appropriate approach, and it may change in future versions. In general,\nit would be a good idea for users to avoid comparing dates in different calendar systems, and indeed most users are unlikely to ever explicitly\nconsider which calendar system they're working in anyway.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public struct LocalDate : IEquatable<LocalDate>, IComparable<LocalDate>, IComparable, IFormattable, IXmlSerializable, ISerializable
        VB: >-
          <Serializable>

          Public Structure LocalDate

              Implements IEquatable(Of LocalDate), IComparable(Of LocalDate), IComparable, IFormattable, IXmlSerializable, ISerializable
    implements:
    - System.IEquatable{NodaTime.LocalDate}
    - System.IComparable{NodaTime.LocalDate}
    - System.IComparable
    - System.IFormattable
    - System.Xml.Serialization.IXmlSerializable
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LocalDate(Int32, Int32, Int32)
        VB: LocalDate(Int32, Int32, Int32)
      nameWithType:
        CSharp: LocalDate.LocalDate(Int32, Int32, Int32)
        VB: LocalDate.LocalDate(Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDate.LocalDate(System.Int32, System.Int32, System.Int32)
        VB: NodaTime.LocalDate.LocalDate(System.Int32, System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDate.cs
        startLine: 54
      summary: "\nConstructs an instance for the given year, month and day in the ISO calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate(int year, int month, int day)
          VB: Public Sub New(year As Integer, month As Integer, day As Integer)
        parameters:
        - id: year
          type: System.Int32
          description: The year. This is the "absolute year", so a value of 0 means 1 BC, for example.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
      overload: NodaTime.LocalDate.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      commentId: M:NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: LocalDate(Int32, Int32, Int32, CalendarSystem)
        VB: LocalDate(Int32, Int32, Int32, CalendarSystem)
      nameWithType:
        CSharp: LocalDate.LocalDate(Int32, Int32, Int32, CalendarSystem)
        VB: LocalDate.LocalDate(Int32, Int32, Int32, CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.LocalDate.LocalDate(System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
        VB: NodaTime.LocalDate.LocalDate(System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDate.cs
        startLine: 70
      summary: "\nConstructs an instance for the given year, month and day in the specified calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate(int year, int month, int day, CalendarSystem calendar)
          VB: Public Sub New(year As Integer, month As Integer, day As Integer, calendar As CalendarSystem)
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year", so, for

            the ISO calendar, a value of 0 means 1 BC, for example.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
        - id: calendar
          type: NodaTime.CalendarSystem
          description: Calendar system in which to create the date.
      overload: NodaTime.LocalDate.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date.
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">calendar</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.LocalDate.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LocalDate(Era, Int32, Int32, Int32)
        VB: LocalDate(Era, Int32, Int32, Int32)
      nameWithType:
        CSharp: LocalDate.LocalDate(Era, Int32, Int32, Int32)
        VB: LocalDate.LocalDate(Era, Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDate.LocalDate(NodaTime.Calendars.Era, System.Int32, System.Int32, System.Int32)
        VB: NodaTime.LocalDate.LocalDate(NodaTime.Calendars.Era, System.Int32, System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDate.cs
        startLine: 84
      summary: "\nConstructs an instance for the given era, year of era, month and day in the ISO calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate(Era era, int yearOfEra, int month, int day)
          VB: Public Sub New(era As Era, yearOfEra As Integer, month As Integer, day As Integer)
        parameters:
        - id: era
          type: NodaTime.Calendars.Era
          description: The era within which to create a date. Must be a valid era within the ISO calendar.
        - id: yearOfEra
          type: System.Int32
          description: The year of era.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
      overload: NodaTime.LocalDate.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      commentId: M:NodaTime.LocalDate.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: LocalDate(Era, Int32, Int32, Int32, CalendarSystem)
        VB: LocalDate(Era, Int32, Int32, Int32, CalendarSystem)
      nameWithType:
        CSharp: LocalDate.LocalDate(Era, Int32, Int32, Int32, CalendarSystem)
        VB: LocalDate.LocalDate(Era, Int32, Int32, Int32, CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.LocalDate.LocalDate(NodaTime.Calendars.Era, System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
        VB: NodaTime.LocalDate.LocalDate(NodaTime.Calendars.Era, System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDate.cs
        startLine: 100
      summary: "\nConstructs an instance for the given era, year of era, month and day in the specified calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate(Era era, int yearOfEra, int month, int day, CalendarSystem calendar)
          VB: Public Sub New(era As Era, yearOfEra As Integer, month As Integer, day As Integer, calendar As CalendarSystem)
        parameters:
        - id: era
          type: NodaTime.Calendars.Era
          description: The era within which to create a date. Must be a valid era within the specified calendar.
        - id: yearOfEra
          type: System.Int32
          description: The year of era.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
        - id: calendar
          type: NodaTime.CalendarSystem
          description: Calendar system in which to create the date.
      overload: NodaTime.LocalDate.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date.
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">calendar</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.Calendar
      commentId: P:NodaTime.LocalDate.Calendar
      language: CSharp
      name:
        CSharp: Calendar
        VB: Calendar
      nameWithType:
        CSharp: LocalDate.Calendar
        VB: LocalDate.Calendar
      qualifiedName:
        CSharp: NodaTime.LocalDate.Calendar
        VB: NodaTime.LocalDate.Calendar
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Calendar
        path: src/NodaTime/LocalDate.cs
        startLine: 112
      summary: Gets the calendar system associated with this local date.
      example: []
      syntax:
        content:
          CSharp: public CalendarSystem Calendar { get; }
          VB: Public ReadOnly Property Calendar As CalendarSystem
        parameters: []
        return:
          type: NodaTime.CalendarSystem
      overload: NodaTime.LocalDate.Calendar*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDate.Year
      commentId: P:NodaTime.LocalDate.Year
      language: CSharp
      name:
        CSharp: Year
        VB: Year
      nameWithType:
        CSharp: LocalDate.Year
        VB: LocalDate.Year
      qualifiedName:
        CSharp: NodaTime.LocalDate.Year
        VB: NodaTime.LocalDate.Year
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Year
        path: src/NodaTime/LocalDate.cs
        startLine: 117
      summary: Gets the year of this local date.
      remarks: >-
        This returns the "absolute year", so, for the ISO calendar,

        a value of 0 means 1 BC, for example.
      example: []
      syntax:
        content:
          CSharp: public int Year { get; }
          VB: Public ReadOnly Property Year As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDate.Year*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDate.Month
      commentId: P:NodaTime.LocalDate.Month
      language: CSharp
      name:
        CSharp: Month
        VB: Month
      nameWithType:
        CSharp: LocalDate.Month
        VB: LocalDate.Month
      qualifiedName:
        CSharp: NodaTime.LocalDate.Month
        VB: NodaTime.LocalDate.Month
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Month
        path: src/NodaTime/LocalDate.cs
        startLine: 120
      summary: Gets the month of this local date within the year.
      example: []
      syntax:
        content:
          CSharp: public int Month { get; }
          VB: Public ReadOnly Property Month As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDate.Month*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDate.Day
      commentId: P:NodaTime.LocalDate.Day
      language: CSharp
      name:
        CSharp: Day
        VB: Day
      nameWithType:
        CSharp: LocalDate.Day
        VB: LocalDate.Day
      qualifiedName:
        CSharp: NodaTime.LocalDate.Day
        VB: NodaTime.LocalDate.Day
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Day
        path: src/NodaTime/LocalDate.cs
        startLine: 123
      summary: Gets the day of this local date within the month.
      example: []
      syntax:
        content:
          CSharp: public int Day { get; }
          VB: Public ReadOnly Property Day As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDate.Day*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDate.IsoDayOfWeek
      commentId: P:NodaTime.LocalDate.IsoDayOfWeek
      language: CSharp
      name:
        CSharp: IsoDayOfWeek
        VB: IsoDayOfWeek
      nameWithType:
        CSharp: LocalDate.IsoDayOfWeek
        VB: LocalDate.IsoDayOfWeek
      qualifiedName:
        CSharp: NodaTime.LocalDate.IsoDayOfWeek
        VB: NodaTime.LocalDate.IsoDayOfWeek
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: IsoDayOfWeek
        path: src/NodaTime/LocalDate.cs
        startLine: 131
      summary: "\nGets the week day of this local date expressed as an <xref href=\"NodaTime.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref> value,\nfor calendars which use ISO days of the week.\n"
      example: []
      syntax:
        content:
          CSharp: public IsoDayOfWeek IsoDayOfWeek { get; }
          VB: Public ReadOnly Property IsoDayOfWeek As IsoDayOfWeek
        parameters: []
        return:
          type: NodaTime.IsoDayOfWeek
      overload: NodaTime.LocalDate.IsoDayOfWeek*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The underlying calendar doesn't use ISO days of the week.
      seealso:
      - linkId: NodaTime.LocalDate.DayOfWeek
        commentId: P:NodaTime.LocalDate.DayOfWeek
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.IsoDayOfWeek: 
        NodaTime.LocalDate.DayOfWeek: 
    - id: NodaTime.LocalDate.DayOfWeek
      commentId: P:NodaTime.LocalDate.DayOfWeek
      language: CSharp
      name:
        CSharp: DayOfWeek
        VB: DayOfWeek
      nameWithType:
        CSharp: LocalDate.DayOfWeek
        VB: LocalDate.DayOfWeek
      qualifiedName:
        CSharp: NodaTime.LocalDate.DayOfWeek
        VB: NodaTime.LocalDate.DayOfWeek
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DayOfWeek
        path: src/NodaTime/LocalDate.cs
        startLine: 140
      summary: "\nGets the week day of this local date as a number.\n"
      remarks: "\nFor calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.\n"
      example: []
      syntax:
        content:
          CSharp: public int DayOfWeek { get; }
          VB: Public ReadOnly Property DayOfWeek As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDate.DayOfWeek*
      seealso:
      - linkId: NodaTime.LocalDate.IsoDayOfWeek
        commentId: P:NodaTime.LocalDate.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDate.IsoDayOfWeek: 
    - id: NodaTime.LocalDate.WeekYear
      commentId: P:NodaTime.LocalDate.WeekYear
      language: CSharp
      name:
        CSharp: WeekYear
        VB: WeekYear
      nameWithType:
        CSharp: LocalDate.WeekYear
        VB: LocalDate.WeekYear
      qualifiedName:
        CSharp: NodaTime.LocalDate.WeekYear
        VB: NodaTime.LocalDate.WeekYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WeekYear
        path: src/NodaTime/LocalDate.cs
        startLine: 160
      summary: "\nGets the \"week year\" of this local date.\n"
      remarks: "\n<p>\nThe WeekYear is the year that matches with the <xref href=\"NodaTime.LocalDate.WeekOfWeekYear\" data-throw-if-not-resolved=\"false\"></xref> field.\nIn the standard ISO8601 week algorithm, the first week of the year\nis that in which at least 4 days are in the year. As a result of this\ndefinition, day 1 of the first week may be in the previous year.\nThe WeekYear allows you to query the effective year for that day.\n</p>\n<p>\nFor example, January 1st 2011 was a Saturday, so only two days of that week\n(Saturday and Sunday) were in 2011. Therefore January 1st is part of\nweek 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,\nso is part of week 1 of WeekYear 2013.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public int WeekYear { get; }
          VB: Public ReadOnly Property WeekYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDate.WeekYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDate.WeekOfWeekYear: 
    - id: NodaTime.LocalDate.WeekOfWeekYear
      commentId: P:NodaTime.LocalDate.WeekOfWeekYear
      language: CSharp
      name:
        CSharp: WeekOfWeekYear
        VB: WeekOfWeekYear
      nameWithType:
        CSharp: LocalDate.WeekOfWeekYear
        VB: LocalDate.WeekOfWeekYear
      qualifiedName:
        CSharp: NodaTime.LocalDate.WeekOfWeekYear
        VB: NodaTime.LocalDate.WeekOfWeekYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WeekOfWeekYear
        path: src/NodaTime/LocalDate.cs
        startLine: 163
      summary: Gets the week within the WeekYear. See <xref href="NodaTime.LocalDate.WeekYear" data-throw-if-not-resolved="false"></xref> for more details.
      example: []
      syntax:
        content:
          CSharp: public int WeekOfWeekYear { get; }
          VB: Public ReadOnly Property WeekOfWeekYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDate.WeekOfWeekYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDate.WeekYear: 
    - id: NodaTime.LocalDate.YearOfCentury
      commentId: P:NodaTime.LocalDate.YearOfCentury
      language: CSharp
      name:
        CSharp: YearOfCentury
        VB: YearOfCentury
      nameWithType:
        CSharp: LocalDate.YearOfCentury
        VB: LocalDate.YearOfCentury
      qualifiedName:
        CSharp: NodaTime.LocalDate.YearOfCentury
        VB: NodaTime.LocalDate.YearOfCentury
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: YearOfCentury
        path: src/NodaTime/LocalDate.cs
        startLine: 167
      summary: Gets the year of this local date within the century.
      remarks: This always returns a value in the range 0 to 99 inclusive.
      example: []
      syntax:
        content:
          CSharp: public int YearOfCentury { get; }
          VB: Public ReadOnly Property YearOfCentury As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDate.YearOfCentury*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDate.YearOfEra
      commentId: P:NodaTime.LocalDate.YearOfEra
      language: CSharp
      name:
        CSharp: YearOfEra
        VB: YearOfEra
      nameWithType:
        CSharp: LocalDate.YearOfEra
        VB: LocalDate.YearOfEra
      qualifiedName:
        CSharp: NodaTime.LocalDate.YearOfEra
        VB: NodaTime.LocalDate.YearOfEra
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: YearOfEra
        path: src/NodaTime/LocalDate.cs
        startLine: 170
      summary: Gets the year of this local date within the era.
      example: []
      syntax:
        content:
          CSharp: public int YearOfEra { get; }
          VB: Public ReadOnly Property YearOfEra As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDate.YearOfEra*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDate.Era
      commentId: P:NodaTime.LocalDate.Era
      language: CSharp
      name:
        CSharp: Era
        VB: Era
      nameWithType:
        CSharp: LocalDate.Era
        VB: LocalDate.Era
      qualifiedName:
        CSharp: NodaTime.LocalDate.Era
        VB: NodaTime.LocalDate.Era
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Era
        path: src/NodaTime/LocalDate.cs
        startLine: 173
      summary: Gets the era of this local date.
      example: []
      syntax:
        content:
          CSharp: public Era Era { get; }
          VB: Public ReadOnly Property Era As Era
        parameters: []
        return:
          type: NodaTime.Calendars.Era
      overload: NodaTime.LocalDate.Era*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDate.DayOfYear
      commentId: P:NodaTime.LocalDate.DayOfYear
      language: CSharp
      name:
        CSharp: DayOfYear
        VB: DayOfYear
      nameWithType:
        CSharp: LocalDate.DayOfYear
        VB: LocalDate.DayOfYear
      qualifiedName:
        CSharp: NodaTime.LocalDate.DayOfYear
        VB: NodaTime.LocalDate.DayOfYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DayOfYear
        path: src/NodaTime/LocalDate.cs
        startLine: 176
      summary: Gets the day of this local date within the year.
      example: []
      syntax:
        content:
          CSharp: public int DayOfYear { get; }
          VB: Public ReadOnly Property DayOfYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDate.DayOfYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDate.AtMidnight
      commentId: M:NodaTime.LocalDate.AtMidnight
      language: CSharp
      name:
        CSharp: AtMidnight()
        VB: AtMidnight()
      nameWithType:
        CSharp: LocalDate.AtMidnight()
        VB: LocalDate.AtMidnight()
      qualifiedName:
        CSharp: NodaTime.LocalDate.AtMidnight()
        VB: NodaTime.LocalDate.AtMidnight()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: AtMidnight
        path: src/NodaTime/LocalDate.cs
        startLine: 183
      summary: "\nGets a <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> at midnight on the date represented by this local date.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime AtMidnight()
          VB: Public Function AtMidnight As LocalDateTime
        return:
          type: NodaTime.LocalDateTime
          description: >-
            The <xref href="NodaTime.LocalDateTime" data-throw-if-not-resolved="false"></xref> representing midnight on tthis local date, in the same calendar

            system.
      overload: NodaTime.LocalDate.AtMidnight*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDate.FromWeekYearWeekAndDay(System.Int32,System.Int32,NodaTime.IsoDayOfWeek)
      commentId: M:NodaTime.LocalDate.FromWeekYearWeekAndDay(System.Int32,System.Int32,NodaTime.IsoDayOfWeek)
      language: CSharp
      name:
        CSharp: FromWeekYearWeekAndDay(Int32, Int32, IsoDayOfWeek)
        VB: FromWeekYearWeekAndDay(Int32, Int32, IsoDayOfWeek)
      nameWithType:
        CSharp: LocalDate.FromWeekYearWeekAndDay(Int32, Int32, IsoDayOfWeek)
        VB: LocalDate.FromWeekYearWeekAndDay(Int32, Int32, IsoDayOfWeek)
      qualifiedName:
        CSharp: NodaTime.LocalDate.FromWeekYearWeekAndDay(System.Int32, System.Int32, NodaTime.IsoDayOfWeek)
        VB: NodaTime.LocalDate.FromWeekYearWeekAndDay(System.Int32, System.Int32, NodaTime.IsoDayOfWeek)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromWeekYearWeekAndDay
        path: src/NodaTime/LocalDate.cs
        startLine: 196
      summary: "\nReturns the local date corresponding to the given \"week year\", \"week of week year\", and \"day of week\"\nin the ISO calendar system.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDate FromWeekYearWeekAndDay(int weekYear, int weekOfWeekYear, IsoDayOfWeek dayOfWeek)
          VB: Public Shared Function FromWeekYearWeekAndDay(weekYear As Integer, weekOfWeekYear As Integer, dayOfWeek As IsoDayOfWeek) As LocalDate
        parameters:
        - id: weekYear
          type: System.Int32
          description: ISO-8601 week year of value to return
        - id: weekOfWeekYear
          type: System.Int32
          description: ISO-8601 week of week year of value to return
        - id: dayOfWeek
          type: NodaTime.IsoDayOfWeek
          description: ISO-8601 day of week to return
        return:
          type: NodaTime.LocalDate
          description: The date corresponding to the given week year / week of week year / day of week.
      overload: NodaTime.LocalDate.FromWeekYearWeekAndDay*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.Period)
      commentId: M:NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Addition(LocalDate, Period)
        VB: Addition(LocalDate, Period)
      nameWithType:
        CSharp: LocalDate.Addition(LocalDate, Period)
        VB: LocalDate.Addition(LocalDate, Period)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Addition(NodaTime.LocalDate, NodaTime.Period)
        VB: NodaTime.LocalDate.Addition(NodaTime.LocalDate, NodaTime.Period)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Addition
        path: src/NodaTime/LocalDate.cs
        startLine: 208
      summary: "\nAdds the specified period to the date.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDate operator +(LocalDate date, Period period)
          VB: Public Shared Operator +(date As LocalDate, period As Period) As LocalDate
        parameters:
        - id: date
          type: NodaTime.LocalDate
          description: The date to add the period to
        - id: period
          type: NodaTime.Period
          description: The period to add. Must not contain any (non-zero) time units.
        return:
          type: NodaTime.LocalDate
          description: The sum of the given date and period
      overload: NodaTime.LocalDate.op_Addition*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDate.Add(NodaTime.LocalDate,NodaTime.Period)
      commentId: M:NodaTime.LocalDate.Add(NodaTime.LocalDate,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Add(LocalDate, Period)
        VB: Add(LocalDate, Period)
      nameWithType:
        CSharp: LocalDate.Add(LocalDate, Period)
        VB: LocalDate.Add(LocalDate, Period)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Add(NodaTime.LocalDate, NodaTime.Period)
        VB: NodaTime.LocalDate.Add(NodaTime.LocalDate, NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Add
        path: src/NodaTime/LocalDate.cs
        startLine: 221
      summary: "\nAdds the specified period to the date. Friendly alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDate Add(LocalDate date, Period period)
          VB: Public Shared Function Add(date As LocalDate, period As Period) As LocalDate
        parameters:
        - id: date
          type: NodaTime.LocalDate
          description: The date to add the period to
        - id: period
          type: NodaTime.Period
          description: The period to add. Must not contain any (non-zero) time units.
        return:
          type: NodaTime.LocalDate
          description: The sum of the given date and period
      overload: NodaTime.LocalDate.Add*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDate.Plus(NodaTime.Period)
      commentId: M:NodaTime.LocalDate.Plus(NodaTime.Period)
      language: CSharp
      name:
        CSharp: Plus(Period)
        VB: Plus(Period)
      nameWithType:
        CSharp: LocalDate.Plus(Period)
        VB: LocalDate.Plus(Period)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Plus(NodaTime.Period)
        VB: NodaTime.LocalDate.Plus(NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Plus
        path: src/NodaTime/LocalDate.cs
        startLine: 231
      summary: "\nAdds the specified period to this date. Fluent alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate Plus(Period period)
          VB: Public Function Plus(period As Period) As LocalDate
        parameters:
        - id: period
          type: NodaTime.Period
          description: The period to add. Must not contain any (non-zero) time units.
        return:
          type: NodaTime.LocalDate
          description: The sum of this date and the given period
      overload: NodaTime.LocalDate.Plus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.LocalTime)
      commentId: M:NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: Addition(LocalDate, LocalTime)
        VB: Addition(LocalDate, LocalTime)
      nameWithType:
        CSharp: LocalDate.Addition(LocalDate, LocalTime)
        VB: LocalDate.Addition(LocalDate, LocalTime)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Addition(NodaTime.LocalDate, NodaTime.LocalTime)
        VB: NodaTime.LocalDate.Addition(NodaTime.LocalDate, NodaTime.LocalTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Addition
        path: src/NodaTime/LocalDate.cs
        startLine: 243
      summary: "\nCombines the given <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.LocalTime\" data-throw-if-not-resolved=\"false\"></xref> components\ninto a single <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTime operator +(LocalDate date, LocalTime time)
          VB: Public Shared Operator +(date As LocalDate, time As LocalTime) As LocalDateTime
        parameters:
        - id: date
          type: NodaTime.LocalDate
          description: The date to add the time to
        - id: time
          type: NodaTime.LocalTime
          description: The time to add
        return:
          type: NodaTime.LocalDateTime
          description: The sum of the given date and time
      overload: NodaTime.LocalDate.op_Addition*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.LocalDate: 
        NodaTime.LocalTime: 
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDate.op_Subtraction(NodaTime.LocalDate,NodaTime.Period)
      commentId: M:NodaTime.LocalDate.op_Subtraction(NodaTime.LocalDate,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Subtraction(LocalDate, Period)
        VB: Subtraction(LocalDate, Period)
      nameWithType:
        CSharp: LocalDate.Subtraction(LocalDate, Period)
        VB: LocalDate.Subtraction(LocalDate, Period)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Subtraction(NodaTime.LocalDate, NodaTime.Period)
        VB: NodaTime.LocalDate.Subtraction(NodaTime.LocalDate, NodaTime.Period)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Subtraction
        path: src/NodaTime/LocalDate.cs
        startLine: 256
      summary: "\nSubtracts the specified period from the date.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDate operator -(LocalDate date, Period period)
          VB: Public Shared Operator -(date As LocalDate, period As Period) As LocalDate
        parameters:
        - id: date
          type: NodaTime.LocalDate
          description: The date to subtract the period from
        - id: period
          type: NodaTime.Period
          description: The period to subtract. Must not contain any (non-zero) time units.
        return:
          type: NodaTime.LocalDate
          description: The result of subtracting the given period from the date
      overload: NodaTime.LocalDate.op_Subtraction*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDate.Subtract(NodaTime.LocalDate,NodaTime.Period)
      commentId: M:NodaTime.LocalDate.Subtract(NodaTime.LocalDate,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Subtract(LocalDate, Period)
        VB: Subtract(LocalDate, Period)
      nameWithType:
        CSharp: LocalDate.Subtract(LocalDate, Period)
        VB: LocalDate.Subtract(LocalDate, Period)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Subtract(NodaTime.LocalDate, NodaTime.Period)
        VB: NodaTime.LocalDate.Subtract(NodaTime.LocalDate, NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Subtract
        path: src/NodaTime/LocalDate.cs
        startLine: 269
      summary: "\nSubtracts the specified period from the date. Friendly alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDate Subtract(LocalDate date, Period period)
          VB: Public Shared Function Subtract(date As LocalDate, period As Period) As LocalDate
        parameters:
        - id: date
          type: NodaTime.LocalDate
          description: The date to subtract the period from
        - id: period
          type: NodaTime.Period
          description: The period to subtract. Must not contain any (non-zero) time units.
        return:
          type: NodaTime.LocalDate
          description: The result of subtracting the given period from the date.
      overload: NodaTime.LocalDate.Subtract*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDate.Minus(NodaTime.Period)
      commentId: M:NodaTime.LocalDate.Minus(NodaTime.Period)
      language: CSharp
      name:
        CSharp: Minus(Period)
        VB: Minus(Period)
      nameWithType:
        CSharp: LocalDate.Minus(Period)
        VB: LocalDate.Minus(Period)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Minus(NodaTime.Period)
        VB: NodaTime.LocalDate.Minus(NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minus
        path: src/NodaTime/LocalDate.cs
        startLine: 279
      summary: "\nSubtracts the specified period from this date. Fluent alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate Minus(Period period)
          VB: Public Function Minus(period As Period) As LocalDate
        parameters:
        - id: period
          type: NodaTime.Period
          description: The period to subtract. Must not contain any (non-zero) time units.
        return:
          type: NodaTime.LocalDate
          description: The result of subtracting the given period from this date.
      overload: NodaTime.LocalDate.Minus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.op_Equality(NodaTime.LocalDate,NodaTime.LocalDate)
      commentId: M:NodaTime.LocalDate.op_Equality(NodaTime.LocalDate,NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: Equality(LocalDate, LocalDate)
        VB: Equality(LocalDate, LocalDate)
      nameWithType:
        CSharp: LocalDate.Equality(LocalDate, LocalDate)
        VB: LocalDate.Equality(LocalDate, LocalDate)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Equality(NodaTime.LocalDate, NodaTime.LocalDate)
        VB: NodaTime.LocalDate.Equality(NodaTime.LocalDate, NodaTime.LocalDate)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Equality
        path: src/NodaTime/LocalDate.cs
        startLine: 291
      summary: "\nCompares two <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref> values for equality. This requires\nthat the dates be the same, within the same calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator ==(LocalDate lhs, LocalDate rhs)
          VB: Public Shared Operator =(lhs As LocalDate, rhs As LocalDate) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalDate
          description: The first value to compare
        - id: rhs
          type: NodaTime.LocalDate
          description: The second value to compare
        return:
          type: System.Boolean
          description: True if the two dates are the same and in the same calendar; false otherwise
      overload: NodaTime.LocalDate.op_Equality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.LocalDate: 
    - id: NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate)
      commentId: M:NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: Inequality(LocalDate, LocalDate)
        VB: Inequality(LocalDate, LocalDate)
      nameWithType:
        CSharp: LocalDate.Inequality(LocalDate, LocalDate)
        VB: LocalDate.Inequality(LocalDate, LocalDate)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Inequality(NodaTime.LocalDate, NodaTime.LocalDate)
        VB: NodaTime.LocalDate.Inequality(NodaTime.LocalDate, NodaTime.LocalDate)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Inequality
        path: src/NodaTime/LocalDate.cs
        startLine: 302
      summary: "\nCompares two <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref> values for inequality.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator !=(LocalDate lhs, LocalDate rhs)
          VB: Public Shared Operator <>(lhs As LocalDate, rhs As LocalDate) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalDate
          description: The first value to compare
        - id: rhs
          type: NodaTime.LocalDate
          description: The second value to compare
        return:
          type: System.Boolean
          description: False if the two dates are the same and in the same calendar; true otherwise
      overload: NodaTime.LocalDate.op_Inequality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.LocalDate: 
    - id: NodaTime.LocalDate.op_LessThan(NodaTime.LocalDate,NodaTime.LocalDate)
      commentId: M:NodaTime.LocalDate.op_LessThan(NodaTime.LocalDate,NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: LessThan(LocalDate, LocalDate)
        VB: LessThan(LocalDate, LocalDate)
      nameWithType:
        CSharp: LocalDate.LessThan(LocalDate, LocalDate)
        VB: LocalDate.LessThan(LocalDate, LocalDate)
      qualifiedName:
        CSharp: NodaTime.LocalDate.LessThan(NodaTime.LocalDate, NodaTime.LocalDate)
        VB: NodaTime.LocalDate.LessThan(NodaTime.LocalDate, NodaTime.LocalDate)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThan
        path: src/NodaTime/LocalDate.cs
        startLine: 318
      summary: "\nCompares two LocalDate values to see if the left one is strictly earlier than the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars. See the top-level type\ndocumentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <(LocalDate lhs, LocalDate rhs)
          VB: Public Shared Operator <(lhs As LocalDate, rhs As LocalDate) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalDate
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalDate
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is strictly earlier than <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalDate.op_LessThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDate.op_LessThanOrEqual(NodaTime.LocalDate,NodaTime.LocalDate)
      commentId: M:NodaTime.LocalDate.op_LessThanOrEqual(NodaTime.LocalDate,NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: LessThanOrEqual(LocalDate, LocalDate)
        VB: LessThanOrEqual(LocalDate, LocalDate)
      nameWithType:
        CSharp: LocalDate.LessThanOrEqual(LocalDate, LocalDate)
        VB: LocalDate.LessThanOrEqual(LocalDate, LocalDate)
      qualifiedName:
        CSharp: NodaTime.LocalDate.LessThanOrEqual(NodaTime.LocalDate, NodaTime.LocalDate)
        VB: NodaTime.LocalDate.LessThanOrEqual(NodaTime.LocalDate, NodaTime.LocalDate)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThanOrEqual
        path: src/NodaTime/LocalDate.cs
        startLine: 334
      summary: "\nCompares two LocalDate values to see if the left one is earlier than or equal to the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars. See the top-level type\ndocumentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <=(LocalDate lhs, LocalDate rhs)
          VB: Public Shared Operator <=(lhs As LocalDate, rhs As LocalDate) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalDate
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalDate
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is earlier than or equal to <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalDate.op_LessThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDate.op_GreaterThan(NodaTime.LocalDate,NodaTime.LocalDate)
      commentId: M:NodaTime.LocalDate.op_GreaterThan(NodaTime.LocalDate,NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: GreaterThan(LocalDate, LocalDate)
        VB: GreaterThan(LocalDate, LocalDate)
      nameWithType:
        CSharp: LocalDate.GreaterThan(LocalDate, LocalDate)
        VB: LocalDate.GreaterThan(LocalDate, LocalDate)
      qualifiedName:
        CSharp: NodaTime.LocalDate.GreaterThan(NodaTime.LocalDate, NodaTime.LocalDate)
        VB: NodaTime.LocalDate.GreaterThan(NodaTime.LocalDate, NodaTime.LocalDate)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThan
        path: src/NodaTime/LocalDate.cs
        startLine: 350
      summary: "\nCompares two LocalDate values to see if the left one is strictly later than the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars. See the top-level type\ndocumentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator>(LocalDate lhs, LocalDate rhs)
          VB: Public Shared Operator>(lhs As LocalDate, rhs As LocalDate) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalDate
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalDate
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is strictly later than <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalDate.op_GreaterThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDate.op_GreaterThanOrEqual(NodaTime.LocalDate,NodaTime.LocalDate)
      commentId: M:NodaTime.LocalDate.op_GreaterThanOrEqual(NodaTime.LocalDate,NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: GreaterThanOrEqual(LocalDate, LocalDate)
        VB: GreaterThanOrEqual(LocalDate, LocalDate)
      nameWithType:
        CSharp: LocalDate.GreaterThanOrEqual(LocalDate, LocalDate)
        VB: LocalDate.GreaterThanOrEqual(LocalDate, LocalDate)
      qualifiedName:
        CSharp: NodaTime.LocalDate.GreaterThanOrEqual(NodaTime.LocalDate, NodaTime.LocalDate)
        VB: NodaTime.LocalDate.GreaterThanOrEqual(NodaTime.LocalDate, NodaTime.LocalDate)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThanOrEqual
        path: src/NodaTime/LocalDate.cs
        startLine: 366
      summary: "\nCompares two LocalDate values to see if the left one is later than or equal to the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars. See the top-level type\ndocumentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator >=(LocalDate lhs, LocalDate rhs)
          VB: Public Shared Operator >=(lhs As LocalDate, rhs As LocalDate) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalDate
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalDate
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is later than or equal to <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalDate.op_GreaterThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)
      commentId: M:NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: CompareTo(LocalDate)
        VB: CompareTo(LocalDate)
      nameWithType:
        CSharp: LocalDate.CompareTo(LocalDate)
        VB: LocalDate.CompareTo(LocalDate)
      qualifiedName:
        CSharp: NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)
        VB: NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CompareTo
        path: src/NodaTime/LocalDate.cs
        startLine: 385
      summary: "\nIndicates whether this date is earlier, later or the same as another one.\n"
      remarks: "\nThe comparison is performed in terms of a calendar-independent notion of date;\nthe calendar systems of both <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref> values are ignored. When both values use the same calendar,\nthis is absolutely natural. However, when comparing a value in one calendar with a value in another,\nthis can lead to surprising results. For example, 1945 in the ISO calendar corresponds to around 1364\nin the Islamic calendar, so an Islamic date in year 1400 is \"after\" a date in 1945 in the ISO calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public int CompareTo(LocalDate other)
          VB: Public Function CompareTo(other As LocalDate) As Integer
        parameters:
        - id: other
          type: NodaTime.LocalDate
          description: The other date to compare this one with
        return:
          type: System.Int32
          description: >-
            A value less than zero if this date is earlier than <span class="paramref">other</span>;

            zero if this date is the same as <span class="paramref">other</span>; a value greater than zero if this date is

            later than <span class="paramref">other</span>.
      overload: NodaTime.LocalDate.CompareTo*
      implements:
      - System.IComparable{NodaTime.LocalDate}.CompareTo(NodaTime.LocalDate)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDate: 
    - isEii: true
      id: NodaTime.LocalDate.System#IComparable#CompareTo(System.Object)
      commentId: M:NodaTime.LocalDate.System#IComparable#CompareTo(System.Object)
      language: CSharp
      name:
        CSharp: IComparable.CompareTo(Object)
        VB: System.IComparable.CompareTo(Object)
      nameWithType:
        CSharp: LocalDate.IComparable.CompareTo(Object)
        VB: LocalDate.System.IComparable.CompareTo(Object)
      qualifiedName:
        CSharp: NodaTime.LocalDate.System.IComparable.CompareTo(System.Object)
        VB: NodaTime.LocalDate.System.IComparable.CompareTo(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.IComparable.CompareTo
        path: src/NodaTime/LocalDate.cs
        startLine: 401
      summary: "\nImplementation of <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to compare two LocalDates.\n"
      remarks: "\nThis uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.\n"
      example: []
      syntax:
        content:
          CSharp: int IComparable.CompareTo(object obj)
          VB: Function System.IComparable.CompareTo(obj As Object) As Integer Implements IComparable.CompareTo
        parameters:
        - id: obj
          type: System.Object
          description: The object to compare this value with.
        return:
          type: System.Int32
          description: >
            The result of comparing this LocalDate with another one; see <xref href="NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)" data-throw-if-not-resolved="false"></xref> for general details.

            If <span class="paramref">obj</span> is null, this method returns a value greater than 0.
      overload: NodaTime.LocalDate.System#IComparable#CompareTo*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">obj</span> is non-null but does not refer to an instance of <xref href="NodaTime.LocalDate" data-throw-if-not-resolved="false"></xref>.
      implements:
      - System.IComparable.CompareTo(System.Object)
      modifiers:
        CSharp: []
        VB: []
      references:
        System.IComparable.CompareTo(System.Object): 
        NodaTime.LocalDate: 
        NodaTime.LocalDate.CompareTo(NodaTime.LocalDate): 
    - id: NodaTime.LocalDate.GetHashCode
      commentId: M:NodaTime.LocalDate.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: LocalDate.GetHashCode()
        VB: LocalDate.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.LocalDate.GetHashCode()
        VB: NodaTime.LocalDate.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/LocalDate.cs
        startLine: 415
      summary: "\nReturns a hash code for this local date.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: A hash code for this local date.
      overload: NodaTime.LocalDate.GetHashCode*
      overridden: System.ValueType.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.LocalDate.Equals(System.Object)
      commentId: M:NodaTime.LocalDate.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: LocalDate.Equals(Object)
        VB: LocalDate.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Equals(System.Object)
        VB: NodaTime.LocalDate.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/LocalDate.cs
        startLine: 426
      summary: "\nCompares two <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref> values for equality. This requires\nthat the dates be the same, within the same calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: The object to compare this date with.
        return:
          type: System.Boolean
          description: True if the given value is another local date equal to this one; false otherwise.
      overload: NodaTime.LocalDate.Equals*
      overridden: System.ValueType.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        NodaTime.LocalDate: 
    - id: NodaTime.LocalDate.Equals(NodaTime.LocalDate)
      commentId: M:NodaTime.LocalDate.Equals(NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: Equals(LocalDate)
        VB: Equals(LocalDate)
      nameWithType:
        CSharp: LocalDate.Equals(LocalDate)
        VB: LocalDate.Equals(LocalDate)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Equals(NodaTime.LocalDate)
        VB: NodaTime.LocalDate.Equals(NodaTime.LocalDate)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/LocalDate.cs
        startLine: 441
      summary: "\nCompares two <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref> values for equality. This requires\nthat the dates be the same, within the same calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(LocalDate other)
          VB: Public Function Equals(other As LocalDate) As Boolean
        parameters:
        - id: other
          type: NodaTime.LocalDate
          description: The value to compare this date with.
        return:
          type: System.Boolean
          description: True if the given value is another local date equal to this one; false otherwise.
      overload: NodaTime.LocalDate.Equals*
      implements:
      - System.IEquatable{NodaTime.LocalDate}.Equals(NodaTime.LocalDate)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDate: 
    - id: NodaTime.LocalDate.WithCalendar(NodaTime.CalendarSystem)
      commentId: M:NodaTime.LocalDate.WithCalendar(NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: WithCalendar(CalendarSystem)
        VB: WithCalendar(CalendarSystem)
      nameWithType:
        CSharp: LocalDate.WithCalendar(CalendarSystem)
        VB: LocalDate.WithCalendar(CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.LocalDate.WithCalendar(NodaTime.CalendarSystem)
        VB: NodaTime.LocalDate.WithCalendar(NodaTime.CalendarSystem)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCalendar
        path: src/NodaTime/LocalDate.cs
        startLine: 454
      summary: "\nCreates a new LocalDate representing the same physical date, but in a different calendar.\nThe returned LocalDate is likely to have different field values to this one.\nFor example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate WithCalendar(CalendarSystem calendarSystem)
          VB: Public Function WithCalendar(calendarSystem As CalendarSystem) As LocalDate
        parameters:
        - id: calendarSystem
          type: NodaTime.CalendarSystem
          description: The calendar system to convert this local date to.
        return:
          type: NodaTime.LocalDate
          description: The converted LocalDate
      overload: NodaTime.LocalDate.WithCalendar*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">calendarSystem</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.PlusYears(System.Int32)
      commentId: M:NodaTime.LocalDate.PlusYears(System.Int32)
      language: CSharp
      name:
        CSharp: PlusYears(Int32)
        VB: PlusYears(Int32)
      nameWithType:
        CSharp: LocalDate.PlusYears(Int32)
        VB: LocalDate.PlusYears(Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDate.PlusYears(System.Int32)
        VB: NodaTime.LocalDate.PlusYears(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusYears
        path: src/NodaTime/LocalDate.cs
        startLine: 469
      summary: "\nReturns a new LocalDate representing the current value with the given number of years added.\n"
      remarks: "\nIf the resulting date is invalid, lower fields (typically the day of month) are reduced to find a valid value.\nFor example, adding one year to February 29th 2012 will return February 28th 2013; subtracting one year from\nFebruary 29th 2012 will return February 28th 2011.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate PlusYears(int years)
          VB: Public Function PlusYears(years As Integer) As LocalDate
        parameters:
        - id: years
          type: System.Int32
          description: The number of years to add
        return:
          type: NodaTime.LocalDate
          description: The current value plus the given number of years.
      overload: NodaTime.LocalDate.PlusYears*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.PlusMonths(System.Int32)
      commentId: M:NodaTime.LocalDate.PlusMonths(System.Int32)
      language: CSharp
      name:
        CSharp: PlusMonths(Int32)
        VB: PlusMonths(Int32)
      nameWithType:
        CSharp: LocalDate.PlusMonths(Int32)
        VB: LocalDate.PlusMonths(Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDate.PlusMonths(System.Int32)
        VB: NodaTime.LocalDate.PlusMonths(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusMonths
        path: src/NodaTime/LocalDate.cs
        startLine: 490
      summary: "\nReturns a new LocalDate representing the current value with the given number of months added.\n"
      remarks: "\n<p>\nThis method does not try to maintain the year of the current value, so adding four months to a value in \nOctober will result in a value in the following February.\n</p>\n<p>\nIf the resulting date is invalid, the day of month is reduced to find a valid value.\nFor example, adding one month to January 30th 2011 will return February 28th 2011; subtracting one month from\nMarch 30th 2011 will return February 28th 2011.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate PlusMonths(int months)
          VB: Public Function PlusMonths(months As Integer) As LocalDate
        parameters:
        - id: months
          type: System.Int32
          description: The number of months to add
        return:
          type: NodaTime.LocalDate
          description: The current date plus the given number of months
      overload: NodaTime.LocalDate.PlusMonths*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.PlusDays(System.Int32)
      commentId: M:NodaTime.LocalDate.PlusDays(System.Int32)
      language: CSharp
      name:
        CSharp: PlusDays(Int32)
        VB: PlusDays(Int32)
      nameWithType:
        CSharp: LocalDate.PlusDays(Int32)
        VB: LocalDate.PlusDays(Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDate.PlusDays(System.Int32)
        VB: NodaTime.LocalDate.PlusDays(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusDays
        path: src/NodaTime/LocalDate.cs
        startLine: 506
      summary: "\nReturns a new LocalDate representing the current value with the given number of days added.\n"
      remarks: "\n<p>\nThis method does not try to maintain the month or year of the current value, so adding 3 days to a value of January 30th\nwill result in a value of February 2nd.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate PlusDays(int days)
          VB: Public Function PlusDays(days As Integer) As LocalDate
        parameters:
        - id: days
          type: System.Int32
          description: The number of days to add
        return:
          type: NodaTime.LocalDate
          description: The current value plus the given number of days.
      overload: NodaTime.LocalDate.PlusDays*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.PlusWeeks(System.Int32)
      commentId: M:NodaTime.LocalDate.PlusWeeks(System.Int32)
      language: CSharp
      name:
        CSharp: PlusWeeks(Int32)
        VB: PlusWeeks(Int32)
      nameWithType:
        CSharp: LocalDate.PlusWeeks(Int32)
        VB: LocalDate.PlusWeeks(Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDate.PlusWeeks(System.Int32)
        VB: NodaTime.LocalDate.PlusWeeks(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusWeeks
        path: src/NodaTime/LocalDate.cs
        startLine: 516
      summary: "\nReturns a new LocalDate representing the current value with the given number of weeks added.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate PlusWeeks(int weeks)
          VB: Public Function PlusWeeks(weeks As Integer) As LocalDate
        parameters:
        - id: weeks
          type: System.Int32
          description: The number of weeks to add
        return:
          type: NodaTime.LocalDate
          description: The current value plus the given number of weeks.
      overload: NodaTime.LocalDate.PlusWeeks*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDate.Next(NodaTime.IsoDayOfWeek)
      commentId: M:NodaTime.LocalDate.Next(NodaTime.IsoDayOfWeek)
      language: CSharp
      name:
        CSharp: Next(IsoDayOfWeek)
        VB: Next(IsoDayOfWeek)
      nameWithType:
        CSharp: LocalDate.Next(IsoDayOfWeek)
        VB: LocalDate.Next(IsoDayOfWeek)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Next(NodaTime.IsoDayOfWeek)
        VB: NodaTime.LocalDate.Next(NodaTime.IsoDayOfWeek)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Next
        path: src/NodaTime/LocalDate.cs
        startLine: 531
      summary: "\nReturns the next <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref> falling on the specified <xref href=\"NodaTime.LocalDate.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref>.\nThis is a strict \"next\" - if this date on already falls on the target\nday of the week, the returned value will be a week later.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate Next(IsoDayOfWeek targetDayOfWeek)
          VB: Public Function Next(targetDayOfWeek As IsoDayOfWeek) As LocalDate
        parameters:
        - id: targetDayOfWeek
          type: NodaTime.IsoDayOfWeek
          description: The ISO day of the week to return the next date of.
        return:
          type: NodaTime.LocalDate
          description: The next <xref href="NodaTime.LocalDate" data-throw-if-not-resolved="false"></xref> falling on the specified day of the week.
      overload: NodaTime.LocalDate.Next*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The underlying calendar doesn't use ISO days of the week.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: >-
          <span class="paramref">targetDayOfWeek</span> is not a valid day of the
              week (Monday to Sunday).
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDate: 
        NodaTime.LocalDate.IsoDayOfWeek: 
    - id: NodaTime.LocalDate.Previous(NodaTime.IsoDayOfWeek)
      commentId: M:NodaTime.LocalDate.Previous(NodaTime.IsoDayOfWeek)
      language: CSharp
      name:
        CSharp: Previous(IsoDayOfWeek)
        VB: Previous(IsoDayOfWeek)
      nameWithType:
        CSharp: LocalDate.Previous(IsoDayOfWeek)
        VB: LocalDate.Previous(IsoDayOfWeek)
      qualifiedName:
        CSharp: NodaTime.LocalDate.Previous(NodaTime.IsoDayOfWeek)
        VB: NodaTime.LocalDate.Previous(NodaTime.IsoDayOfWeek)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Previous
        path: src/NodaTime/LocalDate.cs
        startLine: 547
      summary: "\nReturns the previous <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref> falling on the specified <xref href=\"NodaTime.LocalDate.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref>.\nThis is a strict \"previous\" - if this date on already falls on the target\nday of the week, the returned value will be a week earlier.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate Previous(IsoDayOfWeek targetDayOfWeek)
          VB: Public Function Previous(targetDayOfWeek As IsoDayOfWeek) As LocalDate
        parameters:
        - id: targetDayOfWeek
          type: NodaTime.IsoDayOfWeek
          description: The ISO day of the week to return the previous date of.
        return:
          type: NodaTime.LocalDate
          description: The previous <xref href="NodaTime.LocalDate" data-throw-if-not-resolved="false"></xref> falling on the specified day of the week.
      overload: NodaTime.LocalDate.Previous*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The underlying calendar doesn't use ISO days of the week.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: >-
          <span class="paramref">targetDayOfWeek</span> is not a valid day of the
              week (Monday to Sunday).
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDate: 
        NodaTime.LocalDate.IsoDayOfWeek: 
    - id: NodaTime.LocalDate.ToString
      commentId: M:NodaTime.LocalDate.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: LocalDate.ToString()
        VB: LocalDate.ToString()
      qualifiedName:
        CSharp: NodaTime.LocalDate.ToString()
        VB: NodaTime.LocalDate.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/LocalDate.cs
        startLine: 561
      summary: "\nReturns a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nThe value of the current instance in the standard format pattern, using the current thread's\nculture to obtain a format provider.\n"
      overload: NodaTime.LocalDate.ToString*
      overridden: System.ValueType.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.String: 
    - id: NodaTime.LocalDate.ToString(System.String,System.IFormatProvider)
      commentId: M:NodaTime.LocalDate.ToString(System.String,System.IFormatProvider)
      language: CSharp
      name:
        CSharp: ToString(String, IFormatProvider)
        VB: ToString(String, IFormatProvider)
      nameWithType:
        CSharp: LocalDate.ToString(String, IFormatProvider)
        VB: LocalDate.ToString(String, IFormatProvider)
      qualifiedName:
        CSharp: NodaTime.LocalDate.ToString(System.String, System.IFormatProvider)
        VB: NodaTime.LocalDate.ToString(System.String, System.IFormatProvider)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/LocalDate.cs
        startLine: 579
      summary: "\nFormats the value of the current instance using the specified pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string ToString(string patternText, IFormatProvider formatProvider)
          VB: Public Function ToString(patternText As String, formatProvider As IFormatProvider) As String
        parameters:
        - id: patternText
          type: System.String
          description: >
            The <xref href="System.String" data-throw-if-not-resolved="false"></xref> specifying the pattern to use,

            or null to use the default format pattern.
        - id: formatProvider
          type: System.IFormatProvider
          description: >
            The <xref href="System.IFormatProvider" data-throw-if-not-resolved="false"></xref> to use when formatting the value,

            or null to use the current thread's culture to obtain a format provider.
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> containing the value of the current instance in the specified format.\n"
      overload: NodaTime.LocalDate.ToString*
      implements:
      - System.IFormattable.ToString(System.String,System.IFormatProvider)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.String: 
        System.IFormatProvider: 
    - isEii: true
      id: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#GetSchema
      commentId: M:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#GetSchema
      language: CSharp
      name:
        CSharp: IXmlSerializable.GetSchema()
        VB: System.Xml.Serialization.IXmlSerializable.GetSchema()
      nameWithType:
        CSharp: LocalDate.IXmlSerializable.GetSchema()
        VB: LocalDate.System.Xml.Serialization.IXmlSerializable.GetSchema()
      qualifiedName:
        CSharp: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.GetSchema()
        VB: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.GetSchema()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.GetSchema
        path: src/NodaTime/LocalDate.cs
        startLine: 587
      example: []
      syntax:
        content:
          CSharp: XmlSchema IXmlSerializable.GetSchema()
          VB: Function System.Xml.Serialization.IXmlSerializable.GetSchema As XmlSchema Implements IXmlSerializable.GetSchema
        return:
          type: System.Xml.Schema.XmlSchema
      overload: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#GetSchema*
      implements:
      - System.Xml.Serialization.IXmlSerializable.GetSchema
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      commentId: M:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      language: CSharp
      name:
        CSharp: IXmlSerializable.ReadXml(XmlReader)
        VB: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      nameWithType:
        CSharp: LocalDate.IXmlSerializable.ReadXml(XmlReader)
        VB: LocalDate.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      qualifiedName:
        CSharp: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        VB: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.ReadXml
        path: src/NodaTime/LocalDate.cs
        startLine: 593
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.ReadXml(XmlReader reader)
          VB: Sub System.Xml.Serialization.IXmlSerializable.ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
        parameters:
        - id: reader
          type: System.Xml.XmlReader
      overload: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#ReadXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      commentId: M:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      language: CSharp
      name:
        CSharp: IXmlSerializable.WriteXml(XmlWriter)
        VB: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      nameWithType:
        CSharp: LocalDate.IXmlSerializable.WriteXml(XmlWriter)
        VB: LocalDate.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      qualifiedName:
        CSharp: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        VB: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.WriteXml
        path: src/NodaTime/LocalDate.cs
        startLine: 610
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.WriteXml(XmlWriter writer)
          VB: Sub System.Xml.Serialization.IXmlSerializable.WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
        parameters:
        - id: writer
          type: System.Xml.XmlWriter
      overload: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#WriteXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.LocalDate.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:NodaTime.LocalDate.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: LocalDate.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: LocalDate.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: NodaTime.LocalDate.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: NodaTime.LocalDate.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDate.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Runtime.Serialization.ISerializable.GetObjectData
        path: src/NodaTime/LocalDate.cs
        startLine: 642
      summary: "\nImplementation of <xref href=\"System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo%2cSystem.Runtime.Serialization.StreamingContext)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
          VB: Sub System.Runtime.Serialization.ISerializable.GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: The <xref href="System.Runtime.Serialization.SerializationInfo" data-throw-if-not-resolved="false"></xref> to populate with data.
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: The destination for this serialization.
      overload: NodaTime.LocalDate.System#Runtime#Serialization#ISerializable#GetObjectData*
      implements:
      - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      modifiers:
        CSharp: []
        VB: []
      references:
        ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        : 
        System.Runtime.Serialization.SerializationInfo: 
    references:
      NodaTime.LocalDate.Equals(NodaTime.LocalDate): 
      NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate): 
      NodaTime.LocalDate.CompareTo(NodaTime.LocalDate): 
      System.IComparable`1: 
  - id: NodaTime.LocalTime
    commentId: T:NodaTime.LocalTime
    language: CSharp
    name:
      CSharp: LocalTime
      VB: LocalTime
    nameWithType:
      CSharp: LocalTime
      VB: LocalTime
    qualifiedName:
      CSharp: NodaTime.LocalTime
      VB: NodaTime.LocalTime
    type: Struct
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/LocalTime.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: LocalTime
      path: src/NodaTime/LocalTime.cs
      startLine: 24
    summary: "\nLocalTime is an immutable struct representing a time of day, with no reference\nto a particular calendar, time zone or date.\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public struct LocalTime : IEquatable<LocalTime>, IComparable<LocalTime>, IFormattable, IComparable, IXmlSerializable, ISerializable
        VB: >-
          <Serializable>

          Public Structure LocalTime

              Implements IEquatable(Of LocalTime), IComparable(Of LocalTime), IFormattable, IComparable, IXmlSerializable, ISerializable
    implements:
    - System.IEquatable{NodaTime.LocalTime}
    - System.IComparable{NodaTime.LocalTime}
    - System.IFormattable
    - System.IComparable
    - System.Xml.Serialization.IXmlSerializable
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: NodaTime.LocalTime.Midnight
      commentId: F:NodaTime.LocalTime.Midnight
      language: CSharp
      name:
        CSharp: Midnight
        VB: Midnight
      nameWithType:
        CSharp: LocalTime.Midnight
        VB: LocalTime.Midnight
      qualifiedName:
        CSharp: NodaTime.LocalTime.Midnight
        VB: NodaTime.LocalTime.Midnight
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Midnight
        path: src/NodaTime/LocalTime.cs
        startLine: 34
      summary: "\nLocal time at midnight, i.e. 0 hours, 0 minutes, 0 seconds.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly LocalTime Midnight
          VB: Public Shared ReadOnly Midnight As LocalTime
        return:
          type: NodaTime.LocalTime
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.LocalTime.Noon
      commentId: F:NodaTime.LocalTime.Noon
      language: CSharp
      name:
        CSharp: Noon
        VB: Noon
      nameWithType:
        CSharp: LocalTime.Noon
        VB: LocalTime.Noon
      qualifiedName:
        CSharp: NodaTime.LocalTime.Noon
        VB: NodaTime.LocalTime.Noon
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Noon
        path: src/NodaTime/LocalTime.cs
        startLine: 38
      summary: "\nLocal time at noon, i.e. 12 hours, 0 minutes, 0 seconds.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly LocalTime Noon
          VB: Public Shared ReadOnly Noon As LocalTime
        return:
          type: NodaTime.LocalTime
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.LocalTime.#ctor(System.Int32,System.Int32)
      commentId: M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LocalTime(Int32, Int32)
        VB: LocalTime(Int32, Int32)
      nameWithType:
        CSharp: LocalTime.LocalTime(Int32, Int32)
        VB: LocalTime.LocalTime(Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalTime.LocalTime(System.Int32, System.Int32)
        VB: NodaTime.LocalTime.LocalTime(System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalTime.cs
        startLine: 50
      summary: "\nCreates a local time at the given hour and minute, with second, millisecond-of-second\nand tick-of-millisecond values of zero.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime(int hour, int minute)
          VB: Public Sub New(hour As Integer, minute As Integer)
        parameters:
        - id: hour
          type: System.Int32
          description: The hour of day.
        - id: minute
          type: System.Int32
          description: The minute of the hour.
      overload: NodaTime.LocalTime.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LocalTime(Int32, Int32, Int32)
        VB: LocalTime(Int32, Int32, Int32)
      nameWithType:
        CSharp: LocalTime.LocalTime(Int32, Int32, Int32)
        VB: LocalTime.LocalTime(Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalTime.LocalTime(System.Int32, System.Int32, System.Int32)
        VB: NodaTime.LocalTime.LocalTime(System.Int32, System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalTime.cs
        startLine: 68
      summary: "\nCreates a local time at the given hour, minute and second,\nwith millisecond-of-second and tick-of-millisecond values of zero.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime(int hour, int minute, int second)
          VB: Public Sub New(hour As Integer, minute As Integer, second As Integer)
        parameters:
        - id: hour
          type: System.Int32
          description: The hour of day.
        - id: minute
          type: System.Int32
          description: The minute of the hour.
        - id: second
          type: System.Int32
          description: The second of the minute.
      overload: NodaTime.LocalTime.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LocalTime(Int32, Int32, Int32, Int32)
        VB: LocalTime(Int32, Int32, Int32, Int32)
      nameWithType:
        CSharp: LocalTime.LocalTime(Int32, Int32, Int32, Int32)
        VB: LocalTime.LocalTime(Int32, Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalTime.LocalTime(System.Int32, System.Int32, System.Int32, System.Int32)
        VB: NodaTime.LocalTime.LocalTime(System.Int32, System.Int32, System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalTime.cs
        startLine: 89
      summary: "\nCreates a local time at the given hour, minute, second and millisecond,\nwith a tick-of-millisecond value of zero.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime(int hour, int minute, int second, int millisecond)
          VB: Public Sub New(hour As Integer, minute As Integer, second As Integer, millisecond As Integer)
        parameters:
        - id: hour
          type: System.Int32
          description: The hour of day.
        - id: minute
          type: System.Int32
          description: The minute of the hour.
        - id: second
          type: System.Int32
          description: The second of the minute.
        - id: millisecond
          type: System.Int32
          description: The millisecond of the second.
      overload: NodaTime.LocalTime.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LocalTime(Int32, Int32, Int32, Int32, Int32)
        VB: LocalTime(Int32, Int32, Int32, Int32, Int32)
      nameWithType:
        CSharp: LocalTime.LocalTime(Int32, Int32, Int32, Int32, Int32)
        VB: LocalTime.LocalTime(Int32, Int32, Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalTime.LocalTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
        VB: NodaTime.LocalTime.LocalTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalTime.cs
        startLine: 112
      summary: "\nCreates a local time at the given hour, minute, second, millisecond and tick within millisecond.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime(int hour, int minute, int second, int millisecond, int tickWithinMillisecond)
          VB: Public Sub New(hour As Integer, minute As Integer, second As Integer, millisecond As Integer, tickWithinMillisecond As Integer)
        parameters:
        - id: hour
          type: System.Int32
          description: The hour of day.
        - id: minute
          type: System.Int32
          description: The minute of the hour.
        - id: second
          type: System.Int32
          description: The second of the minute.
        - id: millisecond
          type: System.Int32
          description: The millisecond of the second.
        - id: tickWithinMillisecond
          type: System.Int32
          description: The tick within the millisecond.
      overload: NodaTime.LocalTime.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.FromHourMinuteSecondTick(System.Int32,System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.LocalTime.FromHourMinuteSecondTick(System.Int32,System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: FromHourMinuteSecondTick(Int32, Int32, Int32, Int32)
        VB: FromHourMinuteSecondTick(Int32, Int32, Int32, Int32)
      nameWithType:
        CSharp: LocalTime.FromHourMinuteSecondTick(Int32, Int32, Int32, Int32)
        VB: LocalTime.FromHourMinuteSecondTick(Int32, Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalTime.FromHourMinuteSecondTick(System.Int32, System.Int32, System.Int32, System.Int32)
        VB: NodaTime.LocalTime.FromHourMinuteSecondTick(System.Int32, System.Int32, System.Int32, System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromHourMinuteSecondTick
        path: src/NodaTime/LocalTime.cs
        startLine: 139
      summary: "\nFactory method for creating a local time from the hour of day, minute of hour, second of minute, and tick of second.\n"
      remarks: "\nThis is not a constructor overload as it would have the same signature as the one taking millisecond of second.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTime FromHourMinuteSecondTick(int hour, int minute, int second, int tickWithinSecond)
          VB: Public Shared Function FromHourMinuteSecondTick(hour As Integer, minute As Integer, second As Integer, tickWithinSecond As Integer) As LocalTime
        parameters:
        - id: hour
          type: System.Int32
          description: The hour of day in the desired time, in the range [0, 23].
        - id: minute
          type: System.Int32
          description: The minute of hour in the desired time, in the range [0, 59].
        - id: second
          type: System.Int32
          description: The second of minute in the desired time, in the range [0, 59].
        - id: tickWithinSecond
          type: System.Int32
          description: The tick within the second in the desired time, in the range [0, 9999999].
        return:
          type: NodaTime.LocalTime
          description: The resulting time.
      overload: NodaTime.LocalTime.FromHourMinuteSecondTick*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid time.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.FromTicksSinceMidnight(System.Int64)
      commentId: M:NodaTime.LocalTime.FromTicksSinceMidnight(System.Int64)
      language: CSharp
      name:
        CSharp: FromTicksSinceMidnight(Int64)
        VB: FromTicksSinceMidnight(Int64)
      nameWithType:
        CSharp: LocalTime.FromTicksSinceMidnight(Int64)
        VB: LocalTime.FromTicksSinceMidnight(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalTime.FromTicksSinceMidnight(System.Int64)
        VB: NodaTime.LocalTime.FromTicksSinceMidnight(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromTicksSinceMidnight
        path: src/NodaTime/LocalTime.cs
        startLine: 157
      summary: "\nFactory method for creating a local time from the number of ticks which have elapsed since midnight.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTime FromTicksSinceMidnight(long ticks)
          VB: Public Shared Function FromTicksSinceMidnight(ticks As Long) As LocalTime
        parameters:
        - id: ticks
          type: System.Int64
          description: The number of ticks, in the range [0, 863,999,999,999]
        return:
          type: NodaTime.LocalTime
          description: The resulting time.
      overload: NodaTime.LocalTime.FromTicksSinceMidnight*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.FromMillisecondsSinceMidnight(System.Int32)
      commentId: M:NodaTime.LocalTime.FromMillisecondsSinceMidnight(System.Int32)
      language: CSharp
      name:
        CSharp: FromMillisecondsSinceMidnight(Int32)
        VB: FromMillisecondsSinceMidnight(Int32)
      nameWithType:
        CSharp: LocalTime.FromMillisecondsSinceMidnight(Int32)
        VB: LocalTime.FromMillisecondsSinceMidnight(Int32)
      qualifiedName:
        CSharp: NodaTime.LocalTime.FromMillisecondsSinceMidnight(System.Int32)
        VB: NodaTime.LocalTime.FromMillisecondsSinceMidnight(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromMillisecondsSinceMidnight
        path: src/NodaTime/LocalTime.cs
        startLine: 168
      summary: "\nFactory method for creating a local time from the number of milliseconds which have elapsed since midnight.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTime FromMillisecondsSinceMidnight(int milliseconds)
          VB: Public Shared Function FromMillisecondsSinceMidnight(milliseconds As Integer) As LocalTime
        parameters:
        - id: milliseconds
          type: System.Int32
          description: The number of milliseconds, in the range [0, 86,399,999]
        return:
          type: NodaTime.LocalTime
          description: The resulting time.
      overload: NodaTime.LocalTime.FromMillisecondsSinceMidnight*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.FromSecondsSinceMidnight(System.Int32)
      commentId: M:NodaTime.LocalTime.FromSecondsSinceMidnight(System.Int32)
      language: CSharp
      name:
        CSharp: FromSecondsSinceMidnight(Int32)
        VB: FromSecondsSinceMidnight(Int32)
      nameWithType:
        CSharp: LocalTime.FromSecondsSinceMidnight(Int32)
        VB: LocalTime.FromSecondsSinceMidnight(Int32)
      qualifiedName:
        CSharp: NodaTime.LocalTime.FromSecondsSinceMidnight(System.Int32)
        VB: NodaTime.LocalTime.FromSecondsSinceMidnight(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromSecondsSinceMidnight
        path: src/NodaTime/LocalTime.cs
        startLine: 179
      summary: "\nFactory method for creating a local time from the number of seconds which have elapsed since midnight.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTime FromSecondsSinceMidnight(int seconds)
          VB: Public Shared Function FromSecondsSinceMidnight(seconds As Integer) As LocalTime
        parameters:
        - id: seconds
          type: System.Int32
          description: The number of seconds, in the range [0, 86,399]
        return:
          type: NodaTime.LocalTime
          description: The resulting time.
      overload: NodaTime.LocalTime.FromSecondsSinceMidnight*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.Hour
      commentId: P:NodaTime.LocalTime.Hour
      language: CSharp
      name:
        CSharp: Hour
        VB: Hour
      nameWithType:
        CSharp: LocalTime.Hour
        VB: LocalTime.Hour
      qualifiedName:
        CSharp: NodaTime.LocalTime.Hour
        VB: NodaTime.LocalTime.Hour
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Hour
        path: src/NodaTime/LocalTime.cs
        startLine: 196
      summary: "\nGets the hour of day of this local time, in the range 0 to 23 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Hour { get; }
          VB: Public ReadOnly Property Hour As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalTime.Hour*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalTime.ClockHourOfHalfDay
      commentId: P:NodaTime.LocalTime.ClockHourOfHalfDay
      language: CSharp
      name:
        CSharp: ClockHourOfHalfDay
        VB: ClockHourOfHalfDay
      nameWithType:
        CSharp: LocalTime.ClockHourOfHalfDay
        VB: LocalTime.ClockHourOfHalfDay
      qualifiedName:
        CSharp: NodaTime.LocalTime.ClockHourOfHalfDay
        VB: NodaTime.LocalTime.ClockHourOfHalfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ClockHourOfHalfDay
        path: src/NodaTime/LocalTime.cs
        startLine: 201
      summary: "\nGets the hour of the half-day of this local time, in the range 1 to 12 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int ClockHourOfHalfDay { get; }
          VB: Public ReadOnly Property ClockHourOfHalfDay As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalTime.ClockHourOfHalfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalTime.Minute
      commentId: P:NodaTime.LocalTime.Minute
      language: CSharp
      name:
        CSharp: Minute
        VB: Minute
      nameWithType:
        CSharp: LocalTime.Minute
        VB: LocalTime.Minute
      qualifiedName:
        CSharp: NodaTime.LocalTime.Minute
        VB: NodaTime.LocalTime.Minute
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minute
        path: src/NodaTime/LocalTime.cs
        startLine: 206
      summary: "\nGets the minute of this local time, in the range 0 to 59 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Minute { get; }
          VB: Public ReadOnly Property Minute As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalTime.Minute*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalTime.Second
      commentId: P:NodaTime.LocalTime.Second
      language: CSharp
      name:
        CSharp: Second
        VB: Second
      nameWithType:
        CSharp: LocalTime.Second
        VB: LocalTime.Second
      qualifiedName:
        CSharp: NodaTime.LocalTime.Second
        VB: NodaTime.LocalTime.Second
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Second
        path: src/NodaTime/LocalTime.cs
        startLine: 211
      summary: "\nGets the second of this local time within the minute, in the range 0 to 59 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Second { get; }
          VB: Public ReadOnly Property Second As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalTime.Second*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalTime.Millisecond
      commentId: P:NodaTime.LocalTime.Millisecond
      language: CSharp
      name:
        CSharp: Millisecond
        VB: Millisecond
      nameWithType:
        CSharp: LocalTime.Millisecond
        VB: LocalTime.Millisecond
      qualifiedName:
        CSharp: NodaTime.LocalTime.Millisecond
        VB: NodaTime.LocalTime.Millisecond
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Millisecond
        path: src/NodaTime/LocalTime.cs
        startLine: 216
      summary: "\nGets the millisecond of this local time within the second, in the range 0 to 999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Millisecond { get; }
          VB: Public ReadOnly Property Millisecond As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalTime.Millisecond*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalTime.TickOfSecond
      commentId: P:NodaTime.LocalTime.TickOfSecond
      language: CSharp
      name:
        CSharp: TickOfSecond
        VB: TickOfSecond
      nameWithType:
        CSharp: LocalTime.TickOfSecond
        VB: LocalTime.TickOfSecond
      qualifiedName:
        CSharp: NodaTime.LocalTime.TickOfSecond
        VB: NodaTime.LocalTime.TickOfSecond
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TickOfSecond
        path: src/NodaTime/LocalTime.cs
        startLine: 221
      summary: "\nGets the tick of this local time within the second, in the range 0 to 9,999,999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int TickOfSecond { get; }
          VB: Public ReadOnly Property TickOfSecond As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalTime.TickOfSecond*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalTime.TickOfDay
      commentId: P:NodaTime.LocalTime.TickOfDay
      language: CSharp
      name:
        CSharp: TickOfDay
        VB: TickOfDay
      nameWithType:
        CSharp: LocalTime.TickOfDay
        VB: LocalTime.TickOfDay
      qualifiedName:
        CSharp: NodaTime.LocalTime.TickOfDay
        VB: NodaTime.LocalTime.TickOfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TickOfDay
        path: src/NodaTime/LocalTime.cs
        startLine: 226
      summary: "\nGets the tick of this local time within the day, in the range 0 to 863,999,999,999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public long TickOfDay { get; }
          VB: Public ReadOnly Property TickOfDay As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.LocalTime.TickOfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalTime.LocalDateTime
      commentId: P:NodaTime.LocalTime.LocalDateTime
      language: CSharp
      name:
        CSharp: LocalDateTime
        VB: LocalDateTime
      nameWithType:
        CSharp: LocalTime.LocalDateTime
        VB: LocalTime.LocalDateTime
      qualifiedName:
        CSharp: NodaTime.LocalTime.LocalDateTime
        VB: NodaTime.LocalTime.LocalDateTime
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: LocalDateTime
        path: src/NodaTime/LocalTime.cs
        startLine: 232
      summary: "\nReturns a <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> with this local time, on January 1st 1970 in the ISO\ncalendar.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime LocalDateTime { get; }
          VB: Public ReadOnly Property LocalDateTime As LocalDateTime
        parameters: []
        return:
          type: NodaTime.LocalDateTime
      overload: NodaTime.LocalTime.LocalDateTime*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalTime.op_Addition(NodaTime.LocalTime,NodaTime.Period)
      commentId: M:NodaTime.LocalTime.op_Addition(NodaTime.LocalTime,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Addition(LocalTime, Period)
        VB: Addition(LocalTime, Period)
      nameWithType:
        CSharp: LocalTime.Addition(LocalTime, Period)
        VB: LocalTime.Addition(LocalTime, Period)
      qualifiedName:
        CSharp: NodaTime.LocalTime.Addition(NodaTime.LocalTime, NodaTime.Period)
        VB: NodaTime.LocalTime.Addition(NodaTime.LocalTime, NodaTime.Period)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Addition
        path: src/NodaTime/LocalTime.cs
        startLine: 241
      summary: "\nCreates a new local time by adding a period to an existing time. The period must not contain\nany date-related units (days etc) with non-zero values.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTime operator +(LocalTime time, Period period)
          VB: Public Shared Operator +(time As LocalTime, period As Period) As LocalTime
        parameters:
        - id: time
          type: NodaTime.LocalTime
          description: The time to add the period to
        - id: period
          type: NodaTime.Period
          description: The period to add
        return:
          type: NodaTime.LocalTime
          description: The result of adding the period to the time, wrapping via midnight if necessary
      overload: NodaTime.LocalTime.op_Addition*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.Add(NodaTime.LocalTime,NodaTime.Period)
      commentId: M:NodaTime.LocalTime.Add(NodaTime.LocalTime,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Add(LocalTime, Period)
        VB: Add(LocalTime, Period)
      nameWithType:
        CSharp: LocalTime.Add(LocalTime, Period)
        VB: LocalTime.Add(LocalTime, Period)
      qualifiedName:
        CSharp: NodaTime.LocalTime.Add(NodaTime.LocalTime, NodaTime.Period)
        VB: NodaTime.LocalTime.Add(NodaTime.LocalTime, NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Add
        path: src/NodaTime/LocalTime.cs
        startLine: 254
      summary: "\nAdds the specified period to the time. Friendly alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTime Add(LocalTime time, Period period)
          VB: Public Shared Function Add(time As LocalTime, period As Period) As LocalTime
        parameters:
        - id: time
          type: NodaTime.LocalTime
          description: The time to add the period to
        - id: period
          type: NodaTime.Period
          description: The period to add. Must not contain any (non-zero) date units.
        return:
          type: NodaTime.LocalTime
          description: The sum of the given time and period
      overload: NodaTime.LocalTime.Add*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.Plus(NodaTime.Period)
      commentId: M:NodaTime.LocalTime.Plus(NodaTime.Period)
      language: CSharp
      name:
        CSharp: Plus(Period)
        VB: Plus(Period)
      nameWithType:
        CSharp: LocalTime.Plus(Period)
        VB: LocalTime.Plus(Period)
      qualifiedName:
        CSharp: NodaTime.LocalTime.Plus(NodaTime.Period)
        VB: NodaTime.LocalTime.Plus(NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Plus
        path: src/NodaTime/LocalTime.cs
        startLine: 264
      summary: "\nAdds the specified period to this time. Fluent alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime Plus(Period period)
          VB: Public Function Plus(period As Period) As LocalTime
        parameters:
        - id: period
          type: NodaTime.Period
          description: The period to add. Must not contain any (non-zero) date units.
        return:
          type: NodaTime.LocalTime
          description: The sum of this time and the given period
      overload: NodaTime.LocalTime.Plus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.op_Subtraction(NodaTime.LocalTime,NodaTime.Period)
      commentId: M:NodaTime.LocalTime.op_Subtraction(NodaTime.LocalTime,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Subtraction(LocalTime, Period)
        VB: Subtraction(LocalTime, Period)
      nameWithType:
        CSharp: LocalTime.Subtraction(LocalTime, Period)
        VB: LocalTime.Subtraction(LocalTime, Period)
      qualifiedName:
        CSharp: NodaTime.LocalTime.Subtraction(NodaTime.LocalTime, NodaTime.Period)
        VB: NodaTime.LocalTime.Subtraction(NodaTime.LocalTime, NodaTime.Period)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Subtraction
        path: src/NodaTime/LocalTime.cs
        startLine: 276
      summary: "\nCreates a new local time by subtracting a period from an existing time. The period must not contain\nany date-related units (days etc) with non-zero values.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTime operator -(LocalTime time, Period period)
          VB: Public Shared Operator -(time As LocalTime, period As Period) As LocalTime
        parameters:
        - id: time
          type: NodaTime.LocalTime
          description: The time to subtract the period from
        - id: period
          type: NodaTime.Period
          description: The period to subtract
        return:
          type: NodaTime.LocalTime
          description: The result of subtract the period from the time, wrapping via midnight if necessary
      overload: NodaTime.LocalTime.op_Subtraction*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.Subtract(NodaTime.LocalTime,NodaTime.Period)
      commentId: M:NodaTime.LocalTime.Subtract(NodaTime.LocalTime,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Subtract(LocalTime, Period)
        VB: Subtract(LocalTime, Period)
      nameWithType:
        CSharp: LocalTime.Subtract(LocalTime, Period)
        VB: LocalTime.Subtract(LocalTime, Period)
      qualifiedName:
        CSharp: NodaTime.LocalTime.Subtract(NodaTime.LocalTime, NodaTime.Period)
        VB: NodaTime.LocalTime.Subtract(NodaTime.LocalTime, NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Subtract
        path: src/NodaTime/LocalTime.cs
        startLine: 289
      summary: "\nSubtracts the specified period from the time. Friendly alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTime Subtract(LocalTime time, Period period)
          VB: Public Shared Function Subtract(time As LocalTime, period As Period) As LocalTime
        parameters:
        - id: time
          type: NodaTime.LocalTime
          description: The time to subtract the period from
        - id: period
          type: NodaTime.Period
          description: The period to subtract. Must not contain any (non-zero) date units.
        return:
          type: NodaTime.LocalTime
          description: The result of subtracting the given period from the time.
      overload: NodaTime.LocalTime.Subtract*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.Minus(NodaTime.Period)
      commentId: M:NodaTime.LocalTime.Minus(NodaTime.Period)
      language: CSharp
      name:
        CSharp: Minus(Period)
        VB: Minus(Period)
      nameWithType:
        CSharp: LocalTime.Minus(Period)
        VB: LocalTime.Minus(Period)
      qualifiedName:
        CSharp: NodaTime.LocalTime.Minus(NodaTime.Period)
        VB: NodaTime.LocalTime.Minus(NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minus
        path: src/NodaTime/LocalTime.cs
        startLine: 299
      summary: "\nSubtracts the specified period from this time. Fluent alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime Minus(Period period)
          VB: Public Function Minus(period As Period) As LocalTime
        parameters:
        - id: period
          type: NodaTime.Period
          description: The period to subtract. Must not contain any (non-zero) date units.
        return:
          type: NodaTime.LocalTime
          description: The result of subtracting the given period from this time.
      overload: NodaTime.LocalTime.Minus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.op_Equality(NodaTime.LocalTime,NodaTime.LocalTime)
      commentId: M:NodaTime.LocalTime.op_Equality(NodaTime.LocalTime,NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: Equality(LocalTime, LocalTime)
        VB: Equality(LocalTime, LocalTime)
      nameWithType:
        CSharp: LocalTime.Equality(LocalTime, LocalTime)
        VB: LocalTime.Equality(LocalTime, LocalTime)
      qualifiedName:
        CSharp: NodaTime.LocalTime.Equality(NodaTime.LocalTime, NodaTime.LocalTime)
        VB: NodaTime.LocalTime.Equality(NodaTime.LocalTime, NodaTime.LocalTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Equality
        path: src/NodaTime/LocalTime.cs
        startLine: 311
      summary: "\nCompares two local times for equality, by checking whether they represent\nthe exact same local time, down to the tick.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator ==(LocalTime lhs, LocalTime rhs)
          VB: Public Shared Operator =(lhs As LocalTime, rhs As LocalTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalTime
          description: The first value to compare
        - id: rhs
          type: NodaTime.LocalTime
          description: The second value to compare
        return:
          type: System.Boolean
          description: True if the two times are the same; false otherwise
      overload: NodaTime.LocalTime.op_Equality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.op_Inequality(NodaTime.LocalTime,NodaTime.LocalTime)
      commentId: M:NodaTime.LocalTime.op_Inequality(NodaTime.LocalTime,NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: Inequality(LocalTime, LocalTime)
        VB: Inequality(LocalTime, LocalTime)
      nameWithType:
        CSharp: LocalTime.Inequality(LocalTime, LocalTime)
        VB: LocalTime.Inequality(LocalTime, LocalTime)
      qualifiedName:
        CSharp: NodaTime.LocalTime.Inequality(NodaTime.LocalTime, NodaTime.LocalTime)
        VB: NodaTime.LocalTime.Inequality(NodaTime.LocalTime, NodaTime.LocalTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Inequality
        path: src/NodaTime/LocalTime.cs
        startLine: 322
      summary: "\nCompares two local times for inequality.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator !=(LocalTime lhs, LocalTime rhs)
          VB: Public Shared Operator <>(lhs As LocalTime, rhs As LocalTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalTime
          description: The first value to compare
        - id: rhs
          type: NodaTime.LocalTime
          description: The second value to compare
        return:
          type: System.Boolean
          description: False if the two times are the same; true otherwise
      overload: NodaTime.LocalTime.op_Inequality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.op_LessThan(NodaTime.LocalTime,NodaTime.LocalTime)
      commentId: M:NodaTime.LocalTime.op_LessThan(NodaTime.LocalTime,NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: LessThan(LocalTime, LocalTime)
        VB: LessThan(LocalTime, LocalTime)
      nameWithType:
        CSharp: LocalTime.LessThan(LocalTime, LocalTime)
        VB: LocalTime.LessThan(LocalTime, LocalTime)
      qualifiedName:
        CSharp: NodaTime.LocalTime.LessThan(NodaTime.LocalTime, NodaTime.LocalTime)
        VB: NodaTime.LocalTime.LessThan(NodaTime.LocalTime, NodaTime.LocalTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThan
        path: src/NodaTime/LocalTime.cs
        startLine: 334
      summary: "\nCompares two LocalTime values to see if the left one is strictly earlier than the right\none.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <(LocalTime lhs, LocalTime rhs)
          VB: Public Shared Operator <(lhs As LocalTime, rhs As LocalTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is strictly earlier than <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalTime.op_LessThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.op_LessThanOrEqual(NodaTime.LocalTime,NodaTime.LocalTime)
      commentId: M:NodaTime.LocalTime.op_LessThanOrEqual(NodaTime.LocalTime,NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: LessThanOrEqual(LocalTime, LocalTime)
        VB: LessThanOrEqual(LocalTime, LocalTime)
      nameWithType:
        CSharp: LocalTime.LessThanOrEqual(LocalTime, LocalTime)
        VB: LocalTime.LessThanOrEqual(LocalTime, LocalTime)
      qualifiedName:
        CSharp: NodaTime.LocalTime.LessThanOrEqual(NodaTime.LocalTime, NodaTime.LocalTime)
        VB: NodaTime.LocalTime.LessThanOrEqual(NodaTime.LocalTime, NodaTime.LocalTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThanOrEqual
        path: src/NodaTime/LocalTime.cs
        startLine: 346
      summary: "\nCompares two LocalTime values to see if the left one is earlier than or equal to the right\none.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <=(LocalTime lhs, LocalTime rhs)
          VB: Public Shared Operator <=(lhs As LocalTime, rhs As LocalTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is earlier than or equal to <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalTime.op_LessThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.op_GreaterThan(NodaTime.LocalTime,NodaTime.LocalTime)
      commentId: M:NodaTime.LocalTime.op_GreaterThan(NodaTime.LocalTime,NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: GreaterThan(LocalTime, LocalTime)
        VB: GreaterThan(LocalTime, LocalTime)
      nameWithType:
        CSharp: LocalTime.GreaterThan(LocalTime, LocalTime)
        VB: LocalTime.GreaterThan(LocalTime, LocalTime)
      qualifiedName:
        CSharp: NodaTime.LocalTime.GreaterThan(NodaTime.LocalTime, NodaTime.LocalTime)
        VB: NodaTime.LocalTime.GreaterThan(NodaTime.LocalTime, NodaTime.LocalTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThan
        path: src/NodaTime/LocalTime.cs
        startLine: 358
      summary: "\nCompares two LocalTime values to see if the left one is strictly later than the right\none.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator>(LocalTime lhs, LocalTime rhs)
          VB: Public Shared Operator>(lhs As LocalTime, rhs As LocalTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is strictly later than <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalTime.op_GreaterThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.op_GreaterThanOrEqual(NodaTime.LocalTime,NodaTime.LocalTime)
      commentId: M:NodaTime.LocalTime.op_GreaterThanOrEqual(NodaTime.LocalTime,NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: GreaterThanOrEqual(LocalTime, LocalTime)
        VB: GreaterThanOrEqual(LocalTime, LocalTime)
      nameWithType:
        CSharp: LocalTime.GreaterThanOrEqual(LocalTime, LocalTime)
        VB: LocalTime.GreaterThanOrEqual(LocalTime, LocalTime)
      qualifiedName:
        CSharp: NodaTime.LocalTime.GreaterThanOrEqual(NodaTime.LocalTime, NodaTime.LocalTime)
        VB: NodaTime.LocalTime.GreaterThanOrEqual(NodaTime.LocalTime, NodaTime.LocalTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThanOrEqual
        path: src/NodaTime/LocalTime.cs
        startLine: 370
      summary: "\nCompares two LocalTime values to see if the left one is later than or equal to the right\none.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator >=(LocalTime lhs, LocalTime rhs)
          VB: Public Shared Operator >=(lhs As LocalTime, rhs As LocalTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is later than or equal to <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalTime.op_GreaterThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)
      commentId: M:NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: CompareTo(LocalTime)
        VB: CompareTo(LocalTime)
      nameWithType:
        CSharp: LocalTime.CompareTo(LocalTime)
        VB: LocalTime.CompareTo(LocalTime)
      qualifiedName:
        CSharp: NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)
        VB: NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CompareTo
        path: src/NodaTime/LocalTime.cs
        startLine: 382
      summary: "\nIndicates whether this time is earlier, later or the same as another one.\n"
      example: []
      syntax:
        content:
          CSharp: public int CompareTo(LocalTime other)
          VB: Public Function CompareTo(other As LocalTime) As Integer
        parameters:
        - id: other
          type: NodaTime.LocalTime
          description: The other date/time to compare this one with
        return:
          type: System.Int32
          description: >-
            A value less than zero if this time is earlier than <span class="paramref">other</span>;

            zero if this time is the same as <span class="paramref">other</span>; a value greater than zero if this time is

            later than <span class="paramref">other</span>.
      overload: NodaTime.LocalTime.CompareTo*
      implements:
      - System.IComparable{NodaTime.LocalTime}.CompareTo(NodaTime.LocalTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - isEii: true
      id: NodaTime.LocalTime.System#IComparable#CompareTo(System.Object)
      commentId: M:NodaTime.LocalTime.System#IComparable#CompareTo(System.Object)
      language: CSharp
      name:
        CSharp: IComparable.CompareTo(Object)
        VB: System.IComparable.CompareTo(Object)
      nameWithType:
        CSharp: LocalTime.IComparable.CompareTo(Object)
        VB: LocalTime.System.IComparable.CompareTo(Object)
      qualifiedName:
        CSharp: NodaTime.LocalTime.System.IComparable.CompareTo(System.Object)
        VB: NodaTime.LocalTime.System.IComparable.CompareTo(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.IComparable.CompareTo
        path: src/NodaTime/LocalTime.cs
        startLine: 398
      summary: "\nImplementation of <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to compare two LocalTimes.\n"
      remarks: "\nThis uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.\n"
      example: []
      syntax:
        content:
          CSharp: int IComparable.CompareTo(object obj)
          VB: Function System.IComparable.CompareTo(obj As Object) As Integer Implements IComparable.CompareTo
        parameters:
        - id: obj
          type: System.Object
          description: The object to compare this value with.
        return:
          type: System.Int32
          description: >
            The result of comparing this LocalTime with another one; see <xref href="NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)" data-throw-if-not-resolved="false"></xref> for general details.

            If <span class="paramref">obj</span> is null, this method returns a value greater than 0.
      overload: NodaTime.LocalTime.System#IComparable#CompareTo*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">obj</span> is non-null but does not refer to an instance of <xref href="NodaTime.LocalTime" data-throw-if-not-resolved="false"></xref>.
      implements:
      - System.IComparable.CompareTo(System.Object)
      modifiers:
        CSharp: []
        VB: []
      references:
        System.IComparable.CompareTo(System.Object): 
        NodaTime.LocalTime: 
        NodaTime.LocalTime.CompareTo(NodaTime.LocalTime): 
    - id: NodaTime.LocalTime.GetHashCode
      commentId: M:NodaTime.LocalTime.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: LocalTime.GetHashCode()
        VB: LocalTime.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.LocalTime.GetHashCode()
        VB: NodaTime.LocalTime.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/LocalTime.cs
        startLine: 412
      summary: "\nReturns a hash code for this local time.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: A hash code for this local time.
      overload: NodaTime.LocalTime.GetHashCode*
      overridden: System.ValueType.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.LocalTime.Equals(NodaTime.LocalTime)
      commentId: M:NodaTime.LocalTime.Equals(NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: Equals(LocalTime)
        VB: Equals(LocalTime)
      nameWithType:
        CSharp: LocalTime.Equals(LocalTime)
        VB: LocalTime.Equals(LocalTime)
      qualifiedName:
        CSharp: NodaTime.LocalTime.Equals(NodaTime.LocalTime)
        VB: NodaTime.LocalTime.Equals(NodaTime.LocalTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/LocalTime.cs
        startLine: 423
      summary: "\nCompares this local time with the specified one for equality,\nby checking whether the two values represent the exact same local time, down to the tick.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(LocalTime other)
          VB: Public Function Equals(other As LocalTime) As Boolean
        parameters:
        - id: other
          type: NodaTime.LocalTime
          description: The other local time to compare this one with
        return:
          type: System.Boolean
          description: True if the specified time is equal to this one; false otherwise
      overload: NodaTime.LocalTime.Equals*
      implements:
      - System.IEquatable{NodaTime.LocalTime}.Equals(NodaTime.LocalTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.Equals(System.Object)
      commentId: M:NodaTime.LocalTime.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: LocalTime.Equals(Object)
        VB: LocalTime.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.LocalTime.Equals(System.Object)
        VB: NodaTime.LocalTime.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/LocalTime.cs
        startLine: 434
      summary: "\nCompares this local time with the specified reference. A local time is\nonly equal to another local time with the same underlying tick value.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: The object to compare this one with
        return:
          type: System.Boolean
          description: True if the specified value is a local time is equal to this one; false otherwise
      overload: NodaTime.LocalTime.Equals*
      overridden: System.ValueType.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.LocalTime.PlusHours(System.Int64)
      commentId: M:NodaTime.LocalTime.PlusHours(System.Int64)
      language: CSharp
      name:
        CSharp: PlusHours(Int64)
        VB: PlusHours(Int64)
      nameWithType:
        CSharp: LocalTime.PlusHours(Int64)
        VB: LocalTime.PlusHours(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalTime.PlusHours(System.Int64)
        VB: NodaTime.LocalTime.PlusHours(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusHours
        path: src/NodaTime/LocalTime.cs
        startLine: 451
      summary: "\nReturns a new LocalTime representing the current value with the given number of hours added.\n"
      remarks: "\nIf the value goes past the start or end of the day, it wraps - so 11pm plus two hours is 1am, for example.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime PlusHours(long hours)
          VB: Public Function PlusHours(hours As Long) As LocalTime
        parameters:
        - id: hours
          type: System.Int64
          description: The number of hours to add
        return:
          type: NodaTime.LocalTime
          description: The current value plus the given number of hours.
      overload: NodaTime.LocalTime.PlusHours*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.PlusMinutes(System.Int64)
      commentId: M:NodaTime.LocalTime.PlusMinutes(System.Int64)
      language: CSharp
      name:
        CSharp: PlusMinutes(Int64)
        VB: PlusMinutes(Int64)
      nameWithType:
        CSharp: LocalTime.PlusMinutes(Int64)
        VB: LocalTime.PlusMinutes(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalTime.PlusMinutes(System.Int64)
        VB: NodaTime.LocalTime.PlusMinutes(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusMinutes
        path: src/NodaTime/LocalTime.cs
        startLine: 464
      summary: "\nReturns a new LocalTime representing the current value with the given number of minutes added.\n"
      remarks: "\nIf the value goes past the start or end of the day, it wraps - so 11pm plus 120 minutes is 1am, for example.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime PlusMinutes(long minutes)
          VB: Public Function PlusMinutes(minutes As Long) As LocalTime
        parameters:
        - id: minutes
          type: System.Int64
          description: The number of minutes to add
        return:
          type: NodaTime.LocalTime
          description: The current value plus the given number of minutes.
      overload: NodaTime.LocalTime.PlusMinutes*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.PlusSeconds(System.Int64)
      commentId: M:NodaTime.LocalTime.PlusSeconds(System.Int64)
      language: CSharp
      name:
        CSharp: PlusSeconds(Int64)
        VB: PlusSeconds(Int64)
      nameWithType:
        CSharp: LocalTime.PlusSeconds(Int64)
        VB: LocalTime.PlusSeconds(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalTime.PlusSeconds(System.Int64)
        VB: NodaTime.LocalTime.PlusSeconds(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusSeconds
        path: src/NodaTime/LocalTime.cs
        startLine: 477
      summary: "\nReturns a new LocalTime representing the current value with the given number of seconds added.\n"
      remarks: "\nIf the value goes past the start or end of the day, it wraps - so 11:59pm plus 120 seconds is 12:01am, for example.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime PlusSeconds(long seconds)
          VB: Public Function PlusSeconds(seconds As Long) As LocalTime
        parameters:
        - id: seconds
          type: System.Int64
          description: The number of seconds to add
        return:
          type: NodaTime.LocalTime
          description: The current value plus the given number of seconds.
      overload: NodaTime.LocalTime.PlusSeconds*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.PlusMilliseconds(System.Int64)
      commentId: M:NodaTime.LocalTime.PlusMilliseconds(System.Int64)
      language: CSharp
      name:
        CSharp: PlusMilliseconds(Int64)
        VB: PlusMilliseconds(Int64)
      nameWithType:
        CSharp: LocalTime.PlusMilliseconds(Int64)
        VB: LocalTime.PlusMilliseconds(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalTime.PlusMilliseconds(System.Int64)
        VB: NodaTime.LocalTime.PlusMilliseconds(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusMilliseconds
        path: src/NodaTime/LocalTime.cs
        startLine: 487
      summary: "\nReturns a new LocalTime representing the current value with the given number of milliseconds added.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime PlusMilliseconds(long milliseconds)
          VB: Public Function PlusMilliseconds(milliseconds As Long) As LocalTime
        parameters:
        - id: milliseconds
          type: System.Int64
          description: The number of milliseconds to add
        return:
          type: NodaTime.LocalTime
          description: The current value plus the given number of milliseconds.
      overload: NodaTime.LocalTime.PlusMilliseconds*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.PlusTicks(System.Int64)
      commentId: M:NodaTime.LocalTime.PlusTicks(System.Int64)
      language: CSharp
      name:
        CSharp: PlusTicks(Int64)
        VB: PlusTicks(Int64)
      nameWithType:
        CSharp: LocalTime.PlusTicks(Int64)
        VB: LocalTime.PlusTicks(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalTime.PlusTicks(System.Int64)
        VB: NodaTime.LocalTime.PlusTicks(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusTicks
        path: src/NodaTime/LocalTime.cs
        startLine: 497
      summary: "\nReturns a new LocalTime representing the current value with the given number of ticks added.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime PlusTicks(long ticks)
          VB: Public Function PlusTicks(ticks As Long) As LocalTime
        parameters:
        - id: ticks
          type: System.Int64
          description: The number of ticks to add
        return:
          type: NodaTime.LocalTime
          description: The current value plus the given number of ticks.
      overload: NodaTime.LocalTime.PlusTicks*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalTime.ToString
      commentId: M:NodaTime.LocalTime.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: LocalTime.ToString()
        VB: LocalTime.ToString()
      qualifiedName:
        CSharp: NodaTime.LocalTime.ToString()
        VB: NodaTime.LocalTime.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/LocalTime.cs
        startLine: 510
      summary: "\nReturns a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nThe value of the current instance in the standard format pattern, using the current thread's\nculture to obtain a format provider.\n"
      overload: NodaTime.LocalTime.ToString*
      overridden: System.ValueType.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.String: 
    - id: NodaTime.LocalTime.ToString(System.String,System.IFormatProvider)
      commentId: M:NodaTime.LocalTime.ToString(System.String,System.IFormatProvider)
      language: CSharp
      name:
        CSharp: ToString(String, IFormatProvider)
        VB: ToString(String, IFormatProvider)
      nameWithType:
        CSharp: LocalTime.ToString(String, IFormatProvider)
        VB: LocalTime.ToString(String, IFormatProvider)
      qualifiedName:
        CSharp: NodaTime.LocalTime.ToString(System.String, System.IFormatProvider)
        VB: NodaTime.LocalTime.ToString(System.String, System.IFormatProvider)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/LocalTime.cs
        startLine: 528
      summary: "\nFormats the value of the current instance using the specified pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string ToString(string patternText, IFormatProvider formatProvider)
          VB: Public Function ToString(patternText As String, formatProvider As IFormatProvider) As String
        parameters:
        - id: patternText
          type: System.String
          description: >
            The <xref href="System.String" data-throw-if-not-resolved="false"></xref> specifying the pattern to use,

            or null to use the default format pattern.
        - id: formatProvider
          type: System.IFormatProvider
          description: >
            The <xref href="System.IFormatProvider" data-throw-if-not-resolved="false"></xref> to use when formatting the value,

            or null to use the current thread's culture to obtain a format provider.
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> containing the value of the current instance in the specified format.\n"
      overload: NodaTime.LocalTime.ToString*
      implements:
      - System.IFormattable.ToString(System.String,System.IFormatProvider)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.String: 
        System.IFormatProvider: 
    - isEii: true
      id: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#GetSchema
      commentId: M:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#GetSchema
      language: CSharp
      name:
        CSharp: IXmlSerializable.GetSchema()
        VB: System.Xml.Serialization.IXmlSerializable.GetSchema()
      nameWithType:
        CSharp: LocalTime.IXmlSerializable.GetSchema()
        VB: LocalTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
      qualifiedName:
        CSharp: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
        VB: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.GetSchema
        path: src/NodaTime/LocalTime.cs
        startLine: 536
      example: []
      syntax:
        content:
          CSharp: XmlSchema IXmlSerializable.GetSchema()
          VB: Function System.Xml.Serialization.IXmlSerializable.GetSchema As XmlSchema Implements IXmlSerializable.GetSchema
        return:
          type: System.Xml.Schema.XmlSchema
      overload: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
      implements:
      - System.Xml.Serialization.IXmlSerializable.GetSchema
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      commentId: M:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      language: CSharp
      name:
        CSharp: IXmlSerializable.ReadXml(XmlReader)
        VB: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      nameWithType:
        CSharp: LocalTime.IXmlSerializable.ReadXml(XmlReader)
        VB: LocalTime.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      qualifiedName:
        CSharp: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        VB: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.ReadXml
        path: src/NodaTime/LocalTime.cs
        startLine: 542
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.ReadXml(XmlReader reader)
          VB: Sub System.Xml.Serialization.IXmlSerializable.ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
        parameters:
        - id: reader
          type: System.Xml.XmlReader
      overload: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      commentId: M:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      language: CSharp
      name:
        CSharp: IXmlSerializable.WriteXml(XmlWriter)
        VB: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      nameWithType:
        CSharp: LocalTime.IXmlSerializable.WriteXml(XmlWriter)
        VB: LocalTime.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      qualifiedName:
        CSharp: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        VB: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.WriteXml
        path: src/NodaTime/LocalTime.cs
        startLine: 551
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.WriteXml(XmlWriter writer)
          VB: Sub System.Xml.Serialization.IXmlSerializable.WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
        parameters:
        - id: writer
          type: System.Xml.XmlWriter
      overload: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.LocalTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:NodaTime.LocalTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: LocalTime.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: LocalTime.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: NodaTime.LocalTime.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: NodaTime.LocalTime.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Runtime.Serialization.ISerializable.GetObjectData
        path: src/NodaTime/LocalTime.cs
        startLine: 577
      summary: "\nImplementation of <xref href=\"System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo%2cSystem.Runtime.Serialization.StreamingContext)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
          VB: Sub System.Runtime.Serialization.ISerializable.GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: The <xref href="System.Runtime.Serialization.SerializationInfo" data-throw-if-not-resolved="false"></xref> to populate with data.
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: The destination for this serialization.
      overload: NodaTime.LocalTime.System#Runtime#Serialization#ISerializable#GetObjectData*
      implements:
      - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      modifiers:
        CSharp: []
        VB: []
      references:
        ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        : 
        System.Runtime.Serialization.SerializationInfo: 
  - id: NodaTime.Offset
    commentId: T:NodaTime.Offset
    language: CSharp
    name:
      CSharp: Offset
      VB: Offset
    nameWithType:
      CSharp: Offset
      VB: Offset
    qualifiedName:
      CSharp: NodaTime.Offset
      VB: NodaTime.Offset
    type: Struct
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/Offset.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: Offset
      path: src/NodaTime/Offset.cs
      startLine: 25
    summary: "\nAn offset from UTC in milliseconds. A positive value means that the local time is\nahead of UTC (e.g. for Europe); a negative value means that the local time is behind\nUTC (e.g. for America).\n"
    remarks: "\nOffsets are always strictly less than 24 hours (as either a positive or negative offset).\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public struct Offset : IEquatable<Offset>, IComparable<Offset>, IFormattable, IComparable, IXmlSerializable, ISerializable
        VB: >-
          <Serializable>

          Public Structure Offset

              Implements IEquatable(Of Offset), IComparable(Of Offset), IFormattable, IComparable, IXmlSerializable, ISerializable
    implements:
    - System.IEquatable{NodaTime.Offset}
    - System.IComparable{NodaTime.Offset}
    - System.IFormattable
    - System.IComparable
    - System.Xml.Serialization.IXmlSerializable
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: NodaTime.Offset.Zero
      commentId: F:NodaTime.Offset.Zero
      language: CSharp
      name:
        CSharp: Zero
        VB: Zero
      nameWithType:
        CSharp: Offset.Zero
        VB: Offset.Zero
      qualifiedName:
        CSharp: NodaTime.Offset.Zero
        VB: NodaTime.Offset.Zero
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Zero
        path: src/NodaTime/Offset.cs
        startLine: 35
      summary: "\nAn offset of zero ticks - effectively the permanent offset for UTC.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Offset Zero
          VB: Public Shared ReadOnly Zero As Offset
        return:
          type: NodaTime.Offset
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Offset.MinValue
      commentId: F:NodaTime.Offset.MinValue
      language: CSharp
      name:
        CSharp: MinValue
        VB: MinValue
      nameWithType:
        CSharp: Offset.MinValue
        VB: Offset.MinValue
      qualifiedName:
        CSharp: NodaTime.Offset.MinValue
        VB: NodaTime.Offset.MinValue
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MinValue
        path: src/NodaTime/Offset.cs
        startLine: 39
      summary: "\nThe minimum permitted offset; one millisecond less than a standard day before UTC.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Offset MinValue
          VB: Public Shared ReadOnly MinValue As Offset
        return:
          type: NodaTime.Offset
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Offset.MaxValue
      commentId: F:NodaTime.Offset.MaxValue
      language: CSharp
      name:
        CSharp: MaxValue
        VB: MaxValue
      nameWithType:
        CSharp: Offset.MaxValue
        VB: Offset.MaxValue
      qualifiedName:
        CSharp: NodaTime.Offset.MaxValue
        VB: NodaTime.Offset.MaxValue
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MaxValue
        path: src/NodaTime/Offset.cs
        startLine: 43
      summary: "\nThe maximum permitted offset; one millisecond less than a standard day after UTC.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Offset MaxValue
          VB: Public Shared ReadOnly MaxValue As Offset
        return:
          type: NodaTime.Offset
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Offset.Milliseconds
      commentId: P:NodaTime.Offset.Milliseconds
      language: CSharp
      name:
        CSharp: Milliseconds
        VB: Milliseconds
      nameWithType:
        CSharp: Offset.Milliseconds
        VB: Offset.Milliseconds
      qualifiedName:
        CSharp: NodaTime.Offset.Milliseconds
        VB: NodaTime.Offset.Milliseconds
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Milliseconds
        path: src/NodaTime/Offset.cs
        startLine: 66
      summary: "\nGets the total number of milliseconds in the offset, which may be negative.\n"
      example: []
      syntax:
        content:
          CSharp: public int Milliseconds { get; }
          VB: Public ReadOnly Property Milliseconds As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.Offset.Milliseconds*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Offset.Ticks
      commentId: P:NodaTime.Offset.Ticks
      language: CSharp
      name:
        CSharp: Ticks
        VB: Ticks
      nameWithType:
        CSharp: Offset.Ticks
        VB: Offset.Ticks
      qualifiedName:
        CSharp: NodaTime.Offset.Ticks
        VB: NodaTime.Offset.Ticks
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Ticks
        path: src/NodaTime/Offset.cs
        startLine: 76
      summary: "\nReturns the number of ticks represented by this offset, which may be negative.\n"
      remarks: "\nOffsets are only accurate to millisecond precision; the number of milliseconds is simply multiplied\nby 10,000 to give the number of ticks.\n"
      example: []
      syntax:
        content:
          CSharp: public long Ticks { get; }
          VB: Public ReadOnly Property Ticks As Long
        parameters: []
        return:
          type: System.Int64
          description: The number of ticks.
      overload: NodaTime.Offset.Ticks*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Offset.Max(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.Max(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Max(Offset, Offset)
        VB: Max(Offset, Offset)
      nameWithType:
        CSharp: Offset.Max(Offset, Offset)
        VB: Offset.Max(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Max(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.Max(NodaTime.Offset, NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Max
        path: src/NodaTime/Offset.cs
        startLine: 85
      summary: "\nReturns the greater offset of the given two, i.e. the one which will give a later local\ntime when added to an instant.\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset Max(Offset x, Offset y)
          VB: Public Shared Function Max(x As Offset, y As Offset) As Offset
        parameters:
        - id: x
          type: NodaTime.Offset
          description: The first offset
        - id: y
          type: NodaTime.Offset
          description: The second offset
        return:
          type: NodaTime.Offset
          description: The greater offset of <span class="paramref">x</span> and <span class="paramref">y</span>.
      overload: NodaTime.Offset.Max*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Offset.Min(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.Min(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Min(Offset, Offset)
        VB: Min(Offset, Offset)
      nameWithType:
        CSharp: Offset.Min(Offset, Offset)
        VB: Offset.Min(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Min(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.Min(NodaTime.Offset, NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Min
        path: src/NodaTime/Offset.cs
        startLine: 97
      summary: "\nReturns the lower offset of the given two, i.e. the one which will give an earlier local\ntime when added to an instant.\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset Min(Offset x, Offset y)
          VB: Public Shared Function Min(x As Offset, y As Offset) As Offset
        parameters:
        - id: x
          type: NodaTime.Offset
          description: The first offset
        - id: y
          type: NodaTime.Offset
          description: The second offset
        return:
          type: NodaTime.Offset
          description: The lower offset of <span class="paramref">x</span> and <span class="paramref">y</span>.
      overload: NodaTime.Offset.Min*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Offset.op_UnaryNegation(NodaTime.Offset)
      commentId: M:NodaTime.Offset.op_UnaryNegation(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: UnaryNegation(Offset)
        VB: UnaryNegation(Offset)
      nameWithType:
        CSharp: Offset.UnaryNegation(Offset)
        VB: Offset.UnaryNegation(Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.UnaryNegation(NodaTime.Offset)
        VB: NodaTime.Offset.UnaryNegation(NodaTime.Offset)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_UnaryNegation
        path: src/NodaTime/Offset.cs
        startLine: 108
      summary: "\nImplements the unary operator - (negation).\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset operator -(Offset offset)
          VB: Public Shared Operator -(offset As Offset) As Offset
        parameters:
        - id: offset
          type: NodaTime.Offset
          description: The offset to negate.
        return:
          type: NodaTime.Offset
          description: A new <xref href="NodaTime.Offset" data-throw-if-not-resolved="false"></xref> instance with a negated value.
      overload: NodaTime.Offset.op_UnaryNegation*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Offset: 
    - id: NodaTime.Offset.Negate(NodaTime.Offset)
      commentId: M:NodaTime.Offset.Negate(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Negate(Offset)
        VB: Negate(Offset)
      nameWithType:
        CSharp: Offset.Negate(Offset)
        VB: Offset.Negate(Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Negate(NodaTime.Offset)
        VB: NodaTime.Offset.Negate(NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Negate
        path: src/NodaTime/Offset.cs
        startLine: 118
      summary: "\nReturns the negation of the specified offset. This is the method form of the unary minus operator.\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset Negate(Offset offset)
          VB: Public Shared Function Negate(offset As Offset) As Offset
        parameters:
        - id: offset
          type: NodaTime.Offset
          description: The offset to negate.
        return:
          type: NodaTime.Offset
          description: The negation of the specified offset.
      overload: NodaTime.Offset.Negate*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Offset.op_UnaryPlus(NodaTime.Offset)
      commentId: M:NodaTime.Offset.op_UnaryPlus(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: UnaryPlus(Offset)
        VB: UnaryPlus(Offset)
      nameWithType:
        CSharp: Offset.UnaryPlus(Offset)
        VB: Offset.UnaryPlus(Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.UnaryPlus(NodaTime.Offset)
        VB: NodaTime.Offset.UnaryPlus(NodaTime.Offset)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_UnaryPlus
        path: src/NodaTime/Offset.cs
        startLine: 130
      summary: "\nImplements the unary operator + .\n"
      remarks: >-
        There is no method form of this operator; the <xref href="NodaTime.Offset.Plus(NodaTime.Offset)" data-throw-if-not-resolved="false"></xref> method is an instance

        method for addition, and is more useful than a method form of this would be.
      example: []
      syntax:
        content:
          CSharp: public static Offset operator +(Offset offset)
          VB: Public Shared Operator +(offset As Offset) As Offset
        parameters:
        - id: offset
          type: NodaTime.Offset
          description: The operand.
        return:
          type: NodaTime.Offset
          description: The same <xref href="NodaTime.Offset" data-throw-if-not-resolved="false"></xref> instance
      overload: NodaTime.Offset.op_UnaryPlus*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Offset.Plus(NodaTime.Offset): 
        NodaTime.Offset: 
    - id: NodaTime.Offset.op_Addition(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.op_Addition(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Addition(Offset, Offset)
        VB: Addition(Offset, Offset)
      nameWithType:
        CSharp: Offset.Addition(Offset, Offset)
        VB: Offset.Addition(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Addition(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.Addition(NodaTime.Offset, NodaTime.Offset)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Addition
        path: src/NodaTime/Offset.cs
        startLine: 143
      summary: "\nImplements the operator + (addition).\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset operator +(Offset left, Offset right)
          VB: Public Shared Operator +(left As Offset, right As Offset) As Offset
        parameters:
        - id: left
          type: NodaTime.Offset
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Offset
          description: The right hand side of the operator.
        return:
          type: NodaTime.Offset
          description: A new <xref href="NodaTime.Offset" data-throw-if-not-resolved="false"></xref> representing the sum of the given values.
      overload: NodaTime.Offset.op_Addition*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Offset: 
    - id: NodaTime.Offset.Add(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.Add(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Add(Offset, Offset)
        VB: Add(Offset, Offset)
      nameWithType:
        CSharp: Offset.Add(Offset, Offset)
        VB: Offset.Add(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Add(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.Add(NodaTime.Offset, NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Add
        path: src/NodaTime/Offset.cs
        startLine: 156
      summary: "\nAdds one Offset to another. Friendly alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset Add(Offset left, Offset right)
          VB: Public Shared Function Add(left As Offset, right As Offset) As Offset
        parameters:
        - id: left
          type: NodaTime.Offset
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Offset
          description: The right hand side of the operator.
        return:
          type: NodaTime.Offset
          description: A new <xref href="NodaTime.Offset" data-throw-if-not-resolved="false"></xref> representing the sum of the given values.
      overload: NodaTime.Offset.Add*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Offset: 
    - id: NodaTime.Offset.Plus(NodaTime.Offset)
      commentId: M:NodaTime.Offset.Plus(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Plus(Offset)
        VB: Plus(Offset)
      nameWithType:
        CSharp: Offset.Plus(Offset)
        VB: Offset.Plus(Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Plus(NodaTime.Offset)
        VB: NodaTime.Offset.Plus(NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Plus
        path: src/NodaTime/Offset.cs
        startLine: 167
      summary: "\nReturns the result of adding another Offset to this one, for a fluent alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public Offset Plus(Offset other)
          VB: Public Function Plus(other As Offset) As Offset
        parameters:
        - id: other
          type: NodaTime.Offset
          description: The offset to add
        return:
          type: NodaTime.Offset
          description: The result of adding the other offset to this one.
      overload: NodaTime.Offset.Plus*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Offset.op_Subtraction(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.op_Subtraction(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Subtraction(Offset, Offset)
        VB: Subtraction(Offset, Offset)
      nameWithType:
        CSharp: Offset.Subtraction(Offset, Offset)
        VB: Offset.Subtraction(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Subtraction(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.Subtraction(NodaTime.Offset, NodaTime.Offset)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Subtraction
        path: src/NodaTime/Offset.cs
        startLine: 180
      summary: "\nImplements the operator - (subtraction).\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset operator -(Offset minuend, Offset subtrahend)
          VB: Public Shared Operator -(minuend As Offset, subtrahend As Offset) As Offset
        parameters:
        - id: minuend
          type: NodaTime.Offset
          description: The left hand side of the operator.
        - id: subtrahend
          type: NodaTime.Offset
          description: The right hand side of the operator.
        return:
          type: NodaTime.Offset
          description: A new <xref href="NodaTime.Offset" data-throw-if-not-resolved="false"></xref> representing the difference of the given values.
      overload: NodaTime.Offset.op_Subtraction*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Offset: 
    - id: NodaTime.Offset.Subtract(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.Subtract(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Subtract(Offset, Offset)
        VB: Subtract(Offset, Offset)
      nameWithType:
        CSharp: Offset.Subtract(Offset, Offset)
        VB: Offset.Subtract(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Subtract(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.Subtract(NodaTime.Offset, NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Subtract
        path: src/NodaTime/Offset.cs
        startLine: 193
      summary: "\nSubtracts one Offset from another. Friendly alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset Subtract(Offset minuend, Offset subtrahend)
          VB: Public Shared Function Subtract(minuend As Offset, subtrahend As Offset) As Offset
        parameters:
        - id: minuend
          type: NodaTime.Offset
          description: The left hand side of the operator.
        - id: subtrahend
          type: NodaTime.Offset
          description: The right hand side of the operator.
        return:
          type: NodaTime.Offset
          description: A new <xref href="NodaTime.Offset" data-throw-if-not-resolved="false"></xref> representing the difference of the given values.
      overload: NodaTime.Offset.Subtract*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Offset: 
    - id: NodaTime.Offset.Minus(NodaTime.Offset)
      commentId: M:NodaTime.Offset.Minus(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Minus(Offset)
        VB: Minus(Offset)
      nameWithType:
        CSharp: Offset.Minus(Offset)
        VB: Offset.Minus(Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Minus(NodaTime.Offset)
        VB: NodaTime.Offset.Minus(NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minus
        path: src/NodaTime/Offset.cs
        startLine: 204
      summary: "\nReturns the result of subtracting another Offset from this one, for a fluent alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public Offset Minus(Offset other)
          VB: Public Function Minus(other As Offset) As Offset
        parameters:
        - id: other
          type: NodaTime.Offset
          description: The offset to subtract
        return:
          type: NodaTime.Offset
          description: The result of subtracting the other offset from this one.
      overload: NodaTime.Offset.Minus*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Offset.op_Equality(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.op_Equality(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Equality(Offset, Offset)
        VB: Equality(Offset, Offset)
      nameWithType:
        CSharp: Offset.Equality(Offset, Offset)
        VB: Offset.Equality(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Equality(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.Equality(NodaTime.Offset, NodaTime.Offset)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Equality
        path: src/NodaTime/Offset.cs
        startLine: 215
      summary: "\nImplements the operator == (equality).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator ==(Offset left, Offset right)
          VB: Public Shared Operator =(left As Offset, right As Offset) As Boolean
        parameters:
        - id: left
          type: NodaTime.Offset
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Offset
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if values are equal to each other, otherwise <code>false</code>.
      overload: NodaTime.Offset.op_Equality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Offset.op_Inequality(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.op_Inequality(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Inequality(Offset, Offset)
        VB: Inequality(Offset, Offset)
      nameWithType:
        CSharp: Offset.Inequality(Offset, Offset)
        VB: Offset.Inequality(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Inequality(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.Inequality(NodaTime.Offset, NodaTime.Offset)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Inequality
        path: src/NodaTime/Offset.cs
        startLine: 226
      summary: "\nImplements the operator != (inequality).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator !=(Offset left, Offset right)
          VB: Public Shared Operator <>(left As Offset, right As Offset) As Boolean
        parameters:
        - id: left
          type: NodaTime.Offset
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Offset
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if values are not equal to each other, otherwise <code>false</code>.
      overload: NodaTime.Offset.op_Inequality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Offset.op_LessThan(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.op_LessThan(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: LessThan(Offset, Offset)
        VB: LessThan(Offset, Offset)
      nameWithType:
        CSharp: Offset.LessThan(Offset, Offset)
        VB: Offset.LessThan(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.LessThan(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.LessThan(NodaTime.Offset, NodaTime.Offset)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThan
        path: src/NodaTime/Offset.cs
        startLine: 237
      summary: "\nImplements the operator &lt; (less than).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <(Offset left, Offset right)
          VB: Public Shared Operator <(left As Offset, right As Offset) As Boolean
        parameters:
        - id: left
          type: NodaTime.Offset
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Offset
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is less than the right value, otherwise <code>false</code>.
      overload: NodaTime.Offset.op_LessThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Offset.op_LessThanOrEqual(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.op_LessThanOrEqual(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: LessThanOrEqual(Offset, Offset)
        VB: LessThanOrEqual(Offset, Offset)
      nameWithType:
        CSharp: Offset.LessThanOrEqual(Offset, Offset)
        VB: Offset.LessThanOrEqual(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.LessThanOrEqual(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.LessThanOrEqual(NodaTime.Offset, NodaTime.Offset)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThanOrEqual
        path: src/NodaTime/Offset.cs
        startLine: 248
      summary: "\nImplements the operator &lt;= (less than or equal).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <=(Offset left, Offset right)
          VB: Public Shared Operator <=(left As Offset, right As Offset) As Boolean
        parameters:
        - id: left
          type: NodaTime.Offset
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Offset
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is less than or equal to the right value, otherwise <code>false</code>.
      overload: NodaTime.Offset.op_LessThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Offset.op_GreaterThan(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.op_GreaterThan(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: GreaterThan(Offset, Offset)
        VB: GreaterThan(Offset, Offset)
      nameWithType:
        CSharp: Offset.GreaterThan(Offset, Offset)
        VB: Offset.GreaterThan(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.GreaterThan(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.GreaterThan(NodaTime.Offset, NodaTime.Offset)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThan
        path: src/NodaTime/Offset.cs
        startLine: 259
      summary: "\nImplements the operator &gt; (greater than).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator>(Offset left, Offset right)
          VB: Public Shared Operator>(left As Offset, right As Offset) As Boolean
        parameters:
        - id: left
          type: NodaTime.Offset
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Offset
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is greater than the right value, otherwise <code>false</code>.
      overload: NodaTime.Offset.op_GreaterThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Offset.op_GreaterThanOrEqual(NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.Offset.op_GreaterThanOrEqual(NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: GreaterThanOrEqual(Offset, Offset)
        VB: GreaterThanOrEqual(Offset, Offset)
      nameWithType:
        CSharp: Offset.GreaterThanOrEqual(Offset, Offset)
        VB: Offset.GreaterThanOrEqual(Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.GreaterThanOrEqual(NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.Offset.GreaterThanOrEqual(NodaTime.Offset, NodaTime.Offset)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThanOrEqual
        path: src/NodaTime/Offset.cs
        startLine: 270
      summary: "\nImplements the operator &gt;= (greater than or equal).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator >=(Offset left, Offset right)
          VB: Public Shared Operator >=(left As Offset, right As Offset) As Boolean
        parameters:
        - id: left
          type: NodaTime.Offset
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Offset
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is greater than or equal to the right value, otherwise <code>false</code>.
      overload: NodaTime.Offset.op_GreaterThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Offset.CompareTo(NodaTime.Offset)
      commentId: M:NodaTime.Offset.CompareTo(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: CompareTo(Offset)
        VB: CompareTo(Offset)
      nameWithType:
        CSharp: Offset.CompareTo(Offset)
        VB: Offset.CompareTo(Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.CompareTo(NodaTime.Offset)
        VB: NodaTime.Offset.CompareTo(NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CompareTo
        path: src/NodaTime/Offset.cs
        startLine: 303
      summary: "\nCompares the current object with another object of the same type.\n"
      example: []
      syntax:
        content:
          CSharp: public int CompareTo(Offset other)
          VB: Public Function CompareTo(other As Offset) As Integer
        parameters:
        - id: other
          type: NodaTime.Offset
          description: An object to compare with this object.
        return:
          type: System.Int32
          description: "\nA 32-bit signed integer that indicates the relative order of the objects being compared.\nThe return value has the following meanings:\n<table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>&lt; 0</td><td>This object is less than the <span class=\"paramref\">other</span> parameter.</td></tr><tr><td>0</td><td>This object is equal to <span class=\"paramref\">other</span>.</td></tr><tr><td>&gt; 0</td><td>This object is greater than <span class=\"paramref\">other</span>.</td></tr></tbody></table>\n"
      overload: NodaTime.Offset.CompareTo*
      implements:
      - System.IComparable{NodaTime.Offset}.CompareTo(NodaTime.Offset)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - isEii: true
      id: NodaTime.Offset.System#IComparable#CompareTo(System.Object)
      commentId: M:NodaTime.Offset.System#IComparable#CompareTo(System.Object)
      language: CSharp
      name:
        CSharp: IComparable.CompareTo(Object)
        VB: System.IComparable.CompareTo(Object)
      nameWithType:
        CSharp: Offset.IComparable.CompareTo(Object)
        VB: Offset.System.IComparable.CompareTo(Object)
      qualifiedName:
        CSharp: NodaTime.Offset.System.IComparable.CompareTo(System.Object)
        VB: NodaTime.Offset.System.IComparable.CompareTo(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.IComparable.CompareTo
        path: src/NodaTime/Offset.cs
        startLine: 319
      summary: "\nImplementation of <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to compare two offsets.\n"
      remarks: "\nThis uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.\n"
      example: []
      syntax:
        content:
          CSharp: int IComparable.CompareTo(object obj)
          VB: Function System.IComparable.CompareTo(obj As Object) As Integer Implements IComparable.CompareTo
        parameters:
        - id: obj
          type: System.Object
          description: The object to compare this value with.
        return:
          type: System.Int32
          description: >
            The result of comparing this instant with another one; see <xref href="NodaTime.Offset.CompareTo(NodaTime.Offset)" data-throw-if-not-resolved="false"></xref> for general details.

            If <span class="paramref">obj</span> is null, this method returns a value greater than 0.
      overload: NodaTime.Offset.System#IComparable#CompareTo*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">obj</span> is non-null but does not refer to an instance of <xref href="NodaTime.Offset" data-throw-if-not-resolved="false"></xref>.
      implements:
      - System.IComparable.CompareTo(System.Object)
      modifiers:
        CSharp: []
        VB: []
      references:
        System.IComparable.CompareTo(System.Object): 
        NodaTime.Offset: 
        NodaTime.Offset.CompareTo(NodaTime.Offset): 
    - id: NodaTime.Offset.Equals(NodaTime.Offset)
      commentId: M:NodaTime.Offset.Equals(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Equals(Offset)
        VB: Equals(Offset)
      nameWithType:
        CSharp: Offset.Equals(Offset)
        VB: Offset.Equals(Offset)
      qualifiedName:
        CSharp: NodaTime.Offset.Equals(NodaTime.Offset)
        VB: NodaTime.Offset.Equals(NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/Offset.cs
        startLine: 339
      summary: "\nIndicates whether the current object is equal to another object of the same type.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(Offset other)
          VB: Public Function Equals(other As Offset) As Boolean
        parameters:
        - id: other
          type: NodaTime.Offset
          description: An object to compare with this object.
        return:
          type: System.Boolean
          description: "\ntrue if the current object is equal to the <span class=\"paramref\">other</span> parameter;\notherwise, false.\n"
      overload: NodaTime.Offset.Equals*
      implements:
      - System.IEquatable{NodaTime.Offset}.Equals(NodaTime.Offset)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Offset.Equals(System.Object)
      commentId: M:NodaTime.Offset.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: Offset.Equals(Object)
        VB: Offset.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.Offset.Equals(System.Object)
        VB: NodaTime.Offset.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/Offset.cs
        startLine: 354
      summary: "\nDetermines whether the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: The <xref href="System.Object" data-throw-if-not-resolved="false"></xref> to compare with this instance.
        return:
          type: System.Boolean
          description: "\n<code>true</code> if the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance;\notherwise, <code>false</code>.\n"
      overload: NodaTime.Offset.Equals*
      overridden: System.ValueType.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.Object: 
    - id: NodaTime.Offset.GetHashCode
      commentId: M:NodaTime.Offset.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: Offset.GetHashCode()
        VB: Offset.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.Offset.GetHashCode()
        VB: NodaTime.Offset.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/Offset.cs
        startLine: 370
      summary: "\nReturns a hash code for this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: "\nA hash code for this instance, suitable for use in hashing algorithms and data\nstructures like a hash table. \n"
      overload: NodaTime.Offset.GetHashCode*
      overridden: System.ValueType.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.Offset.ToString
      commentId: M:NodaTime.Offset.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: Offset.ToString()
        VB: Offset.ToString()
      qualifiedName:
        CSharp: NodaTime.Offset.ToString()
        VB: NodaTime.Offset.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/Offset.cs
        startLine: 383
      summary: "\nReturns a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      overload: NodaTime.Offset.ToString*
      overridden: System.ValueType.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.String: 
    - id: NodaTime.Offset.ToString(System.String,System.IFormatProvider)
      commentId: M:NodaTime.Offset.ToString(System.String,System.IFormatProvider)
      language: CSharp
      name:
        CSharp: ToString(String, IFormatProvider)
        VB: ToString(String, IFormatProvider)
      nameWithType:
        CSharp: Offset.ToString(String, IFormatProvider)
        VB: Offset.ToString(String, IFormatProvider)
      qualifiedName:
        CSharp: NodaTime.Offset.ToString(System.String, System.IFormatProvider)
        VB: NodaTime.Offset.ToString(System.String, System.IFormatProvider)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/Offset.cs
        startLine: 403
      summary: "\nFormats the value of the current instance using the specified format.\n"
      example: []
      syntax:
        content:
          CSharp: public string ToString(string patternText, IFormatProvider formatProvider)
          VB: Public Function ToString(patternText As String, formatProvider As IFormatProvider) As String
        parameters:
        - id: patternText
          type: System.String
          description: "The <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> specifying the pattern to use.\n  -or- \n  null to use the default pattern defined for the type of the <xref href=\"System.IFormattable\" data-throw-if-not-resolved=\"false\"></xref> implementation. \n"
        - id: formatProvider
          type: System.IFormatProvider
          description: "The <xref href=\"System.IFormatProvider\" data-throw-if-not-resolved=\"false\"></xref> to use to format the value.\n  -or- \n  null to obtain the numeric format information from the current locale setting of the operating system. \n"
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> containing the value of the current instance in the specified format.\n"
      overload: NodaTime.Offset.ToString*
      implements:
      - System.IFormattable.ToString(System.String,System.IFormatProvider)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.String: 
        System.IFormattable: 
        System.IFormatProvider: 
    - id: NodaTime.Offset.FromMilliseconds(System.Int32)
      commentId: M:NodaTime.Offset.FromMilliseconds(System.Int32)
      language: CSharp
      name:
        CSharp: FromMilliseconds(Int32)
        VB: FromMilliseconds(Int32)
      nameWithType:
        CSharp: Offset.FromMilliseconds(Int32)
        VB: Offset.FromMilliseconds(Int32)
      qualifiedName:
        CSharp: NodaTime.Offset.FromMilliseconds(System.Int32)
        VB: NodaTime.Offset.FromMilliseconds(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromMilliseconds
        path: src/NodaTime/Offset.cs
        startLine: 416
      summary: "\nReturns the offset for the given milliseconds value, which may be negative.\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset FromMilliseconds(int milliseconds)
          VB: Public Shared Function FromMilliseconds(milliseconds As Integer) As Offset
        parameters:
        - id: milliseconds
          type: System.Int32
          description: The int milliseconds value.
        return:
          type: NodaTime.Offset
          description: The <xref href="NodaTime.Offset" data-throw-if-not-resolved="false"></xref> for the given milliseconds value
      overload: NodaTime.Offset.FromMilliseconds*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Offset: 
    - id: NodaTime.Offset.FromTicks(System.Int64)
      commentId: M:NodaTime.Offset.FromTicks(System.Int64)
      language: CSharp
      name:
        CSharp: FromTicks(Int64)
        VB: FromTicks(Int64)
      nameWithType:
        CSharp: Offset.FromTicks(Int64)
        VB: Offset.FromTicks(Int64)
      qualifiedName:
        CSharp: NodaTime.Offset.FromTicks(System.Int64)
        VB: NodaTime.Offset.FromTicks(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromTicks
        path: src/NodaTime/Offset.cs
        startLine: 431
      summary: "\nCreates a new offset from the given number of ticks, which may be negative.\n"
      remarks: "\nOffsets are only accurate to millisecond precision; the given number of ticks is simply divided\nby 10,000 to give the number of milliseconds - any remainder is truncated.\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset FromTicks(long ticks)
          VB: Public Shared Function FromTicks(ticks As Long) As Offset
        parameters:
        - id: ticks
          type: System.Int64
          description: The number of ticks specifying the length of the new offset.
        return:
          type: NodaTime.Offset
          description: An offset representing the given number of ticks, to the (truncated) millisecond.
      overload: NodaTime.Offset.FromTicks*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Offset.FromHours(System.Int32)
      commentId: M:NodaTime.Offset.FromHours(System.Int32)
      language: CSharp
      name:
        CSharp: FromHours(Int32)
        VB: FromHours(Int32)
      nameWithType:
        CSharp: Offset.FromHours(Int32)
        VB: Offset.FromHours(Int32)
      qualifiedName:
        CSharp: NodaTime.Offset.FromHours(System.Int32)
        VB: NodaTime.Offset.FromHours(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromHours
        path: src/NodaTime/Offset.cs
        startLine: 444
      summary: "\nCreates an offset with the specified number of hours, which may be negative.\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset FromHours(int hours)
          VB: Public Shared Function FromHours(hours As Integer) As Offset
        parameters:
        - id: hours
          type: System.Int32
          description: The number of hours to represent in the new offset.
        return:
          type: NodaTime.Offset
          description: "\nA new <xref href=\"NodaTime.Offset\" data-throw-if-not-resolved=\"false\"></xref> representing the given value.\n"
      overload: NodaTime.Offset.FromHours*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Offset: 
    - id: NodaTime.Offset.FromHoursAndMinutes(System.Int32,System.Int32)
      commentId: M:NodaTime.Offset.FromHoursAndMinutes(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: FromHoursAndMinutes(Int32, Int32)
        VB: FromHoursAndMinutes(Int32, Int32)
      nameWithType:
        CSharp: Offset.FromHoursAndMinutes(Int32, Int32)
        VB: Offset.FromHoursAndMinutes(Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.Offset.FromHoursAndMinutes(System.Int32, System.Int32)
        VB: NodaTime.Offset.FromHoursAndMinutes(System.Int32, System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromHoursAndMinutes
        path: src/NodaTime/Offset.cs
        startLine: 464
      summary: "\nCreates an offset with the specified number of hours and minutes.\n"
      remarks: "\nThe result simply takes the hours and minutes and converts each component into milliseconds\nseparately. As a result, a negative offset should usually be obtained by making both arguments\nnegative. For example, to obtain \"three hours and ten minutes behind UTC\" you might call\n<code>Offset.FromHoursAndMinutes(-3, -10)</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Offset FromHoursAndMinutes(int hours, int minutes)
          VB: Public Shared Function FromHoursAndMinutes(hours As Integer, minutes As Integer) As Offset
        parameters:
        - id: hours
          type: System.Int32
          description: The number of hours to represent in the new offset.
        - id: minutes
          type: System.Int32
          description: The number of minutes to represent in the new offset.
        return:
          type: NodaTime.Offset
          description: "\nA new <xref href=\"NodaTime.Offset\" data-throw-if-not-resolved=\"false\"></xref> representing the given value.\n"
      overload: NodaTime.Offset.FromHoursAndMinutes*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The result of the operation is outside the range of Offset.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Offset: 
    - id: NodaTime.Offset.ToTimeSpan
      commentId: M:NodaTime.Offset.ToTimeSpan
      language: CSharp
      name:
        CSharp: ToTimeSpan()
        VB: ToTimeSpan()
      nameWithType:
        CSharp: Offset.ToTimeSpan()
        VB: Offset.ToTimeSpan()
      qualifiedName:
        CSharp: NodaTime.Offset.ToTimeSpan()
        VB: NodaTime.Offset.ToTimeSpan()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToTimeSpan
        path: src/NodaTime/Offset.cs
        startLine: 475
      summary: "\nConverts this offset to a .NET standard <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> value.\n"
      example: []
      syntax:
        content:
          CSharp: public TimeSpan ToTimeSpan()
          VB: Public Function ToTimeSpan As TimeSpan
        return:
          type: System.TimeSpan
          description: An equivalent <xref href="System.TimeSpan" data-throw-if-not-resolved="false"></xref> to this value.
      overload: NodaTime.Offset.ToTimeSpan*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.TimeSpan: 
    - isEii: true
      id: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#GetSchema
      commentId: M:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#GetSchema
      language: CSharp
      name:
        CSharp: IXmlSerializable.GetSchema()
        VB: System.Xml.Serialization.IXmlSerializable.GetSchema()
      nameWithType:
        CSharp: Offset.IXmlSerializable.GetSchema()
        VB: Offset.System.Xml.Serialization.IXmlSerializable.GetSchema()
      qualifiedName:
        CSharp: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.GetSchema()
        VB: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.GetSchema()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.GetSchema
        path: src/NodaTime/Offset.cs
        startLine: 497
      example: []
      syntax:
        content:
          CSharp: XmlSchema IXmlSerializable.GetSchema()
          VB: Function System.Xml.Serialization.IXmlSerializable.GetSchema As XmlSchema Implements IXmlSerializable.GetSchema
        return:
          type: System.Xml.Schema.XmlSchema
      overload: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#GetSchema*
      implements:
      - System.Xml.Serialization.IXmlSerializable.GetSchema
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      commentId: M:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      language: CSharp
      name:
        CSharp: IXmlSerializable.ReadXml(XmlReader)
        VB: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      nameWithType:
        CSharp: Offset.IXmlSerializable.ReadXml(XmlReader)
        VB: Offset.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      qualifiedName:
        CSharp: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        VB: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.ReadXml
        path: src/NodaTime/Offset.cs
        startLine: 503
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.ReadXml(XmlReader reader)
          VB: Sub System.Xml.Serialization.IXmlSerializable.ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
        parameters:
        - id: reader
          type: System.Xml.XmlReader
      overload: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#ReadXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      commentId: M:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      language: CSharp
      name:
        CSharp: IXmlSerializable.WriteXml(XmlWriter)
        VB: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      nameWithType:
        CSharp: Offset.IXmlSerializable.WriteXml(XmlWriter)
        VB: Offset.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      qualifiedName:
        CSharp: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        VB: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.WriteXml
        path: src/NodaTime/Offset.cs
        startLine: 512
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.WriteXml(XmlWriter writer)
          VB: Sub System.Xml.Serialization.IXmlSerializable.WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
        parameters:
        - id: writer
          type: System.Xml.XmlWriter
      overload: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#WriteXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Offset.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:NodaTime.Offset.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: Offset.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: Offset.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: NodaTime.Offset.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: NodaTime.Offset.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Offset.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Runtime.Serialization.ISerializable.GetObjectData
        path: src/NodaTime/Offset.cs
        startLine: 538
      summary: "\nImplementation of <xref href=\"System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo%2cSystem.Runtime.Serialization.StreamingContext)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
          VB: Sub System.Runtime.Serialization.ISerializable.GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: The <xref href="System.Runtime.Serialization.SerializationInfo" data-throw-if-not-resolved="false"></xref> to populate with data.
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: The destination for this serialization.
      overload: NodaTime.Offset.System#Runtime#Serialization#ISerializable#GetObjectData*
      implements:
      - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      modifiers:
        CSharp: []
        VB: []
      references:
        ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        : 
        System.Runtime.Serialization.SerializationInfo: 
  - id: NodaTime.Period
    commentId: T:NodaTime.Period
    language: CSharp
    name:
      CSharp: Period
      VB: Period
    nameWithType:
      CSharp: Period
      VB: Period
    qualifiedName:
      CSharp: NodaTime.Period
      VB: NodaTime.Period
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/Period.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: Period
      path: src/NodaTime/Period.cs
      startLine: 42
    summary: "\nRepresents a period of time expressed in human chronological terms: hours, days,\nweeks, months and so on.\n"
    remarks: "\n<p>\nA <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref> contains a set of properties such as <xref href=\"NodaTime.Period.Years\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"NodaTime.Period.Months\" data-throw-if-not-resolved=\"false\"></xref>, and so on\nthat return the number of each unit contained within this period. Note that these properties are not normalized in\nany way by default, and so a <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref> may contain values such as \"2 hours and 90 minutes\". The\n<xref href=\"NodaTime.Period.Normalize\" data-throw-if-not-resolved=\"false\"></xref> method will convert equivalent periods into a standard representation.\n</p>\n<p>\nPeriods can contain negative units as well as positive units (\"+2 hours, -43 minutes, +10 seconds\"), but do not\ndifferentiate between properties that are zero and those that are absent (i.e. a period created as \"10 years\"\nand one created as \"10 years, zero months\" are equal periods; the <xref href=\"NodaTime.Period.Months\" data-throw-if-not-resolved=\"false\"></xref> property returns zero in\nboth cases).\n</p>\n<p>\n<xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref> equality is implemented by comparing each property's values individually.\n</p>\n<p>\nPeriods operate on calendar-related types such as\n<xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> whereas <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> operates on instants\non the time line. (Note that although <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> includes both concepts, it only supports\nduration-based arithmetic.)\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public sealed class Period : IEquatable<Period>, ISerializable
        VB: >-
          <Serializable>

          Public NotInheritable Class Period

              Implements IEquatable(Of Period), ISerializable
    inheritance:
    - System.Object
    implements:
    - System.IEquatable{NodaTime.Period}
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    - System.Object.MemberwiseClone
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Period.Zero
      commentId: F:NodaTime.Period.Zero
      language: CSharp
      name:
        CSharp: Zero
        VB: Zero
      nameWithType:
        CSharp: Period.Zero
        VB: Period.Zero
      qualifiedName:
        CSharp: NodaTime.Period.Zero
        VB: NodaTime.Period.Zero
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Zero
        path: src/NodaTime/Period.cs
        startLine: 71
      summary: "\nA period containing only zero-valued properties.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Period Zero
          VB: Public Shared ReadOnly Zero As Period
        return:
          type: NodaTime.Period
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Period.NormalizingEqualityComparer
      commentId: P:NodaTime.Period.NormalizingEqualityComparer
      language: CSharp
      name:
        CSharp: NormalizingEqualityComparer
        VB: NormalizingEqualityComparer
      nameWithType:
        CSharp: Period.NormalizingEqualityComparer
        VB: Period.NormalizingEqualityComparer
      qualifiedName:
        CSharp: NodaTime.Period.NormalizingEqualityComparer
        VB: NodaTime.Period.NormalizingEqualityComparer
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: NormalizingEqualityComparer
        path: src/NodaTime/Period.cs
        startLine: 78
      summary: "\nReturns an equality comparer which compares periods by first normalizing them - so 24 hours is deemed equal to 1 day, and so on.\nNote that as per the <xref href=\"NodaTime.Period.Normalize\" data-throw-if-not-resolved=\"false\"></xref> method, years and months are unchanged by normalization - so 12 months does not\nequal 1 year.\n"
      example: []
      syntax:
        content:
          CSharp: public static IEqualityComparer<Period> NormalizingEqualityComparer { get; }
          VB: Public Shared ReadOnly Property NormalizingEqualityComparer As IEqualityComparer(Of Period)
        parameters: []
        return:
          type: System.Collections.Generic.IEqualityComparer{NodaTime.Period}
      overload: NodaTime.Period.NormalizingEqualityComparer*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.Period.Normalize: 
    - id: NodaTime.Period.FromYears(System.Int64)
      commentId: M:NodaTime.Period.FromYears(System.Int64)
      language: CSharp
      name:
        CSharp: FromYears(Int64)
        VB: FromYears(Int64)
      nameWithType:
        CSharp: Period.FromYears(Int64)
        VB: Period.FromYears(Int64)
      qualifiedName:
        CSharp: NodaTime.Period.FromYears(System.Int64)
        VB: NodaTime.Period.FromYears(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromYears
        path: src/NodaTime/Period.cs
        startLine: 150
      summary: "\nCreates a period representing the specified number of years.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period FromYears(long years)
          VB: Public Shared Function FromYears(years As Long) As Period
        parameters:
        - id: years
          type: System.Int64
          description: The number of years in the new period
        return:
          type: NodaTime.Period
          description: A period consisting of the given number of years.
      overload: NodaTime.Period.FromYears*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.FromWeeks(System.Int64)
      commentId: M:NodaTime.Period.FromWeeks(System.Int64)
      language: CSharp
      name:
        CSharp: FromWeeks(Int64)
        VB: FromWeeks(Int64)
      nameWithType:
        CSharp: Period.FromWeeks(Int64)
        VB: Period.FromWeeks(Int64)
      qualifiedName:
        CSharp: NodaTime.Period.FromWeeks(System.Int64)
        VB: NodaTime.Period.FromWeeks(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromWeeks
        path: src/NodaTime/Period.cs
        startLine: 160
      summary: "\nCreates a period representing the specified number of weeks.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period FromWeeks(long weeks)
          VB: Public Shared Function FromWeeks(weeks As Long) As Period
        parameters:
        - id: weeks
          type: System.Int64
          description: The number of weeks in the new period
        return:
          type: NodaTime.Period
          description: A period consisting of the given number of weeks.
      overload: NodaTime.Period.FromWeeks*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.FromMonths(System.Int64)
      commentId: M:NodaTime.Period.FromMonths(System.Int64)
      language: CSharp
      name:
        CSharp: FromMonths(Int64)
        VB: FromMonths(Int64)
      nameWithType:
        CSharp: Period.FromMonths(Int64)
        VB: Period.FromMonths(Int64)
      qualifiedName:
        CSharp: NodaTime.Period.FromMonths(System.Int64)
        VB: NodaTime.Period.FromMonths(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromMonths
        path: src/NodaTime/Period.cs
        startLine: 170
      summary: "\nCreates a period representing the specified number of months.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period FromMonths(long months)
          VB: Public Shared Function FromMonths(months As Long) As Period
        parameters:
        - id: months
          type: System.Int64
          description: The number of months in the new period
        return:
          type: NodaTime.Period
          description: A period consisting of the given number of months.
      overload: NodaTime.Period.FromMonths*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.FromDays(System.Int64)
      commentId: M:NodaTime.Period.FromDays(System.Int64)
      language: CSharp
      name:
        CSharp: FromDays(Int64)
        VB: FromDays(Int64)
      nameWithType:
        CSharp: Period.FromDays(Int64)
        VB: Period.FromDays(Int64)
      qualifiedName:
        CSharp: NodaTime.Period.FromDays(System.Int64)
        VB: NodaTime.Period.FromDays(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromDays
        path: src/NodaTime/Period.cs
        startLine: 180
      summary: "\nCreates a period representing the specified number of days.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period FromDays(long days)
          VB: Public Shared Function FromDays(days As Long) As Period
        parameters:
        - id: days
          type: System.Int64
          description: The number of days in the new period
        return:
          type: NodaTime.Period
          description: A period consisting of the given number of days.
      overload: NodaTime.Period.FromDays*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.FromHours(System.Int64)
      commentId: M:NodaTime.Period.FromHours(System.Int64)
      language: CSharp
      name:
        CSharp: FromHours(Int64)
        VB: FromHours(Int64)
      nameWithType:
        CSharp: Period.FromHours(Int64)
        VB: Period.FromHours(Int64)
      qualifiedName:
        CSharp: NodaTime.Period.FromHours(System.Int64)
        VB: NodaTime.Period.FromHours(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromHours
        path: src/NodaTime/Period.cs
        startLine: 190
      summary: "\nCreates a period representing the specified number of hours.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period FromHours(long hours)
          VB: Public Shared Function FromHours(hours As Long) As Period
        parameters:
        - id: hours
          type: System.Int64
          description: The number of hours in the new period
        return:
          type: NodaTime.Period
          description: A period consisting of the given number of hours.
      overload: NodaTime.Period.FromHours*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.FromMinutes(System.Int64)
      commentId: M:NodaTime.Period.FromMinutes(System.Int64)
      language: CSharp
      name:
        CSharp: FromMinutes(Int64)
        VB: FromMinutes(Int64)
      nameWithType:
        CSharp: Period.FromMinutes(Int64)
        VB: Period.FromMinutes(Int64)
      qualifiedName:
        CSharp: NodaTime.Period.FromMinutes(System.Int64)
        VB: NodaTime.Period.FromMinutes(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromMinutes
        path: src/NodaTime/Period.cs
        startLine: 200
      summary: "\nCreates a period representing the specified number of minutes.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period FromMinutes(long minutes)
          VB: Public Shared Function FromMinutes(minutes As Long) As Period
        parameters:
        - id: minutes
          type: System.Int64
          description: The number of minutes in the new period
        return:
          type: NodaTime.Period
          description: A period consisting of the given number of minutes.
      overload: NodaTime.Period.FromMinutes*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.FromSeconds(System.Int64)
      commentId: M:NodaTime.Period.FromSeconds(System.Int64)
      language: CSharp
      name:
        CSharp: FromSeconds(Int64)
        VB: FromSeconds(Int64)
      nameWithType:
        CSharp: Period.FromSeconds(Int64)
        VB: Period.FromSeconds(Int64)
      qualifiedName:
        CSharp: NodaTime.Period.FromSeconds(System.Int64)
        VB: NodaTime.Period.FromSeconds(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromSeconds
        path: src/NodaTime/Period.cs
        startLine: 210
      summary: "\nCreates a period representing the specified number of seconds.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period FromSeconds(long seconds)
          VB: Public Shared Function FromSeconds(seconds As Long) As Period
        parameters:
        - id: seconds
          type: System.Int64
          description: The number of seconds in the new period
        return:
          type: NodaTime.Period
          description: A period consisting of the given number of seconds.
      overload: NodaTime.Period.FromSeconds*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.FromMillseconds(System.Int64)
      commentId: M:NodaTime.Period.FromMillseconds(System.Int64)
      language: CSharp
      name:
        CSharp: FromMillseconds(Int64)
        VB: FromMillseconds(Int64)
      nameWithType:
        CSharp: Period.FromMillseconds(Int64)
        VB: Period.FromMillseconds(Int64)
      qualifiedName:
        CSharp: NodaTime.Period.FromMillseconds(System.Int64)
        VB: NodaTime.Period.FromMillseconds(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromMillseconds
        path: src/NodaTime/Period.cs
        startLine: 222
      summary: "\nCreates a period representing the specified number of milliseconds.\n"
      remarks: This method is not available in the PCL version, as it was made obsolete in Noda Time 1.1.
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("Use FromMilliseconds instead. This method's name was a typo, and it will be removed in a future release.")]

            public static Period FromMillseconds(long milliseconds)
          VB: >-
            <Obsolete("Use FromMilliseconds instead. This method's name was a typo, and it will be removed in a future release.")>

            Public Shared Function FromMillseconds(milliseconds As Long) As Period
        parameters:
        - id: milliseconds
          type: System.Int64
          description: The number of milliseconds in the new period
        return:
          type: NodaTime.Period
          description: A period consisting of the given number of milliseconds.
      overload: NodaTime.Period.FromMillseconds*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: Use FromMilliseconds instead. This method's name was a typo, and it will be removed in a future release.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.FromMilliseconds(System.Int64)
      commentId: M:NodaTime.Period.FromMilliseconds(System.Int64)
      language: CSharp
      name:
        CSharp: FromMilliseconds(Int64)
        VB: FromMilliseconds(Int64)
      nameWithType:
        CSharp: Period.FromMilliseconds(Int64)
        VB: Period.FromMilliseconds(Int64)
      qualifiedName:
        CSharp: NodaTime.Period.FromMilliseconds(System.Int64)
        VB: NodaTime.Period.FromMilliseconds(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromMilliseconds
        path: src/NodaTime/Period.cs
        startLine: 234
      summary: "\nCreates a period representing the specified number of milliseconds.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period FromMilliseconds(long milliseconds)
          VB: Public Shared Function FromMilliseconds(milliseconds As Long) As Period
        parameters:
        - id: milliseconds
          type: System.Int64
          description: The number of milliseconds in the new period
        return:
          type: NodaTime.Period
          description: A period consisting of the given number of milliseconds.
      overload: NodaTime.Period.FromMilliseconds*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.FromTicks(System.Int64)
      commentId: M:NodaTime.Period.FromTicks(System.Int64)
      language: CSharp
      name:
        CSharp: FromTicks(Int64)
        VB: FromTicks(Int64)
      nameWithType:
        CSharp: Period.FromTicks(Int64)
        VB: Period.FromTicks(Int64)
      qualifiedName:
        CSharp: NodaTime.Period.FromTicks(System.Int64)
        VB: NodaTime.Period.FromTicks(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromTicks
        path: src/NodaTime/Period.cs
        startLine: 244
      summary: "\nCreates a period representing the specified number of ticks.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period FromTicks(long ticks)
          VB: Public Shared Function FromTicks(ticks As Long) As Period
        parameters:
        - id: ticks
          type: System.Int64
          description: The number of ticks in the new period
        return:
          type: NodaTime.Period
          description: A period consisting of the given number of ticks.
      overload: NodaTime.Period.FromTicks*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.op_Addition(NodaTime.Period,NodaTime.Period)
      commentId: M:NodaTime.Period.op_Addition(NodaTime.Period,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Addition(Period, Period)
        VB: Addition(Period, Period)
      nameWithType:
        CSharp: Period.Addition(Period, Period)
        VB: Period.Addition(Period, Period)
      qualifiedName:
        CSharp: NodaTime.Period.Addition(NodaTime.Period, NodaTime.Period)
        VB: NodaTime.Period.Addition(NodaTime.Period, NodaTime.Period)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Addition
        path: src/NodaTime/Period.cs
        startLine: 256
      summary: "\nAdds two periods together, by simply adding the values for each property.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period operator +(Period left, Period right)
          VB: Public Shared Operator +(left As Period, right As Period) As Period
        parameters:
        - id: left
          type: NodaTime.Period
          description: The first period to add
        - id: right
          type: NodaTime.Period
          description: The second period to add
        return:
          type: NodaTime.Period
          description: >-
            The sum of the two periods. The units of the result will be the union of those in both

            periods.
      overload: NodaTime.Period.op_Addition*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.CreateComparer(NodaTime.LocalDateTime)
      commentId: M:NodaTime.Period.CreateComparer(NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: CreateComparer(LocalDateTime)
        VB: CreateComparer(LocalDateTime)
      nameWithType:
        CSharp: Period.CreateComparer(LocalDateTime)
        VB: Period.CreateComparer(LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.Period.CreateComparer(NodaTime.LocalDateTime)
        VB: NodaTime.Period.CreateComparer(NodaTime.LocalDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateComparer
        path: src/NodaTime/Period.cs
        startLine: 277
      summary: "\nCreates an <xref href=\"System.Collections.Generic.IComparer%601\" data-throw-if-not-resolved=\"false\"></xref> for periods, using the given \"base\" local date/time.\n"
      remarks: "\nCertain periods can't naturally be compared without more context - how \"one month\" compares to\n\"30 days\" depends on where you start. In order to compare two periods, the returned comparer\neffectively adds both periods to the \"base\" specified by <span class=\"paramref\">baseDateTime</span> and compares\nthe results. In some cases this arithmetic isn't actually required - when two periods can be\nconverted to durations, the comparer uses that conversion for efficiency.\n"
      example: []
      syntax:
        content:
          CSharp: public static IComparer<Period> CreateComparer(LocalDateTime baseDateTime)
          VB: Public Shared Function CreateComparer(baseDateTime As LocalDateTime) As IComparer(Of Period)
        parameters:
        - id: baseDateTime
          type: NodaTime.LocalDateTime
          description: The base local date/time to use for comparisons.
        return:
          type: System.Collections.Generic.IComparer{NodaTime.Period}
          description: The new comparer.
      overload: NodaTime.Period.CreateComparer*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.Collections.Generic.IComparer`1: 
    - id: NodaTime.Period.op_Subtraction(NodaTime.Period,NodaTime.Period)
      commentId: M:NodaTime.Period.op_Subtraction(NodaTime.Period,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Subtraction(Period, Period)
        VB: Subtraction(Period, Period)
      nameWithType:
        CSharp: Period.Subtraction(Period, Period)
        VB: Period.Subtraction(Period, Period)
      qualifiedName:
        CSharp: NodaTime.Period.Subtraction(NodaTime.Period, NodaTime.Period)
        VB: NodaTime.Period.Subtraction(NodaTime.Period, NodaTime.Period)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Subtraction
        path: src/NodaTime/Period.cs
        startLine: 342
      summary: "\nSubtracts one period from another, by simply subtracting each property value.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period operator -(Period minuend, Period subtrahend)
          VB: Public Shared Operator -(minuend As Period, subtrahend As Period) As Period
        parameters:
        - id: minuend
          type: NodaTime.Period
          description: The period to subtract the second operand from
        - id: subtrahend
          type: NodaTime.Period
          description: The period to subtract the first operand from
        return:
          type: NodaTime.Period
          description: >-
            The result of subtracting all the values in the second operand from the values in the first. The

            units of the result will be the union of both periods, even if the subtraction caused some properties to

            become zero (so "2 weeks, 1 days" minus "2 weeks" is "zero weeks, 1 days", not "1 days").
      overload: NodaTime.Period.op_Subtraction*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime,NodaTime.PeriodUnits)
      commentId: M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime,NodaTime.PeriodUnits)
      language: CSharp
      name:
        CSharp: Between(LocalDateTime, LocalDateTime, PeriodUnits)
        VB: Between(LocalDateTime, LocalDateTime, PeriodUnits)
      nameWithType:
        CSharp: Period.Between(LocalDateTime, LocalDateTime, PeriodUnits)
        VB: Period.Between(LocalDateTime, LocalDateTime, PeriodUnits)
      qualifiedName:
        CSharp: NodaTime.Period.Between(NodaTime.LocalDateTime, NodaTime.LocalDateTime, NodaTime.PeriodUnits)
        VB: NodaTime.Period.Between(NodaTime.LocalDateTime, NodaTime.LocalDateTime, NodaTime.PeriodUnits)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Between
        path: src/NodaTime/Period.cs
        startLine: 367
      summary: "\nReturns the period between a start and an end date/time, using only the given units.\n"
      remarks: "\nIf <span class=\"paramref\">end</span> is before <span class=\"paramref\">start</span>, each property in the returned period\nwill be negative. If the given set of units cannot exactly reach the end point (e.g. finding\nthe difference between 1am and 3:15am in hours) the result will be such that adding it to <span class=\"paramref\">start</span>\nwill give a value between <span class=\"paramref\">start</span> and <span class=\"paramref\">end</span>. In other words,\nany rounding is \"towards start\"; this is true whether the resulting period is negative or positive.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period Between(LocalDateTime start, LocalDateTime end, PeriodUnits units)
          VB: Public Shared Function Between(start As LocalDateTime, end As LocalDateTime, units As PeriodUnits) As Period
        parameters:
        - id: start
          type: NodaTime.LocalDateTime
          description: Start date/time
        - id: end
          type: NodaTime.LocalDateTime
          description: End date/time
        - id: units
          type: NodaTime.PeriodUnits
          description: Units to use for calculations
        return:
          type: NodaTime.Period
          description: The period between the given date/times, using the given units.
      overload: NodaTime.Period.Between*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">units</span> is empty or contained unknown values.
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">start</span> and <span class="paramref">end</span> use different calendars.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      commentId: M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: Between(LocalDateTime, LocalDateTime)
        VB: Between(LocalDateTime, LocalDateTime)
      nameWithType:
        CSharp: Period.Between(LocalDateTime, LocalDateTime)
        VB: Period.Between(LocalDateTime, LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.Period.Between(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
        VB: NodaTime.Period.Between(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Between
        path: src/NodaTime/Period.cs
        startLine: 443
      summary: "\nReturns the exact difference between two date/times.\n"
      remarks: "\nIf <span class=\"paramref\">end</span> is before <span class=\"paramref\">start</span>, each property in the returned period\nwill be negative.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period Between(LocalDateTime start, LocalDateTime end)
          VB: Public Shared Function Between(start As LocalDateTime, end As LocalDateTime) As Period
        parameters:
        - id: start
          type: NodaTime.LocalDateTime
          description: Start date/time
        - id: end
          type: NodaTime.LocalDateTime
          description: End date/time
        return:
          type: NodaTime.Period
          description: The period between the two date and time values, using all units.
      overload: NodaTime.Period.Between*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate,NodaTime.PeriodUnits)
      commentId: M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate,NodaTime.PeriodUnits)
      language: CSharp
      name:
        CSharp: Between(LocalDate, LocalDate, PeriodUnits)
        VB: Between(LocalDate, LocalDate, PeriodUnits)
      nameWithType:
        CSharp: Period.Between(LocalDate, LocalDate, PeriodUnits)
        VB: Period.Between(LocalDate, LocalDate, PeriodUnits)
      qualifiedName:
        CSharp: NodaTime.Period.Between(NodaTime.LocalDate, NodaTime.LocalDate, NodaTime.PeriodUnits)
        VB: NodaTime.Period.Between(NodaTime.LocalDate, NodaTime.LocalDate, NodaTime.PeriodUnits)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Between
        path: src/NodaTime/Period.cs
        startLine: 464
      summary: "\nReturns the period between a start and an end date, using only the given units.\n"
      remarks: "\nIf <span class=\"paramref\">end</span> is before <span class=\"paramref\">start</span>, each property in the returned period\nwill be negative. If the given set of units cannot exactly reach the end point (e.g. finding\nthe difference between 12th February and 15th March in months) the result will be such that adding it to <span class=\"paramref\">start</span>\nwill give a value between <span class=\"paramref\">start</span> and <span class=\"paramref\">end</span>. In other words,\nany rounding is \"towards start\"; this is true whether the resulting period is negative or positive.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period Between(LocalDate start, LocalDate end, PeriodUnits units)
          VB: Public Shared Function Between(start As LocalDate, end As LocalDate, units As PeriodUnits) As Period
        parameters:
        - id: start
          type: NodaTime.LocalDate
          description: Start date
        - id: end
          type: NodaTime.LocalDate
          description: End date
        - id: units
          type: NodaTime.PeriodUnits
          description: Units to use for calculations
        return:
          type: NodaTime.Period
          description: The period between the given dates, using the given units.
      overload: NodaTime.Period.Between*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">units</span> contains time units, is empty or contains unknown values.
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">start</span> and <span class="paramref">end</span> use different calendars.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate)
      commentId: M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: Between(LocalDate, LocalDate)
        VB: Between(LocalDate, LocalDate)
      nameWithType:
        CSharp: Period.Between(LocalDate, LocalDate)
        VB: Period.Between(LocalDate, LocalDate)
      qualifiedName:
        CSharp: NodaTime.Period.Between(NodaTime.LocalDate, NodaTime.LocalDate)
        VB: NodaTime.Period.Between(NodaTime.LocalDate, NodaTime.LocalDate)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Between
        path: src/NodaTime/Period.cs
        startLine: 480
      summary: "\nReturns the exact difference between two dates.\n"
      remarks: "\nIf <span class=\"paramref\">end</span> is before <span class=\"paramref\">start</span>, each property in the returned period\nwill be negative.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period Between(LocalDate start, LocalDate end)
          VB: Public Shared Function Between(start As LocalDate, end As LocalDate) As Period
        parameters:
        - id: start
          type: NodaTime.LocalDate
          description: Start date
        - id: end
          type: NodaTime.LocalDate
          description: End date
        return:
          type: NodaTime.Period
          description: The period between the two dates, using year, month and day units.
      overload: NodaTime.Period.Between*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime,NodaTime.PeriodUnits)
      commentId: M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime,NodaTime.PeriodUnits)
      language: CSharp
      name:
        CSharp: Between(LocalTime, LocalTime, PeriodUnits)
        VB: Between(LocalTime, LocalTime, PeriodUnits)
      nameWithType:
        CSharp: Period.Between(LocalTime, LocalTime, PeriodUnits)
        VB: Period.Between(LocalTime, LocalTime, PeriodUnits)
      qualifiedName:
        CSharp: NodaTime.Period.Between(NodaTime.LocalTime, NodaTime.LocalTime, NodaTime.PeriodUnits)
        VB: NodaTime.Period.Between(NodaTime.LocalTime, NodaTime.LocalTime, NodaTime.PeriodUnits)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Between
        path: src/NodaTime/Period.cs
        startLine: 501
      summary: "\nReturns the period between a start and an end time, using only the given units.\n"
      remarks: "\nIf <span class=\"paramref\">end</span> is before <span class=\"paramref\">start</span>, each property in the returned period\nwill be negative. If the given set of units cannot exactly reach the end point (e.g. finding\nthe difference between 3am and 4.30am in hours) the result will be such that adding it to <span class=\"paramref\">start</span>\nwill give a value between <span class=\"paramref\">start</span> and <span class=\"paramref\">end</span>. In other words,\nany rounding is \"towards start\"; this is true whether the resulting period is negative or positive.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period Between(LocalTime start, LocalTime end, PeriodUnits units)
          VB: Public Shared Function Between(start As LocalTime, end As LocalTime, units As PeriodUnits) As Period
        parameters:
        - id: start
          type: NodaTime.LocalTime
          description: Start time
        - id: end
          type: NodaTime.LocalTime
          description: End time
        - id: units
          type: NodaTime.PeriodUnits
          description: Units to use for calculations
        return:
          type: NodaTime.Period
          description: The period between the given times, using the given units.
      overload: NodaTime.Period.Between*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">units</span> contains date units, is empty or contains unknown values.
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">start</span> and <span class="paramref">end</span> use different calendars.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime)
      commentId: M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: Between(LocalTime, LocalTime)
        VB: Between(LocalTime, LocalTime)
      nameWithType:
        CSharp: Period.Between(LocalTime, LocalTime)
        VB: Period.Between(LocalTime, LocalTime)
      qualifiedName:
        CSharp: NodaTime.Period.Between(NodaTime.LocalTime, NodaTime.LocalTime)
        VB: NodaTime.Period.Between(NodaTime.LocalTime, NodaTime.LocalTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Between
        path: src/NodaTime/Period.cs
        startLine: 517
      summary: "\nReturns the exact difference between two times.\n"
      remarks: "\nIf <span class=\"paramref\">end</span> is before <span class=\"paramref\">start</span>, each property in the returned period\nwill be negative.\n"
      example: []
      syntax:
        content:
          CSharp: public static Period Between(LocalTime start, LocalTime end)
          VB: Public Shared Function Between(start As LocalTime, end As LocalTime) As Period
        parameters:
        - id: start
          type: NodaTime.LocalTime
          description: Start time
        - id: end
          type: NodaTime.LocalTime
          description: End time
        return:
          type: NodaTime.Period
          description: The period between the two times, using the time period units.
      overload: NodaTime.Period.Between*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Period.HasTimeComponent
      commentId: P:NodaTime.Period.HasTimeComponent
      language: CSharp
      name:
        CSharp: HasTimeComponent
        VB: HasTimeComponent
      nameWithType:
        CSharp: Period.HasTimeComponent
        VB: Period.HasTimeComponent
      qualifiedName:
        CSharp: NodaTime.Period.HasTimeComponent
        VB: NodaTime.Period.HasTimeComponent
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: HasTimeComponent
        path: src/NodaTime/Period.cs
        startLine: 525
      summary: "\nReturns whether or not this period contains any non-zero-valued time-based properties (hours or lower).\n"
      example: []
      syntax:
        content:
          CSharp: public bool HasTimeComponent { get; }
          VB: Public ReadOnly Property HasTimeComponent As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: NodaTime.Period.HasTimeComponent*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.HasDateComponent
      commentId: P:NodaTime.Period.HasDateComponent
      language: CSharp
      name:
        CSharp: HasDateComponent
        VB: HasDateComponent
      nameWithType:
        CSharp: Period.HasDateComponent
        VB: Period.HasDateComponent
      qualifiedName:
        CSharp: NodaTime.Period.HasDateComponent
        VB: NodaTime.Period.HasDateComponent
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: HasDateComponent
        path: src/NodaTime/Period.cs
        startLine: 536
      summary: "\nReturns whether or not this period contains any non-zero date-based properties (days or higher).\n"
      example: []
      syntax:
        content:
          CSharp: public bool HasDateComponent { get; }
          VB: Public ReadOnly Property HasDateComponent As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: NodaTime.Period.HasDateComponent*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.ToDuration
      commentId: M:NodaTime.Period.ToDuration
      language: CSharp
      name:
        CSharp: ToDuration()
        VB: ToDuration()
      nameWithType:
        CSharp: Period.ToDuration()
        VB: Period.ToDuration()
      qualifiedName:
        CSharp: NodaTime.Period.ToDuration()
        VB: NodaTime.Period.ToDuration()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToDuration
        path: src/NodaTime/Period.cs
        startLine: 554
      summary: "\nFor periods that do not contain a non-zero number of years or months, returns a duration for this period\nassuming a standard 7-day week, 24-hour day, 60-minute hour etc.\n"
      example: []
      syntax:
        content:
          CSharp: public Duration ToDuration()
          VB: Public Function ToDuration As Duration
        return:
          type: NodaTime.Duration
          description: The duration of the period.
      overload: NodaTime.Period.ToDuration*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The month or year property in the period is non-zero.
      - type: System.OverflowException
        commentId: T:System.OverflowException
        description: >-
          The period doesn't have years or months, but the calculation

          overflows the bounds of <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref>. In some cases this may occur even though the theoretical

          result would be valid due to balancing positive and negative values, but for simplicity there is

          no attempt to work around this - in realistic periods, it shouldn't be a problem.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Duration: 
    - id: NodaTime.Period.ToBuilder
      commentId: M:NodaTime.Period.ToBuilder
      language: CSharp
      name:
        CSharp: ToBuilder()
        VB: ToBuilder()
      nameWithType:
        CSharp: Period.ToBuilder()
        VB: Period.ToBuilder()
      qualifiedName:
        CSharp: NodaTime.Period.ToBuilder()
        VB: NodaTime.Period.ToBuilder()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToBuilder
        path: src/NodaTime/Period.cs
        startLine: 587
      summary: "\nCreates a <xref href=\"NodaTime.PeriodBuilder\" data-throw-if-not-resolved=\"false\"></xref> from this instance. The new builder\nis populated with the values from this period, but is then detached from it:\nchanges made to the builder are not reflected in this period.\n"
      example: []
      syntax:
        content:
          CSharp: public PeriodBuilder ToBuilder()
          VB: Public Function ToBuilder As PeriodBuilder
        return:
          type: NodaTime.PeriodBuilder
          description: A builder with the same values and units as this period.
      overload: NodaTime.Period.ToBuilder*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.PeriodBuilder: 
    - id: NodaTime.Period.Normalize
      commentId: M:NodaTime.Period.Normalize
      language: CSharp
      name:
        CSharp: Normalize()
        VB: Normalize()
      nameWithType:
        CSharp: Period.Normalize()
        VB: Period.Normalize()
      qualifiedName:
        CSharp: NodaTime.Period.Normalize()
        VB: NodaTime.Period.Normalize()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Normalize
        path: src/NodaTime/Period.cs
        startLine: 613
      summary: "\nReturns a normalized version of this period, such that equivalent (but potentially non-equal) periods are\nchanged to the same representation.\n"
      remarks: "\nMonths and years are unchanged\n(as they can vary in length), but weeks are multiplied by 7 and added to the\nDays property, and all time properties are normalized to their natural range\n(where ticks are \"within a millisecond\"), adding to the larger property where\nnecessary. So for example, a period of 25 hours becomes a period of 1 day\nand 1 hour. Aside from months and years, either all the properties\nend up positive, or they all end up negative.\n"
      example: []
      syntax:
        content:
          CSharp: public Period Normalize()
          VB: Public Function Normalize As Period
        return:
          type: NodaTime.Period
          description: The normalized period.
      overload: NodaTime.Period.Normalize*
      exceptions:
      - type: System.OverflowException
        commentId: T:System.OverflowException
        description: >-
          The period doesn't have years or months, but it contains more than

          <xref href="System.Int64.MaxValue" data-throw-if-not-resolved="false"></xref> ticks when the combined weeks/days/time portions are considered. Such a period

          could never be useful anyway, however.

          In some cases this may occur even though the theoretical result would be valid due to balancing positive and

          negative values, but for simplicity there is no attempt to work around this - in realistic periods, it

          shouldn't be a problem.
      seealso:
      - linkId: NodaTime.Period.NormalizingEqualityComparer
        commentId: P:NodaTime.Period.NormalizingEqualityComparer
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.Int64.MaxValue: 
        NodaTime.Period.NormalizingEqualityComparer: 
    - id: NodaTime.Period.Years
      commentId: P:NodaTime.Period.Years
      language: CSharp
      name:
        CSharp: Years
        VB: Years
      nameWithType:
        CSharp: Period.Years
        VB: Period.Years
      qualifiedName:
        CSharp: NodaTime.Period.Years
        VB: NodaTime.Period.Years
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Years
        path: src/NodaTime/Period.cs
        startLine: 677
      summary: "\nGets the number of years within this period.\n"
      remarks: "\nThis property returns zero both when the property has been explicitly set to zero and when the period does not\ncontain this property.\n"
      example: []
      syntax:
        content:
          CSharp: public long Years { get; }
          VB: Public ReadOnly Property Years As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Period.Years*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.Months
      commentId: P:NodaTime.Period.Months
      language: CSharp
      name:
        CSharp: Months
        VB: Months
      nameWithType:
        CSharp: Period.Months
        VB: Period.Months
      qualifiedName:
        CSharp: NodaTime.Period.Months
        VB: NodaTime.Period.Months
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Months
        path: src/NodaTime/Period.cs
        startLine: 685
      summary: "\nGets the number of months within this period.\n"
      remarks: "\nThis property returns zero both when the property has been explicitly set to zero and when the period does not\ncontain this property.\n"
      example: []
      syntax:
        content:
          CSharp: public long Months { get; }
          VB: Public ReadOnly Property Months As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Period.Months*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.Weeks
      commentId: P:NodaTime.Period.Weeks
      language: CSharp
      name:
        CSharp: Weeks
        VB: Weeks
      nameWithType:
        CSharp: Period.Weeks
        VB: Period.Weeks
      qualifiedName:
        CSharp: NodaTime.Period.Weeks
        VB: NodaTime.Period.Weeks
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Weeks
        path: src/NodaTime/Period.cs
        startLine: 693
      summary: "\nGets the number of weeks within this period.\n"
      remarks: "\nThis property returns zero both when the property has been explicitly set to zero and when the period does not\ncontain this property.\n"
      example: []
      syntax:
        content:
          CSharp: public long Weeks { get; }
          VB: Public ReadOnly Property Weeks As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Period.Weeks*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.Days
      commentId: P:NodaTime.Period.Days
      language: CSharp
      name:
        CSharp: Days
        VB: Days
      nameWithType:
        CSharp: Period.Days
        VB: Period.Days
      qualifiedName:
        CSharp: NodaTime.Period.Days
        VB: NodaTime.Period.Days
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Days
        path: src/NodaTime/Period.cs
        startLine: 701
      summary: "\nGets the number of days within this period.\n"
      remarks: "\nThis property returns zero both when the property has been explicitly set to zero and when the period does not\ncontain this property.\n"
      example: []
      syntax:
        content:
          CSharp: public long Days { get; }
          VB: Public ReadOnly Property Days As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Period.Days*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.Hours
      commentId: P:NodaTime.Period.Hours
      language: CSharp
      name:
        CSharp: Hours
        VB: Hours
      nameWithType:
        CSharp: Period.Hours
        VB: Period.Hours
      qualifiedName:
        CSharp: NodaTime.Period.Hours
        VB: NodaTime.Period.Hours
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Hours
        path: src/NodaTime/Period.cs
        startLine: 709
      summary: "\nGets the number of hours within this period.\n"
      remarks: "\nThis property returns zero both when the property has been explicitly set to zero and when the period does not\ncontain this property.\n"
      example: []
      syntax:
        content:
          CSharp: public long Hours { get; }
          VB: Public ReadOnly Property Hours As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Period.Hours*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.Minutes
      commentId: P:NodaTime.Period.Minutes
      language: CSharp
      name:
        CSharp: Minutes
        VB: Minutes
      nameWithType:
        CSharp: Period.Minutes
        VB: Period.Minutes
      qualifiedName:
        CSharp: NodaTime.Period.Minutes
        VB: NodaTime.Period.Minutes
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minutes
        path: src/NodaTime/Period.cs
        startLine: 717
      summary: "\nGets the number of minutes within this period.\n"
      remarks: "\nThis property returns zero both when the property has been explicitly set to zero and when the period does not\ncontain this property.\n"
      example: []
      syntax:
        content:
          CSharp: public long Minutes { get; }
          VB: Public ReadOnly Property Minutes As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Period.Minutes*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.Seconds
      commentId: P:NodaTime.Period.Seconds
      language: CSharp
      name:
        CSharp: Seconds
        VB: Seconds
      nameWithType:
        CSharp: Period.Seconds
        VB: Period.Seconds
      qualifiedName:
        CSharp: NodaTime.Period.Seconds
        VB: NodaTime.Period.Seconds
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Seconds
        path: src/NodaTime/Period.cs
        startLine: 725
      summary: "\nGets the number of seconds within this period.\n"
      remarks: "\nThis property returns zero both when the property has been explicitly set to zero and when the period does not\ncontain this property.\n"
      example: []
      syntax:
        content:
          CSharp: public long Seconds { get; }
          VB: Public ReadOnly Property Seconds As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Period.Seconds*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.Milliseconds
      commentId: P:NodaTime.Period.Milliseconds
      language: CSharp
      name:
        CSharp: Milliseconds
        VB: Milliseconds
      nameWithType:
        CSharp: Period.Milliseconds
        VB: Period.Milliseconds
      qualifiedName:
        CSharp: NodaTime.Period.Milliseconds
        VB: NodaTime.Period.Milliseconds
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Milliseconds
        path: src/NodaTime/Period.cs
        startLine: 733
      summary: "\nGets the number of milliseconds within this period.\n"
      remarks: "\nThis property returns zero both when the property has been explicitly set to zero and when the period does not\ncontain this property.\n"
      example: []
      syntax:
        content:
          CSharp: public long Milliseconds { get; }
          VB: Public ReadOnly Property Milliseconds As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Period.Milliseconds*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.Ticks
      commentId: P:NodaTime.Period.Ticks
      language: CSharp
      name:
        CSharp: Ticks
        VB: Ticks
      nameWithType:
        CSharp: Period.Ticks
        VB: Period.Ticks
      qualifiedName:
        CSharp: NodaTime.Period.Ticks
        VB: NodaTime.Period.Ticks
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Ticks
        path: src/NodaTime/Period.cs
        startLine: 741
      summary: "\nGets the number of ticks within this period.\n"
      remarks: "\nThis property returns zero both when the property has been explicitly set to zero and when the period does not\ncontain this property.\n"
      example: []
      syntax:
        content:
          CSharp: public long Ticks { get; }
          VB: Public ReadOnly Property Ticks As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Period.Ticks*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Period.ToString
      commentId: M:NodaTime.Period.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: Period.ToString()
        VB: Period.ToString()
      qualifiedName:
        CSharp: NodaTime.Period.ToString()
        VB: NodaTime.Period.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/Period.cs
        startLine: 750
      summary: "\nReturns this string formatted according to the <xref href=\"NodaTime.Text.PeriodPattern.RoundtripPattern\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: A formatted representation of this period.
      overload: NodaTime.Period.ToString*
      overridden: System.Object.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        NodaTime.Text.PeriodPattern.RoundtripPattern: 
    - id: NodaTime.Period.Equals(System.Object)
      commentId: M:NodaTime.Period.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: Period.Equals(Object)
        VB: Period.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.Period.Equals(System.Object)
        VB: NodaTime.Period.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/Period.cs
        startLine: 760
      summary: "\nCompares the given object for equality with this one, as per <xref href=\"NodaTime.Period.Equals(NodaTime.Period)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object other)
          VB: Public Overrides Function Equals(other As Object) As Boolean
        parameters:
        - id: other
          type: System.Object
          description: The value to compare this one with.
        return:
          type: System.Boolean
          description: true if the other object is a period equal to this one, consistent with <xref href="NodaTime.Period.Equals(NodaTime.Period)" data-throw-if-not-resolved="false"></xref>
      overload: NodaTime.Period.Equals*
      overridden: System.Object.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        NodaTime.Period.Equals(NodaTime.Period): 
    - id: NodaTime.Period.GetHashCode
      commentId: M:NodaTime.Period.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: Period.GetHashCode()
        VB: Period.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.Period.GetHashCode()
        VB: NodaTime.Period.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/Period.cs
        startLine: 769
      summary: "\nReturns the hash code for this period, consistent with <xref href=\"NodaTime.Period.Equals(NodaTime.Period)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: The hash code for this period.
      overload: NodaTime.Period.GetHashCode*
      overridden: System.Object.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        NodaTime.Period.Equals(NodaTime.Period): 
    - id: NodaTime.Period.Equals(NodaTime.Period)
      commentId: M:NodaTime.Period.Equals(NodaTime.Period)
      language: CSharp
      name:
        CSharp: Equals(Period)
        VB: Equals(Period)
      nameWithType:
        CSharp: Period.Equals(Period)
        VB: Period.Equals(Period)
      qualifiedName:
        CSharp: NodaTime.Period.Equals(NodaTime.Period)
        VB: NodaTime.Period.Equals(NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/Period.cs
        startLine: 793
      summary: "\nCompares the given period for equality with this one.\n"
      remarks: "\nPeriods are equal if they contain the same values for the same properties.\nHowever, no normalization takes place, so \"one hour\" is not equal to \"sixty minutes\".\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(Period other)
          VB: Public Function Equals(other As Period) As Boolean
        parameters:
        - id: other
          type: NodaTime.Period
          description: The period to compare this one with.
        return:
          type: System.Boolean
          description: True if this period has the same values for the same properties as the one specified.
      overload: NodaTime.Period.Equals*
      implements:
      - System.IEquatable{NodaTime.Period}.Equals(NodaTime.Period)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - isEii: true
      id: NodaTime.Period.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:NodaTime.Period.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: Period.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: Period.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: NodaTime.Period.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: NodaTime.Period.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Period.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Runtime.Serialization.ISerializable.GetObjectData
        path: src/NodaTime/Period.cs
        startLine: 847
      summary: "\nImplementation of <xref href=\"System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo%2cSystem.Runtime.Serialization.StreamingContext)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
          VB: Sub System.Runtime.Serialization.ISerializable.GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: The <xref href="System.Runtime.Serialization.SerializationInfo" data-throw-if-not-resolved="false"></xref> to populate with data.
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: The destination for this serialization.
      overload: NodaTime.Period.System#Runtime#Serialization#ISerializable#GetObjectData*
      implements:
      - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      modifiers:
        CSharp: []
        VB: []
      references:
        ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        : 
        System.Runtime.Serialization.SerializationInfo: 
    references:
      NodaTime.Period: 
      NodaTime.Period.Years: 
      NodaTime.Period.Months: 
      NodaTime.Period.Normalize: 
      NodaTime.LocalDateTime: 
      NodaTime.Duration: 
      NodaTime.ZonedDateTime: 
  - id: NodaTime.SkippedTimeException
    commentId: T:NodaTime.SkippedTimeException
    language: CSharp
    name:
      CSharp: SkippedTimeException
      VB: SkippedTimeException
    nameWithType:
      CSharp: SkippedTimeException
      VB: SkippedTimeException
    qualifiedName:
      CSharp: NodaTime.SkippedTimeException
      VB: NodaTime.SkippedTimeException
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/SkippedTimeException.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: SkippedTimeException
      path: src/NodaTime/SkippedTimeException.cs
      startLine: 34
    summary: "\nException thrown to indicate that the specified local time doesn't\nexist in a particular time zone due to daylight saving time changes.    \n"
    remarks: "\n<p>\nThis normally occurs for spring transitions, where the clock goes forward\n(usually by an hour). For example, suppose the time zone goes forward\nat 2am, so the second after 01:59:59 becomes 03:00:00. In that case,\nlocal times such as 02:30:00 never occur.\n</p>\n<p>\nThis exception is used to indicate such problems, as they're usually\nnot the same as other <xref href=\"System.ArgumentOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> causes,\nsuch as entering \"15\" for a month number.\n</p>\n<p>\nNote that it is possible (though extremely rare) for a whole day to be skipped due to a time zone transition,\nso this exception may also be thrown in cases where no local time is valid for a particular local date. (For\nexample, Samoa skipped December 30th 2011 entirely, transitioning from UTC-10 to UTC+14 at midnight.)\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public sealed class SkippedTimeException : ArgumentOutOfRangeException, _Exception, ISerializable
        VB: >-
          <Serializable>

          Public NotInheritable Class SkippedTimeException

              Inherits ArgumentOutOfRangeException

              Implements _Exception, ISerializable
    inheritance:
    - System.Object
    - System.Exception
    - System.SystemException
    - System.ArgumentException
    - System.ArgumentOutOfRangeException
    implements:
    - System.Runtime.InteropServices._Exception
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.ArgumentOutOfRangeException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    - System.ArgumentOutOfRangeException.Message
    - System.ArgumentOutOfRangeException.ActualValue
    - System.ArgumentException.ParamName
    - System.Exception.GetBaseException
    - System.Exception.ToString
    - System.Exception.GetType
    - System.Exception.Data
    - System.Exception.InnerException
    - System.Exception.TargetSite
    - System.Exception.StackTrace
    - System.Exception.HelpLink
    - System.Exception.Source
    - System.Exception.HResult
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.MemberwiseClone
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.SkippedTimeException.LocalDateTime
      commentId: P:NodaTime.SkippedTimeException.LocalDateTime
      language: CSharp
      name:
        CSharp: LocalDateTime
        VB: LocalDateTime
      nameWithType:
        CSharp: SkippedTimeException.LocalDateTime
        VB: SkippedTimeException.LocalDateTime
      qualifiedName:
        CSharp: NodaTime.SkippedTimeException.LocalDateTime
        VB: NodaTime.SkippedTimeException.LocalDateTime
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/SkippedTimeException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: LocalDateTime
        path: src/NodaTime/SkippedTimeException.cs
        startLine: 44
      summary: "\nThe local date/time which is invalid in the time zone\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime LocalDateTime { get; }
          VB: Public ReadOnly Property LocalDateTime As LocalDateTime
        parameters: []
        return:
          type: NodaTime.LocalDateTime
      overload: NodaTime.SkippedTimeException.LocalDateTime*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.SkippedTimeException.Zone
      commentId: P:NodaTime.SkippedTimeException.Zone
      language: CSharp
      name:
        CSharp: Zone
        VB: Zone
      nameWithType:
        CSharp: SkippedTimeException.Zone
        VB: SkippedTimeException.Zone
      qualifiedName:
        CSharp: NodaTime.SkippedTimeException.Zone
        VB: NodaTime.SkippedTimeException.Zone
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/SkippedTimeException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Zone
        path: src/NodaTime/SkippedTimeException.cs
        startLine: 49
      summary: "\nThe time zone in which the local date/time is invalid\n"
      example: []
      syntax:
        content:
          CSharp: public DateTimeZone Zone { get; }
          VB: Public ReadOnly Property Zone As DateTimeZone
        parameters: []
        return:
          type: NodaTime.DateTimeZone
      overload: NodaTime.SkippedTimeException.Zone*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.SkippedTimeException.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone)
      commentId: M:NodaTime.SkippedTimeException.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: SkippedTimeException(LocalDateTime, DateTimeZone)
        VB: SkippedTimeException(LocalDateTime, DateTimeZone)
      nameWithType:
        CSharp: SkippedTimeException.SkippedTimeException(LocalDateTime, DateTimeZone)
        VB: SkippedTimeException.SkippedTimeException(LocalDateTime, DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.SkippedTimeException.SkippedTimeException(NodaTime.LocalDateTime, NodaTime.DateTimeZone)
        VB: NodaTime.SkippedTimeException.SkippedTimeException(NodaTime.LocalDateTime, NodaTime.DateTimeZone)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/SkippedTimeException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/SkippedTimeException.cs
        startLine: 60
      summary: "\nCreates a new instance for the given local date/time and time zone.\n"
      remarks: "\nUser code is unlikely to need to deliberately call this constructor except\npossibly for testing.\n"
      example: []
      syntax:
        content:
          CSharp: public SkippedTimeException(LocalDateTime localDateTime, DateTimeZone zone)
          VB: Public Sub New(localDateTime As LocalDateTime, zone As DateTimeZone)
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: The local date/time which is skipped in the specified time zone.
        - id: zone
          type: NodaTime.DateTimeZone
          description: The time zone in which the local date/time does not exist.
      overload: NodaTime.SkippedTimeException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      System.ArgumentOutOfRangeException: 
  - id: NodaTime.SystemClock
    commentId: T:NodaTime.SystemClock
    language: CSharp
    name:
      CSharp: SystemClock
      VB: SystemClock
    nameWithType:
      CSharp: SystemClock
      VB: SystemClock
    qualifiedName:
      CSharp: NodaTime.SystemClock
      VB: NodaTime.SystemClock
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/SystemClock.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: SystemClock
      path: src/NodaTime/SystemClock.cs
      startLine: 15
    summary: "\nSingleton implementation of <xref href=\"NodaTime.IClock\" data-throw-if-not-resolved=\"false\"></xref> which reads the current system time.\nIt is recommended that for anything other than throwaway code, this is only referenced\nin a single place in your code: where you provide a value to inject into the rest of\nyour application, which should only depend on the interface.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class SystemClock : IClock'
        VB: >-
          Public NotInheritable Class SystemClock

              Implements IClock
    inheritance:
    - System.Object
    implements:
    - NodaTime.IClock
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.SystemClock.Instance
      commentId: F:NodaTime.SystemClock.Instance
      language: CSharp
      name:
        CSharp: Instance
        VB: Instance
      nameWithType:
        CSharp: SystemClock.Instance
        VB: SystemClock.Instance
      qualifiedName:
        CSharp: NodaTime.SystemClock.Instance
        VB: NodaTime.SystemClock.Instance
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/SystemClock.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Instance
        path: src/NodaTime/SystemClock.cs
        startLine: 21
      summary: "\nThe singleton instance of <xref href=\"NodaTime.SystemClock\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly SystemClock Instance
          VB: Public Shared ReadOnly Instance As SystemClock
        return:
          type: NodaTime.SystemClock
          description: The singleton instance of <xref href="NodaTime.SystemClock" data-throw-if-not-resolved="false"></xref>.
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.SystemClock: 
    - id: NodaTime.SystemClock.Now
      commentId: P:NodaTime.SystemClock.Now
      language: CSharp
      name:
        CSharp: Now
        VB: Now
      nameWithType:
        CSharp: SystemClock.Now
        VB: SystemClock.Now
      qualifiedName:
        CSharp: NodaTime.SystemClock.Now
        VB: NodaTime.SystemClock.Now
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/SystemClock.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Now
        path: src/NodaTime/SystemClock.cs
        startLine: 34
      summary: "\nGets the current time as an <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant Now { get; }
          VB: Public ReadOnly Property Now As Instant
        parameters: []
        return:
          type: NodaTime.Instant
          description: The current time in ticks as an <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref>.
      overload: NodaTime.SystemClock.Now*
      implements:
      - NodaTime.IClock.Now
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.Instant: 
    references:
      NodaTime.IClock: 
  - id: NodaTime.LocalDateTime
    commentId: T:NodaTime.LocalDateTime
    language: CSharp
    name:
      CSharp: LocalDateTime
      VB: LocalDateTime
    nameWithType:
      CSharp: LocalDateTime
      VB: LocalDateTime
    qualifiedName:
      CSharp: NodaTime.LocalDateTime
      VB: NodaTime.LocalDateTime
    type: Struct
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/LocalDateTime.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: LocalDateTime
      path: src/NodaTime/LocalDateTime.cs
      startLine: 43
    summary: "\nA date and time in a particular calendar system. A LocalDateTime value does not represent an\ninstant on the time line, because it has no associated time zone: \"November 12th 2009 7pm, ISO calendar\"\noccurred at different instants for different people around the world.\n"
    remarks: "\n<p>\nThis type defaults to using the IsoCalendarSystem unless a different calendar system is\nspecified.\n</p>\n<p>Comparisons of values can be handled in a way which is either calendar-sensitive or calendar-insensitive.\nNoda Time implements all the operators (and the <xref href=\"NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref> method) such that all operators other than <xref href=\"NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime%2cNodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref>\nwill return false if asked to compare two values in different calendar systems.\n</p>\n<p>\nHowever, the <xref href=\"NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref> method (implementing <xref href=\"System.IComparable%601\" data-throw-if-not-resolved=\"false\"></xref>) is calendar-insensitive; it compares the two\nvalues historically in terms of when they actually occurred, as if they're both converted to some \"neutral\" calendar system first.\n</p>\n<p>\nIt's unclear at the time of this writing whether this is the most appropriate approach, and it may change in future versions. In general,\nit would be a good idea for users to avoid comparing dates in different calendar systems, and indeed most users are unlikely to ever explicitly\nconsider which calendar system they're working in anyway.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public struct LocalDateTime : IEquatable<LocalDateTime>, IComparable<LocalDateTime>, IComparable, IFormattable, IXmlSerializable, ISerializable
        VB: >-
          <Serializable>

          Public Structure LocalDateTime

              Implements IEquatable(Of LocalDateTime), IComparable(Of LocalDateTime), IComparable, IFormattable, IXmlSerializable, ISerializable
    implements:
    - System.IEquatable{NodaTime.LocalDateTime}
    - System.IComparable{NodaTime.LocalDateTime}
    - System.IComparable
    - System.IFormattable
    - System.Xml.Serialization.IXmlSerializable
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LocalDateTime(Int32, Int32, Int32, Int32, Int32)
        VB: LocalDateTime(Int32, Int32, Int32, Int32, Int32)
      nameWithType:
        CSharp: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32)
        VB: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
        VB: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDateTime.cs
        startLine: 88
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct using the ISO calendar system.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime(int year, int month, int day, int hour, int minute)
          VB: Public Sub New(year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer)
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year",

            so a value of 0 means 1 BC, for example.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
        - id: hour
          type: System.Int32
          description: The hour.
        - id: minute
          type: System.Int32
          description: The minute.
      overload: NodaTime.LocalDateTime.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date/time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      commentId: M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: LocalDateTime(Int32, Int32, Int32, Int32, Int32, CalendarSystem)
        VB: LocalDateTime(Int32, Int32, Int32, Int32, Int32, CalendarSystem)
      nameWithType:
        CSharp: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, CalendarSystem)
        VB: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
        VB: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDateTime.cs
        startLine: 106
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime(int year, int month, int day, int hour, int minute, CalendarSystem calendar)
          VB: Public Sub New(year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, calendar As CalendarSystem)
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year", so, for

            the ISO calendar, a value of 0 means 1 BC, for example.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
        - id: hour
          type: System.Int32
          description: The hour.
        - id: minute
          type: System.Int32
          description: The minute.
        - id: calendar
          type: NodaTime.CalendarSystem
          description: The calendar.
      overload: NodaTime.LocalDateTime.#ctor*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">calendar</span> is null.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date/time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32)
        VB: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32)
      nameWithType:
        CSharp: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32)
        VB: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
        VB: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDateTime.cs
        startLine: 125
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct using the ISO calendar system.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime(int year, int month, int day, int hour, int minute, int second)
          VB: Public Sub New(year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer)
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year",

            so a value of 0 means 1 BC, for example.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
        - id: hour
          type: System.Int32
          description: The hour.
        - id: minute
          type: System.Int32
          description: The minute.
        - id: second
          type: System.Int32
          description: The second.
      overload: NodaTime.LocalDateTime.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date/time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      commentId: M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
        VB: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
      nameWithType:
        CSharp: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
        VB: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
        VB: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDateTime.cs
        startLine: 144
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime(int year, int month, int day, int hour, int minute, int second, CalendarSystem calendar)
          VB: Public Sub New(year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, calendar As CalendarSystem)
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year", so, for

            the ISO calendar, a value of 0 means 1 BC, for example.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
        - id: hour
          type: System.Int32
          description: The hour.
        - id: minute
          type: System.Int32
          description: The minute.
        - id: second
          type: System.Int32
          description: The second.
        - id: calendar
          type: NodaTime.CalendarSystem
          description: The calendar.
      overload: NodaTime.LocalDateTime.#ctor*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">calendar</span> is null.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date/time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32)
        VB: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32)
      nameWithType:
        CSharp: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32)
        VB: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
        VB: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDateTime.cs
        startLine: 164
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct using the ISO calendar system.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond)
          VB: Public Sub New(year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer)
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year",

            so a value of 0 means 1 BC, for example.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
        - id: hour
          type: System.Int32
          description: The hour.
        - id: minute
          type: System.Int32
          description: The minute.
        - id: second
          type: System.Int32
          description: The second.
        - id: millisecond
          type: System.Int32
          description: The millisecond.
      overload: NodaTime.LocalDateTime.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date/time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      commentId: M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
        VB: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
      nameWithType:
        CSharp: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
        VB: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
        VB: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDateTime.cs
        startLine: 184
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, CalendarSystem calendar)
          VB: Public Sub New(year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer, calendar As CalendarSystem)
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year", so, for

            the ISO calendar, a value of 0 means 1 BC, for example.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
        - id: hour
          type: System.Int32
          description: The hour.
        - id: minute
          type: System.Int32
          description: The minute.
        - id: second
          type: System.Int32
          description: The second.
        - id: millisecond
          type: System.Int32
          description: The millisecond.
        - id: calendar
          type: NodaTime.CalendarSystem
          description: The calendar.
      overload: NodaTime.LocalDateTime.#ctor*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">calendar</span> is null.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date/time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32)
        VB: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32)
      nameWithType:
        CSharp: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32)
        VB: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
        VB: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDateTime.cs
        startLine: 203
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int tickWithinMillisecond)
          VB: Public Sub New(year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer, tickWithinMillisecond As Integer)
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year",

            so a value of 0 means 1 BC, for example.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
        - id: hour
          type: System.Int32
          description: The hour.
        - id: minute
          type: System.Int32
          description: The minute.
        - id: second
          type: System.Int32
          description: The second.
        - id: millisecond
          type: System.Int32
          description: The millisecond.
        - id: tickWithinMillisecond
          type: System.Int32
          description: The tick within millisecond.
      overload: NodaTime.LocalDateTime.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date/time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      commentId: M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
        VB: LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
      nameWithType:
        CSharp: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
        VB: LocalDateTime.LocalDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32, CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
        VB: NodaTime.LocalDateTime.LocalDateTime(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, NodaTime.CalendarSystem)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/LocalDateTime.cs
        startLine: 224
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int tickWithinMillisecond, CalendarSystem calendar)
          VB: Public Sub New(year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer, tickWithinMillisecond As Integer, calendar As CalendarSystem)
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year", so, for

            the ISO calendar, a value of 0 means 1 BC, for example.
        - id: month
          type: System.Int32
          description: The month of year.
        - id: day
          type: System.Int32
          description: The day of month.
        - id: hour
          type: System.Int32
          description: The hour.
        - id: minute
          type: System.Int32
          description: The minute.
        - id: second
          type: System.Int32
          description: The second.
        - id: millisecond
          type: System.Int32
          description: The millisecond.
        - id: tickWithinMillisecond
          type: System.Int32
          description: The tick within millisecond.
        - id: calendar
          type: NodaTime.CalendarSystem
          description: The calendar.
      overload: NodaTime.LocalDateTime.#ctor*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">calendar</span> is null.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The parameters do not form a valid date/time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDateTime.Calendar
      commentId: P:NodaTime.LocalDateTime.Calendar
      language: CSharp
      name:
        CSharp: Calendar
        VB: Calendar
      nameWithType:
        CSharp: LocalDateTime.Calendar
        VB: LocalDateTime.Calendar
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Calendar
        VB: NodaTime.LocalDateTime.Calendar
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Calendar
        path: src/NodaTime/LocalDateTime.cs
        startLine: 234
      summary: Gets the calendar system associated with this local date and time.
      example: []
      syntax:
        content:
          CSharp: public CalendarSystem Calendar { get; }
          VB: Public ReadOnly Property Calendar As CalendarSystem
        parameters: []
        return:
          type: NodaTime.CalendarSystem
      overload: NodaTime.LocalDateTime.Calendar*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.CenturyOfEra
      commentId: P:NodaTime.LocalDateTime.CenturyOfEra
      language: CSharp
      name:
        CSharp: CenturyOfEra
        VB: CenturyOfEra
      nameWithType:
        CSharp: LocalDateTime.CenturyOfEra
        VB: LocalDateTime.CenturyOfEra
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.CenturyOfEra
        VB: NodaTime.LocalDateTime.CenturyOfEra
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CenturyOfEra
        path: src/NodaTime/LocalDateTime.cs
        startLine: 240
      summary: Gets the century within the era of this local date and time.
      example: []
      syntax:
        content:
          CSharp: public int CenturyOfEra { get; }
          VB: Public ReadOnly Property CenturyOfEra As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.CenturyOfEra*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.Year
      commentId: P:NodaTime.LocalDateTime.Year
      language: CSharp
      name:
        CSharp: Year
        VB: Year
      nameWithType:
        CSharp: LocalDateTime.Year
        VB: LocalDateTime.Year
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Year
        VB: NodaTime.LocalDateTime.Year
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Year
        path: src/NodaTime/LocalDateTime.cs
        startLine: 245
      summary: Gets the year of this local date and time.
      remarks: >-
        This returns the "absolute year", so, for the ISO calendar,

        a value of 0 means 1 BC, for example.
      example: []
      syntax:
        content:
          CSharp: public int Year { get; }
          VB: Public ReadOnly Property Year As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.Year*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.YearOfCentury
      commentId: P:NodaTime.LocalDateTime.YearOfCentury
      language: CSharp
      name:
        CSharp: YearOfCentury
        VB: YearOfCentury
      nameWithType:
        CSharp: LocalDateTime.YearOfCentury
        VB: LocalDateTime.YearOfCentury
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.YearOfCentury
        VB: NodaTime.LocalDateTime.YearOfCentury
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: YearOfCentury
        path: src/NodaTime/LocalDateTime.cs
        startLine: 249
      summary: Gets the year of this local date and time within its century.
      remarks: This always returns a value in the range 0 to 99 inclusive.
      example: []
      syntax:
        content:
          CSharp: public int YearOfCentury { get; }
          VB: Public ReadOnly Property YearOfCentury As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.YearOfCentury*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.YearOfEra
      commentId: P:NodaTime.LocalDateTime.YearOfEra
      language: CSharp
      name:
        CSharp: YearOfEra
        VB: YearOfEra
      nameWithType:
        CSharp: LocalDateTime.YearOfEra
        VB: LocalDateTime.YearOfEra
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.YearOfEra
        VB: NodaTime.LocalDateTime.YearOfEra
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: YearOfEra
        path: src/NodaTime/LocalDateTime.cs
        startLine: 252
      summary: Gets the year of this local date and time within its era.
      example: []
      syntax:
        content:
          CSharp: public int YearOfEra { get; }
          VB: Public ReadOnly Property YearOfEra As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.YearOfEra*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.Era
      commentId: P:NodaTime.LocalDateTime.Era
      language: CSharp
      name:
        CSharp: Era
        VB: Era
      nameWithType:
        CSharp: LocalDateTime.Era
        VB: LocalDateTime.Era
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Era
        VB: NodaTime.LocalDateTime.Era
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Era
        path: src/NodaTime/LocalDateTime.cs
        startLine: 255
      summary: Gets the era of this local date and time.
      example: []
      syntax:
        content:
          CSharp: public Era Era { get; }
          VB: Public ReadOnly Property Era As Era
        parameters: []
        return:
          type: NodaTime.Calendars.Era
      overload: NodaTime.LocalDateTime.Era*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.WeekYear
      commentId: P:NodaTime.LocalDateTime.WeekYear
      language: CSharp
      name:
        CSharp: WeekYear
        VB: WeekYear
      nameWithType:
        CSharp: LocalDateTime.WeekYear
        VB: LocalDateTime.WeekYear
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.WeekYear
        VB: NodaTime.LocalDateTime.WeekYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WeekYear
        path: src/NodaTime/LocalDateTime.cs
        startLine: 275
      summary: "\nGets the \"week year\" of this local date and time.\n"
      remarks: "\n<p>\nThe WeekYear is the year that matches with the <xref href=\"NodaTime.LocalDateTime.WeekOfWeekYear\" data-throw-if-not-resolved=\"false\"></xref> field.\nIn the standard ISO8601 week algorithm, the first week of the year\nis that in which at least 4 days are in the year. As a result of this\ndefinition, day 1 of the first week may be in the previous year.\nThe WeekYear allows you to query the effective year for that day.\n</p>\n<p>\nFor example, January 1st 2011 was a Saturday, so only two days of that week\n(Saturday and Sunday) were in 2011. Therefore January 1st is part of\nweek 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,\nso is part of week 1 of WeekYear 2013.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public int WeekYear { get; }
          VB: Public ReadOnly Property WeekYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.WeekYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDateTime.WeekOfWeekYear: 
    - id: NodaTime.LocalDateTime.Month
      commentId: P:NodaTime.LocalDateTime.Month
      language: CSharp
      name:
        CSharp: Month
        VB: Month
      nameWithType:
        CSharp: LocalDateTime.Month
        VB: LocalDateTime.Month
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Month
        VB: NodaTime.LocalDateTime.Month
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Month
        path: src/NodaTime/LocalDateTime.cs
        startLine: 280
      summary: "\nGets the month of this local date and time within the year.\n"
      example: []
      syntax:
        content:
          CSharp: public int Month { get; }
          VB: Public ReadOnly Property Month As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.Month*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.WeekOfWeekYear
      commentId: P:NodaTime.LocalDateTime.WeekOfWeekYear
      language: CSharp
      name:
        CSharp: WeekOfWeekYear
        VB: WeekOfWeekYear
      nameWithType:
        CSharp: LocalDateTime.WeekOfWeekYear
        VB: LocalDateTime.WeekOfWeekYear
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.WeekOfWeekYear
        VB: NodaTime.LocalDateTime.WeekOfWeekYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WeekOfWeekYear
        path: src/NodaTime/LocalDateTime.cs
        startLine: 285
      summary: "\nGets the week within the WeekYear. See <xref href=\"NodaTime.LocalDateTime.WeekYear\" data-throw-if-not-resolved=\"false\"></xref> for more details.\n"
      example: []
      syntax:
        content:
          CSharp: public int WeekOfWeekYear { get; }
          VB: Public ReadOnly Property WeekOfWeekYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.WeekOfWeekYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDateTime.WeekYear: 
    - id: NodaTime.LocalDateTime.DayOfYear
      commentId: P:NodaTime.LocalDateTime.DayOfYear
      language: CSharp
      name:
        CSharp: DayOfYear
        VB: DayOfYear
      nameWithType:
        CSharp: LocalDateTime.DayOfYear
        VB: LocalDateTime.DayOfYear
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.DayOfYear
        VB: NodaTime.LocalDateTime.DayOfYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DayOfYear
        path: src/NodaTime/LocalDateTime.cs
        startLine: 290
      summary: "\nGets the day of this local date and time within the year.\n"
      example: []
      syntax:
        content:
          CSharp: public int DayOfYear { get; }
          VB: Public ReadOnly Property DayOfYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.DayOfYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.Day
      commentId: P:NodaTime.LocalDateTime.Day
      language: CSharp
      name:
        CSharp: Day
        VB: Day
      nameWithType:
        CSharp: LocalDateTime.Day
        VB: LocalDateTime.Day
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Day
        VB: NodaTime.LocalDateTime.Day
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Day
        path: src/NodaTime/LocalDateTime.cs
        startLine: 295
      summary: "\nGets the day of this local date and time within the month.\n"
      example: []
      syntax:
        content:
          CSharp: public int Day { get; }
          VB: Public ReadOnly Property Day As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.Day*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.IsoDayOfWeek
      commentId: P:NodaTime.LocalDateTime.IsoDayOfWeek
      language: CSharp
      name:
        CSharp: IsoDayOfWeek
        VB: IsoDayOfWeek
      nameWithType:
        CSharp: LocalDateTime.IsoDayOfWeek
        VB: LocalDateTime.IsoDayOfWeek
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.IsoDayOfWeek
        VB: NodaTime.LocalDateTime.IsoDayOfWeek
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: IsoDayOfWeek
        path: src/NodaTime/LocalDateTime.cs
        startLine: 303
      summary: "\nGets the week day of this local date and time expressed as an <xref href=\"NodaTime.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref> value,\nfor calendars which use ISO days of the week.\n"
      example: []
      syntax:
        content:
          CSharp: public IsoDayOfWeek IsoDayOfWeek { get; }
          VB: Public ReadOnly Property IsoDayOfWeek As IsoDayOfWeek
        parameters: []
        return:
          type: NodaTime.IsoDayOfWeek
      overload: NodaTime.LocalDateTime.IsoDayOfWeek*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The underlying calendar doesn't use ISO days of the week.
      seealso:
      - linkId: NodaTime.LocalDateTime.DayOfWeek
        commentId: P:NodaTime.LocalDateTime.DayOfWeek
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.IsoDayOfWeek: 
        NodaTime.LocalDateTime.DayOfWeek: 
    - id: NodaTime.LocalDateTime.DayOfWeek
      commentId: P:NodaTime.LocalDateTime.DayOfWeek
      language: CSharp
      name:
        CSharp: DayOfWeek
        VB: DayOfWeek
      nameWithType:
        CSharp: LocalDateTime.DayOfWeek
        VB: LocalDateTime.DayOfWeek
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.DayOfWeek
        VB: NodaTime.LocalDateTime.DayOfWeek
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DayOfWeek
        path: src/NodaTime/LocalDateTime.cs
        startLine: 312
      summary: "\nGets the week day of this local date and time as a number.\n"
      remarks: "\nFor calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.\n"
      example: []
      syntax:
        content:
          CSharp: public int DayOfWeek { get; }
          VB: Public ReadOnly Property DayOfWeek As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.DayOfWeek*
      seealso:
      - linkId: NodaTime.LocalDateTime.IsoDayOfWeek
        commentId: P:NodaTime.LocalDateTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDateTime.IsoDayOfWeek: 
    - id: NodaTime.LocalDateTime.Hour
      commentId: P:NodaTime.LocalDateTime.Hour
      language: CSharp
      name:
        CSharp: Hour
        VB: Hour
      nameWithType:
        CSharp: LocalDateTime.Hour
        VB: LocalDateTime.Hour
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Hour
        VB: NodaTime.LocalDateTime.Hour
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Hour
        path: src/NodaTime/LocalDateTime.cs
        startLine: 317
      summary: "\nGets the hour of day of this local date and time, in the range 0 to 23 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Hour { get; }
          VB: Public ReadOnly Property Hour As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.Hour*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.ClockHourOfHalfDay
      commentId: P:NodaTime.LocalDateTime.ClockHourOfHalfDay
      language: CSharp
      name:
        CSharp: ClockHourOfHalfDay
        VB: ClockHourOfHalfDay
      nameWithType:
        CSharp: LocalDateTime.ClockHourOfHalfDay
        VB: LocalDateTime.ClockHourOfHalfDay
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.ClockHourOfHalfDay
        VB: NodaTime.LocalDateTime.ClockHourOfHalfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ClockHourOfHalfDay
        path: src/NodaTime/LocalDateTime.cs
        startLine: 322
      summary: "\nGets the hour of the half-day of this local date and time, in the range 1 to 12 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int ClockHourOfHalfDay { get; }
          VB: Public ReadOnly Property ClockHourOfHalfDay As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.ClockHourOfHalfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.Minute
      commentId: P:NodaTime.LocalDateTime.Minute
      language: CSharp
      name:
        CSharp: Minute
        VB: Minute
      nameWithType:
        CSharp: LocalDateTime.Minute
        VB: LocalDateTime.Minute
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Minute
        VB: NodaTime.LocalDateTime.Minute
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minute
        path: src/NodaTime/LocalDateTime.cs
        startLine: 327
      summary: "\nGets the minute of this local date and time, in the range 0 to 59 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Minute { get; }
          VB: Public ReadOnly Property Minute As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.Minute*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.Second
      commentId: P:NodaTime.LocalDateTime.Second
      language: CSharp
      name:
        CSharp: Second
        VB: Second
      nameWithType:
        CSharp: LocalDateTime.Second
        VB: LocalDateTime.Second
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Second
        VB: NodaTime.LocalDateTime.Second
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Second
        path: src/NodaTime/LocalDateTime.cs
        startLine: 332
      summary: "\nGets the second of this local date and time within the minute, in the range 0 to 59 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Second { get; }
          VB: Public ReadOnly Property Second As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.Second*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.Millisecond
      commentId: P:NodaTime.LocalDateTime.Millisecond
      language: CSharp
      name:
        CSharp: Millisecond
        VB: Millisecond
      nameWithType:
        CSharp: LocalDateTime.Millisecond
        VB: LocalDateTime.Millisecond
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Millisecond
        VB: NodaTime.LocalDateTime.Millisecond
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Millisecond
        path: src/NodaTime/LocalDateTime.cs
        startLine: 337
      summary: "\nGets the millisecond of this local date and time within the second, in the range 0 to 999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Millisecond { get; }
          VB: Public ReadOnly Property Millisecond As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.Millisecond*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.TickOfSecond
      commentId: P:NodaTime.LocalDateTime.TickOfSecond
      language: CSharp
      name:
        CSharp: TickOfSecond
        VB: TickOfSecond
      nameWithType:
        CSharp: LocalDateTime.TickOfSecond
        VB: LocalDateTime.TickOfSecond
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.TickOfSecond
        VB: NodaTime.LocalDateTime.TickOfSecond
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TickOfSecond
        path: src/NodaTime/LocalDateTime.cs
        startLine: 342
      summary: "\nGets the tick of this local time within the second, in the range 0 to 9,999,999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int TickOfSecond { get; }
          VB: Public ReadOnly Property TickOfSecond As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.LocalDateTime.TickOfSecond*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.TickOfDay
      commentId: P:NodaTime.LocalDateTime.TickOfDay
      language: CSharp
      name:
        CSharp: TickOfDay
        VB: TickOfDay
      nameWithType:
        CSharp: LocalDateTime.TickOfDay
        VB: LocalDateTime.TickOfDay
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.TickOfDay
        VB: NodaTime.LocalDateTime.TickOfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TickOfDay
        path: src/NodaTime/LocalDateTime.cs
        startLine: 347
      summary: "\nGets the tick of this local date and time within the day, in the range 0 to 863,999,999,999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public long TickOfDay { get; }
          VB: Public ReadOnly Property TickOfDay As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.LocalDateTime.TickOfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.LocalDateTime.TimeOfDay
      commentId: P:NodaTime.LocalDateTime.TimeOfDay
      language: CSharp
      name:
        CSharp: TimeOfDay
        VB: TimeOfDay
      nameWithType:
        CSharp: LocalDateTime.TimeOfDay
        VB: LocalDateTime.TimeOfDay
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.TimeOfDay
        VB: NodaTime.LocalDateTime.TimeOfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TimeOfDay
        path: src/NodaTime/LocalDateTime.cs
        startLine: 352
      summary: "\nGets the time portion of this local date and time as a <xref href=\"NodaTime.LocalTime\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime TimeOfDay { get; }
          VB: Public ReadOnly Property TimeOfDay As LocalTime
        parameters: []
        return:
          type: NodaTime.LocalTime
      overload: NodaTime.LocalDateTime.TimeOfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalTime: 
    - id: NodaTime.LocalDateTime.Date
      commentId: P:NodaTime.LocalDateTime.Date
      language: CSharp
      name:
        CSharp: Date
        VB: Date
      nameWithType:
        CSharp: LocalDateTime.Date
        VB: LocalDateTime.Date
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Date
        VB: NodaTime.LocalDateTime.Date
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Date
        path: src/NodaTime/LocalDateTime.cs
        startLine: 368
      summary: "\nGets the date portion of this local date and time as a <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref> in the same calendar system as this value.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate Date { get; }
          VB: Public ReadOnly Property Date As LocalDate
        parameters: []
        return:
          type: NodaTime.LocalDate
      overload: NodaTime.LocalDateTime.Date*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDate: 
    - id: NodaTime.LocalDateTime.ToDateTimeUnspecified
      commentId: M:NodaTime.LocalDateTime.ToDateTimeUnspecified
      language: CSharp
      name:
        CSharp: ToDateTimeUnspecified()
        VB: ToDateTimeUnspecified()
      nameWithType:
        CSharp: LocalDateTime.ToDateTimeUnspecified()
        VB: LocalDateTime.ToDateTimeUnspecified()
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.ToDateTimeUnspecified()
        VB: NodaTime.LocalDateTime.ToDateTimeUnspecified()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToDateTimeUnspecified
        path: src/NodaTime/LocalDateTime.cs
        startLine: 394
      summary: "\nConstructs a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> from this value which has a <xref href=\"System.DateTime.Kind\" data-throw-if-not-resolved=\"false\"></xref>\nof <xref href=\"System.DateTimeKind.Unspecified\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      remarks: "\n<xref href=\"System.DateTimeKind.Unspecified\" data-throw-if-not-resolved=\"false\"></xref> is slightly odd - it can be treated as UTC if you use <xref href=\"System.DateTime.ToLocalTime\" data-throw-if-not-resolved=\"false\"></xref>\nor as system local time if you use <xref href=\"System.DateTime.ToUniversalTime\" data-throw-if-not-resolved=\"false\"></xref>, but it's the only kind which allows\nyou to construct a <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> with an arbitrary offset, which makes it as close to\nthe Noda Time non-system-specific \"local\" concept as exists in .NET.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTime ToDateTimeUnspecified()
          VB: Public Function ToDateTimeUnspecified As Date
        return:
          type: System.DateTime
          description: A <xref href="System.DateTime" data-throw-if-not-resolved="false"></xref> value for the same date and time as this value.
      overload: NodaTime.LocalDateTime.ToDateTimeUnspecified*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.DateTime: 
        System.DateTime.Kind: 
        System.DateTimeKind.Unspecified: 
        System.DateTime.ToLocalTime: 
        System.DateTime.ToUniversalTime: 
        System.DateTimeOffset: 
    - id: NodaTime.LocalDateTime.FromDateTime(System.DateTime)
      commentId: M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)
      language: CSharp
      name:
        CSharp: FromDateTime(DateTime)
        VB: FromDateTime(DateTime)
      nameWithType:
        CSharp: LocalDateTime.FromDateTime(DateTime)
        VB: LocalDateTime.FromDateTime(DateTime)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.FromDateTime(System.DateTime)
        VB: NodaTime.LocalDateTime.FromDateTime(System.DateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromDateTime
        path: src/NodaTime/LocalDateTime.cs
        startLine: 406
      summary: "\nConverts a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> of any kind to a LocalDateTime in the ISO calendar. This does not perform\nany time zone conversions, so a DateTime with a <xref href=\"System.DateTime.Kind\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTimeKind.Utc\" data-throw-if-not-resolved=\"false\"></xref>\nwill still have the same day/hour/minute etc - it won't be converted into the local system time.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTime FromDateTime(DateTime dateTime)
          VB: Public Shared Function FromDateTime(dateTime As Date) As LocalDateTime
        parameters:
        - id: dateTime
          type: System.DateTime
          description: Value to convert into a Noda Time local date and time
        return:
          type: NodaTime.LocalDateTime
          description: A new <xref href="NodaTime.LocalDateTime" data-throw-if-not-resolved="false"></xref> with the same values as the specified <code>DateTime</code>.
      overload: NodaTime.LocalDateTime.FromDateTime*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.DateTime: 
        System.DateTime.Kind: 
        System.DateTimeKind.Utc: 
        NodaTime.LocalDateTime: 
    - id: NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)
      commentId: M:NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: Equals(LocalDateTime)
        VB: Equals(LocalDateTime)
      nameWithType:
        CSharp: LocalDateTime.Equals(LocalDateTime)
        VB: LocalDateTime.Equals(LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)
        VB: NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/LocalDateTime.cs
        startLine: 419
      summary: "\nIndicates whether the current object is equal to another object of the same type.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(LocalDateTime other)
          VB: Public Function Equals(other As LocalDateTime) As Boolean
        parameters:
        - id: other
          type: NodaTime.LocalDateTime
          description: An object to compare with this object.
        return:
          type: System.Boolean
          description: "\ntrue if the current object is equal to the <span class=\"paramref\">other</span> parameter; otherwise, false.\n"
      overload: NodaTime.LocalDateTime.Equals*
      implements:
      - System.IEquatable{NodaTime.LocalDateTime}.Equals(NodaTime.LocalDateTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.op_Equality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      commentId: M:NodaTime.LocalDateTime.op_Equality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: Equality(LocalDateTime, LocalDateTime)
        VB: Equality(LocalDateTime, LocalDateTime)
      nameWithType:
        CSharp: LocalDateTime.Equality(LocalDateTime, LocalDateTime)
        VB: LocalDateTime.Equality(LocalDateTime, LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Equality(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
        VB: NodaTime.LocalDateTime.Equality(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Equality
        path: src/NodaTime/LocalDateTime.cs
        startLine: 432
      summary: "\nImplements the operator == (equality).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator ==(LocalDateTime left, LocalDateTime right)
          VB: Public Shared Operator =(left As LocalDateTime, right As LocalDateTime) As Boolean
        parameters:
        - id: left
          type: NodaTime.LocalDateTime
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.LocalDateTime
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if values are equal to each other, otherwise <code>false</code>.
      overload: NodaTime.LocalDateTime.op_Equality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      commentId: M:NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: Inequality(LocalDateTime, LocalDateTime)
        VB: Inequality(LocalDateTime, LocalDateTime)
      nameWithType:
        CSharp: LocalDateTime.Inequality(LocalDateTime, LocalDateTime)
        VB: LocalDateTime.Inequality(LocalDateTime, LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Inequality(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
        VB: NodaTime.LocalDateTime.Inequality(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Inequality
        path: src/NodaTime/LocalDateTime.cs
        startLine: 443
      summary: "\nImplements the operator != (inequality).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator !=(LocalDateTime left, LocalDateTime right)
          VB: Public Shared Operator <>(left As LocalDateTime, right As LocalDateTime) As Boolean
        parameters:
        - id: left
          type: NodaTime.LocalDateTime
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.LocalDateTime
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if values are not equal to each other, otherwise <code>false</code>.
      overload: NodaTime.LocalDateTime.op_Inequality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDateTime.op_LessThan(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      commentId: M:NodaTime.LocalDateTime.op_LessThan(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: LessThan(LocalDateTime, LocalDateTime)
        VB: LessThan(LocalDateTime, LocalDateTime)
      nameWithType:
        CSharp: LocalDateTime.LessThan(LocalDateTime, LocalDateTime)
        VB: LocalDateTime.LessThan(LocalDateTime, LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.LessThan(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
        VB: NodaTime.LocalDateTime.LessThan(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThan
        path: src/NodaTime/LocalDateTime.cs
        startLine: 459
      summary: "\nCompares two LocalDateTime values to see if the left one is strictly earlier than the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars. See the top-level type\ndocumentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <(LocalDateTime lhs, LocalDateTime rhs)
          VB: Public Shared Operator <(lhs As LocalDateTime, rhs As LocalDateTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalDateTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalDateTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is strictly earlier than <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalDateTime.op_LessThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDateTime.op_LessThanOrEqual(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      commentId: M:NodaTime.LocalDateTime.op_LessThanOrEqual(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: LessThanOrEqual(LocalDateTime, LocalDateTime)
        VB: LessThanOrEqual(LocalDateTime, LocalDateTime)
      nameWithType:
        CSharp: LocalDateTime.LessThanOrEqual(LocalDateTime, LocalDateTime)
        VB: LocalDateTime.LessThanOrEqual(LocalDateTime, LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.LessThanOrEqual(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
        VB: NodaTime.LocalDateTime.LessThanOrEqual(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThanOrEqual
        path: src/NodaTime/LocalDateTime.cs
        startLine: 475
      summary: "\nCompares two LocalDateTime values to see if the left one is earlier than or equal to the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars. See the top-level type\ndocumentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <=(LocalDateTime lhs, LocalDateTime rhs)
          VB: Public Shared Operator <=(lhs As LocalDateTime, rhs As LocalDateTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalDateTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalDateTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is earlier than or equal to <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalDateTime.op_LessThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDateTime.op_GreaterThan(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      commentId: M:NodaTime.LocalDateTime.op_GreaterThan(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: GreaterThan(LocalDateTime, LocalDateTime)
        VB: GreaterThan(LocalDateTime, LocalDateTime)
      nameWithType:
        CSharp: LocalDateTime.GreaterThan(LocalDateTime, LocalDateTime)
        VB: LocalDateTime.GreaterThan(LocalDateTime, LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.GreaterThan(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
        VB: NodaTime.LocalDateTime.GreaterThan(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThan
        path: src/NodaTime/LocalDateTime.cs
        startLine: 491
      summary: "\nCompares two LocalDateTime values to see if the left one is strictly later than the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars. See the top-level type\ndocumentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator>(LocalDateTime lhs, LocalDateTime rhs)
          VB: Public Shared Operator>(lhs As LocalDateTime, rhs As LocalDateTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalDateTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalDateTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is strictly later than <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalDateTime.op_GreaterThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDateTime.op_GreaterThanOrEqual(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      commentId: M:NodaTime.LocalDateTime.op_GreaterThanOrEqual(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: GreaterThanOrEqual(LocalDateTime, LocalDateTime)
        VB: GreaterThanOrEqual(LocalDateTime, LocalDateTime)
      nameWithType:
        CSharp: LocalDateTime.GreaterThanOrEqual(LocalDateTime, LocalDateTime)
        VB: LocalDateTime.GreaterThanOrEqual(LocalDateTime, LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.GreaterThanOrEqual(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
        VB: NodaTime.LocalDateTime.GreaterThanOrEqual(NodaTime.LocalDateTime, NodaTime.LocalDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThanOrEqual
        path: src/NodaTime/LocalDateTime.cs
        startLine: 507
      summary: "\nCompares two LocalDateTime values to see if the left one is later than or equal to the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars. See the top-level type\ndocumentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator >=(LocalDateTime lhs, LocalDateTime rhs)
          VB: Public Shared Operator >=(lhs As LocalDateTime, rhs As LocalDateTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.LocalDateTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.LocalDateTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is later than or equal to <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.LocalDateTime.op_GreaterThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)
      commentId: M:NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: CompareTo(LocalDateTime)
        VB: CompareTo(LocalDateTime)
      nameWithType:
        CSharp: LocalDateTime.CompareTo(LocalDateTime)
        VB: LocalDateTime.CompareTo(LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)
        VB: NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CompareTo
        path: src/NodaTime/LocalDateTime.cs
        startLine: 526
      summary: "\nIndicates whether this date/time is earlier, later or the same as another one.\n"
      remarks: "\nThe comparison is performed in terms of a calendar-independent notion of dates and times;\nthe calendar systems of both <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> values are ignored. When both values use the same calendar,\nthis is absolutely natural. However, when comparing a value in one calendar with a value in another,\nthis can lead to surprising results. For example, 1945 in the ISO calendar corresponds to around 1364\nin the Islamic calendar, so an Islamic date in year 1400 is \"after\" a date in 1945 in the ISO calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public int CompareTo(LocalDateTime other)
          VB: Public Function CompareTo(other As LocalDateTime) As Integer
        parameters:
        - id: other
          type: NodaTime.LocalDateTime
          description: The other local date/time to compare with this value.
        return:
          type: System.Int32
          description: >-
            A value less than zero if this date/time is earlier than <span class="paramref">other</span>;

            zero if this date/time is the same as <span class="paramref">other</span>; a value greater than zero if this date/time is

            later than <span class="paramref">other</span>.
      overload: NodaTime.LocalDateTime.CompareTo*
      implements:
      - System.IComparable{NodaTime.LocalDateTime}.CompareTo(NodaTime.LocalDateTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
    - isEii: true
      id: NodaTime.LocalDateTime.System#IComparable#CompareTo(System.Object)
      commentId: M:NodaTime.LocalDateTime.System#IComparable#CompareTo(System.Object)
      language: CSharp
      name:
        CSharp: IComparable.CompareTo(Object)
        VB: System.IComparable.CompareTo(Object)
      nameWithType:
        CSharp: LocalDateTime.IComparable.CompareTo(Object)
        VB: LocalDateTime.System.IComparable.CompareTo(Object)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.System.IComparable.CompareTo(System.Object)
        VB: NodaTime.LocalDateTime.System.IComparable.CompareTo(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.IComparable.CompareTo
        path: src/NodaTime/LocalDateTime.cs
        startLine: 542
      summary: "\nImplementation of <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to compare two LocalDateTimes.\n"
      remarks: "\nThis uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.\n"
      example: []
      syntax:
        content:
          CSharp: int IComparable.CompareTo(object obj)
          VB: Function System.IComparable.CompareTo(obj As Object) As Integer Implements IComparable.CompareTo
        parameters:
        - id: obj
          type: System.Object
          description: The object to compare this value with.
        return:
          type: System.Int32
          description: >
            The result of comparing this LocalDateTime with another one; see <xref href="NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)" data-throw-if-not-resolved="false"></xref> for general details.

            If <span class="paramref">obj</span> is null, this method returns a value greater than 0.
      overload: NodaTime.LocalDateTime.System#IComparable#CompareTo*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">obj</span> is non-null but does not refer to an instance of <xref href="NodaTime.LocalDateTime" data-throw-if-not-resolved="false"></xref>.
      implements:
      - System.IComparable.CompareTo(System.Object)
      modifiers:
        CSharp: []
        VB: []
      references:
        System.IComparable.CompareTo(System.Object): 
        NodaTime.LocalDateTime: 
        NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime): 
    - id: NodaTime.LocalDateTime.op_Addition(NodaTime.LocalDateTime,NodaTime.Period)
      commentId: M:NodaTime.LocalDateTime.op_Addition(NodaTime.LocalDateTime,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Addition(LocalDateTime, Period)
        VB: Addition(LocalDateTime, Period)
      nameWithType:
        CSharp: LocalDateTime.Addition(LocalDateTime, Period)
        VB: LocalDateTime.Addition(LocalDateTime, Period)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Addition(NodaTime.LocalDateTime, NodaTime.Period)
        VB: NodaTime.LocalDateTime.Addition(NodaTime.LocalDateTime, NodaTime.Period)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Addition
        path: src/NodaTime/LocalDateTime.cs
        startLine: 559
      summary: "\nAdds a period to a local date/time. Fields are added in the order provided by the period.\nThis is a convenience operator over the <xref href=\"NodaTime.LocalDateTime.Plus(NodaTime.Period)\" data-throw-if-not-resolved=\"false\"></xref> method.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTime operator +(LocalDateTime localDateTime, Period period)
          VB: Public Shared Operator +(localDateTime As LocalDateTime, period As Period) As LocalDateTime
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: Initial local date and time
        - id: period
          type: NodaTime.Period
          description: Period to add
        return:
          type: NodaTime.LocalDateTime
          description: The resulting local date and time
      overload: NodaTime.LocalDateTime.op_Addition*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.LocalDateTime.Plus(NodaTime.Period): 
    - id: NodaTime.LocalDateTime.Add(NodaTime.LocalDateTime,NodaTime.Period)
      commentId: M:NodaTime.LocalDateTime.Add(NodaTime.LocalDateTime,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Add(LocalDateTime, Period)
        VB: Add(LocalDateTime, Period)
      nameWithType:
        CSharp: LocalDateTime.Add(LocalDateTime, Period)
        VB: LocalDateTime.Add(LocalDateTime, Period)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Add(NodaTime.LocalDateTime, NodaTime.Period)
        VB: NodaTime.LocalDateTime.Add(NodaTime.LocalDateTime, NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Add
        path: src/NodaTime/LocalDateTime.cs
        startLine: 570
      summary: "\nAdd the specified period to the date and time. Friendly alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTime Add(LocalDateTime localDateTime, Period period)
          VB: Public Shared Function Add(localDateTime As LocalDateTime, period As Period) As LocalDateTime
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: Initial local date and time
        - id: period
          type: NodaTime.Period
          description: Period to add
        return:
          type: NodaTime.LocalDateTime
          description: The resulting local date and time
      overload: NodaTime.LocalDateTime.Add*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDateTime.Plus(NodaTime.Period)
      commentId: M:NodaTime.LocalDateTime.Plus(NodaTime.Period)
      language: CSharp
      name:
        CSharp: Plus(Period)
        VB: Plus(Period)
      nameWithType:
        CSharp: LocalDateTime.Plus(Period)
        VB: LocalDateTime.Plus(Period)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Plus(NodaTime.Period)
        VB: NodaTime.LocalDateTime.Plus(NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Plus
        path: src/NodaTime/LocalDateTime.cs
        startLine: 580
      summary: "\nAdds a period to this local date/time. Fields are added in the order provided by the period.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime Plus(Period period)
          VB: Public Function Plus(period As Period) As LocalDateTime
        parameters:
        - id: period
          type: NodaTime.Period
          description: Period to add
        return:
          type: NodaTime.LocalDateTime
          description: The resulting local date and time
      overload: NodaTime.LocalDateTime.Plus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.op_Subtraction(NodaTime.LocalDateTime,NodaTime.Period)
      commentId: M:NodaTime.LocalDateTime.op_Subtraction(NodaTime.LocalDateTime,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Subtraction(LocalDateTime, Period)
        VB: Subtraction(LocalDateTime, Period)
      nameWithType:
        CSharp: LocalDateTime.Subtraction(LocalDateTime, Period)
        VB: LocalDateTime.Subtraction(LocalDateTime, Period)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Subtraction(NodaTime.LocalDateTime, NodaTime.Period)
        VB: NodaTime.LocalDateTime.Subtraction(NodaTime.LocalDateTime, NodaTime.Period)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Subtraction
        path: src/NodaTime/LocalDateTime.cs
        startLine: 593
      summary: "\nSubtracts a period from a local date/time. Fields are subtracted in the order provided by the period.\nThis is a convenience operator over the <xref href=\"NodaTime.LocalDateTime.Minus(NodaTime.Period)\" data-throw-if-not-resolved=\"false\"></xref> method.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTime operator -(LocalDateTime localDateTime, Period period)
          VB: Public Shared Operator -(localDateTime As LocalDateTime, period As Period) As LocalDateTime
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: Initial local date and time
        - id: period
          type: NodaTime.Period
          description: Period to subtract
        return:
          type: NodaTime.LocalDateTime
          description: The resulting local date and time
      overload: NodaTime.LocalDateTime.op_Subtraction*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.LocalDateTime.Minus(NodaTime.Period): 
    - id: NodaTime.LocalDateTime.Subtract(NodaTime.LocalDateTime,NodaTime.Period)
      commentId: M:NodaTime.LocalDateTime.Subtract(NodaTime.LocalDateTime,NodaTime.Period)
      language: CSharp
      name:
        CSharp: Subtract(LocalDateTime, Period)
        VB: Subtract(LocalDateTime, Period)
      nameWithType:
        CSharp: LocalDateTime.Subtract(LocalDateTime, Period)
        VB: LocalDateTime.Subtract(LocalDateTime, Period)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Subtract(NodaTime.LocalDateTime, NodaTime.Period)
        VB: NodaTime.LocalDateTime.Subtract(NodaTime.LocalDateTime, NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Subtract
        path: src/NodaTime/LocalDateTime.cs
        startLine: 604
      summary: "\nSubtracts the specified period from the date and time. Friendly alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTime Subtract(LocalDateTime localDateTime, Period period)
          VB: Public Shared Function Subtract(localDateTime As LocalDateTime, period As Period) As LocalDateTime
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: Initial local date and time
        - id: period
          type: NodaTime.Period
          description: Period to subtract
        return:
          type: NodaTime.LocalDateTime
          description: The resulting local date and time
      overload: NodaTime.LocalDateTime.Subtract*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.LocalDateTime.Minus(NodaTime.Period)
      commentId: M:NodaTime.LocalDateTime.Minus(NodaTime.Period)
      language: CSharp
      name:
        CSharp: Minus(Period)
        VB: Minus(Period)
      nameWithType:
        CSharp: LocalDateTime.Minus(Period)
        VB: LocalDateTime.Minus(Period)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Minus(NodaTime.Period)
        VB: NodaTime.LocalDateTime.Minus(NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minus
        path: src/NodaTime/LocalDateTime.cs
        startLine: 615
      summary: "\nSubtracts a period from a local date/time. Fields are subtracted in the order provided by the period.\nThis is a convenience operator over the <xref href=\"NodaTime.LocalDateTime.Minus(NodaTime.Period)\" data-throw-if-not-resolved=\"false\"></xref> method.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime Minus(Period period)
          VB: Public Function Minus(period As Period) As LocalDateTime
        parameters:
        - id: period
          type: NodaTime.Period
          description: Period to subtract
        return:
          type: NodaTime.LocalDateTime
          description: The resulting local date and time
      overload: NodaTime.LocalDateTime.Minus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime.Minus(NodaTime.Period): 
    - id: NodaTime.LocalDateTime.Equals(System.Object)
      commentId: M:NodaTime.LocalDateTime.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: LocalDateTime.Equals(Object)
        VB: LocalDateTime.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Equals(System.Object)
        VB: NodaTime.LocalDateTime.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/LocalDateTime.cs
        startLine: 631
      summary: "\nDetermines whether the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: The <xref href="System.Object" data-throw-if-not-resolved="false"></xref> to compare with this instance.
        return:
          type: System.Boolean
          description: "\n<code>true</code> if the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance;\notherwise, <code>false</code>.\n"
      overload: NodaTime.LocalDateTime.Equals*
      overridden: System.ValueType.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.Object: 
    - id: NodaTime.LocalDateTime.GetHashCode
      commentId: M:NodaTime.LocalDateTime.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: LocalDateTime.GetHashCode()
        VB: LocalDateTime.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.GetHashCode()
        VB: NodaTime.LocalDateTime.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/LocalDateTime.cs
        startLine: 647
      summary: "\nReturns a hash code for this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: "\nA hash code for this instance, suitable for use in hashing algorithms and data\nstructures like a hash table. \n"
      overload: NodaTime.LocalDateTime.GetHashCode*
      overridden: System.ValueType.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.LocalDateTime.WithCalendar(NodaTime.CalendarSystem)
      commentId: M:NodaTime.LocalDateTime.WithCalendar(NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: WithCalendar(CalendarSystem)
        VB: WithCalendar(CalendarSystem)
      nameWithType:
        CSharp: LocalDateTime.WithCalendar(CalendarSystem)
        VB: LocalDateTime.WithCalendar(CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.WithCalendar(NodaTime.CalendarSystem)
        VB: NodaTime.LocalDateTime.WithCalendar(NodaTime.CalendarSystem)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCalendar
        path: src/NodaTime/LocalDateTime.cs
        startLine: 664
      summary: "\nCreates a new LocalDateTime representing the same physical date and time, but in a different calendar.\nThe returned LocalDateTime is likely to have different date field values to this one.\nFor example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime WithCalendar(CalendarSystem calendarSystem)
          VB: Public Function WithCalendar(calendarSystem As CalendarSystem) As LocalDateTime
        parameters:
        - id: calendarSystem
          type: NodaTime.CalendarSystem
          description: The calendar system to convert this local date to.
        return:
          type: NodaTime.LocalDateTime
          description: The converted LocalDateTime.
      overload: NodaTime.LocalDateTime.WithCalendar*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">calendarSystem</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.PlusYears(System.Int32)
      commentId: M:NodaTime.LocalDateTime.PlusYears(System.Int32)
      language: CSharp
      name:
        CSharp: PlusYears(Int32)
        VB: PlusYears(Int32)
      nameWithType:
        CSharp: LocalDateTime.PlusYears(Int32)
        VB: LocalDateTime.PlusYears(Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.PlusYears(System.Int32)
        VB: NodaTime.LocalDateTime.PlusYears(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusYears
        path: src/NodaTime/LocalDateTime.cs
        startLine: 680
      summary: "\nReturns a new LocalDateTime representing the current value with the given number of years added.\n"
      remarks: "\nIf the resulting date is invalid, lower fields (typically the day of month) are reduced to find a valid value.\nFor example, adding one year to February 29th 2012 will return February 28th 2013; subtracting one year from\nFebruary 29th 2012 will return February 28th 2011.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime PlusYears(int years)
          VB: Public Function PlusYears(years As Integer) As LocalDateTime
        parameters:
        - id: years
          type: System.Int32
          description: The number of years to add
        return:
          type: NodaTime.LocalDateTime
          description: The current value plus the given number of years.
      overload: NodaTime.LocalDateTime.PlusYears*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.PlusMonths(System.Int32)
      commentId: M:NodaTime.LocalDateTime.PlusMonths(System.Int32)
      language: CSharp
      name:
        CSharp: PlusMonths(Int32)
        VB: PlusMonths(Int32)
      nameWithType:
        CSharp: LocalDateTime.PlusMonths(Int32)
        VB: LocalDateTime.PlusMonths(Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.PlusMonths(System.Int32)
        VB: NodaTime.LocalDateTime.PlusMonths(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusMonths
        path: src/NodaTime/LocalDateTime.cs
        startLine: 702
      summary: "\nReturns a new LocalDateTime representing the current value with the given number of months added.\n"
      remarks: "\n<p>\nThis method does not try to maintain the year of the current value, so adding four months to a value in \nOctober will result in a value in the following February.\n</p>\n<p>\nIf the resulting date is invalid, the day of month is reduced to find a valid value.\nFor example, adding one month to January 30th 2011 will return February 28th 2011; subtracting one month from\nMarch 30th 2011 will return February 28th 2011.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime PlusMonths(int months)
          VB: Public Function PlusMonths(months As Integer) As LocalDateTime
        parameters:
        - id: months
          type: System.Int32
          description: The number of months to add
        return:
          type: NodaTime.LocalDateTime
          description: The current value plus the given number of months.
      overload: NodaTime.LocalDateTime.PlusMonths*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.PlusDays(System.Int32)
      commentId: M:NodaTime.LocalDateTime.PlusDays(System.Int32)
      language: CSharp
      name:
        CSharp: PlusDays(Int32)
        VB: PlusDays(Int32)
      nameWithType:
        CSharp: LocalDateTime.PlusDays(Int32)
        VB: LocalDateTime.PlusDays(Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.PlusDays(System.Int32)
        VB: NodaTime.LocalDateTime.PlusDays(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusDays
        path: src/NodaTime/LocalDateTime.cs
        startLine: 719
      summary: "\nReturns a new LocalDateTime representing the current value with the given number of days added.\n"
      remarks: "\n<p>\nThis method does not try to maintain the month or year of the current value, so adding 3 days to a value on January 30th\nwill result in a value on February 2nd.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime PlusDays(int days)
          VB: Public Function PlusDays(days As Integer) As LocalDateTime
        parameters:
        - id: days
          type: System.Int32
          description: The number of days to add
        return:
          type: NodaTime.LocalDateTime
          description: The current value plus the given number of days.
      overload: NodaTime.LocalDateTime.PlusDays*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.PlusWeeks(System.Int32)
      commentId: M:NodaTime.LocalDateTime.PlusWeeks(System.Int32)
      language: CSharp
      name:
        CSharp: PlusWeeks(Int32)
        VB: PlusWeeks(Int32)
      nameWithType:
        CSharp: LocalDateTime.PlusWeeks(Int32)
        VB: LocalDateTime.PlusWeeks(Int32)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.PlusWeeks(System.Int32)
        VB: NodaTime.LocalDateTime.PlusWeeks(System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusWeeks
        path: src/NodaTime/LocalDateTime.cs
        startLine: 730
      summary: "\nReturns a new LocalDateTime representing the current value with the given number of weeks added.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime PlusWeeks(int weeks)
          VB: Public Function PlusWeeks(weeks As Integer) As LocalDateTime
        parameters:
        - id: weeks
          type: System.Int32
          description: The number of weeks to add
        return:
          type: NodaTime.LocalDateTime
          description: The current value plus the given number of weeks.
      overload: NodaTime.LocalDateTime.PlusWeeks*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.PlusHours(System.Int64)
      commentId: M:NodaTime.LocalDateTime.PlusHours(System.Int64)
      language: CSharp
      name:
        CSharp: PlusHours(Int64)
        VB: PlusHours(Int64)
      nameWithType:
        CSharp: LocalDateTime.PlusHours(Int64)
        VB: LocalDateTime.PlusHours(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.PlusHours(System.Int64)
        VB: NodaTime.LocalDateTime.PlusHours(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusHours
        path: src/NodaTime/LocalDateTime.cs
        startLine: 741
      summary: "\nReturns a new LocalDateTime representing the current value with the given number of hours added.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime PlusHours(long hours)
          VB: Public Function PlusHours(hours As Long) As LocalDateTime
        parameters:
        - id: hours
          type: System.Int64
          description: The number of hours to add
        return:
          type: NodaTime.LocalDateTime
          description: The current value plus the given number of hours.
      overload: NodaTime.LocalDateTime.PlusHours*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.PlusMinutes(System.Int64)
      commentId: M:NodaTime.LocalDateTime.PlusMinutes(System.Int64)
      language: CSharp
      name:
        CSharp: PlusMinutes(Int64)
        VB: PlusMinutes(Int64)
      nameWithType:
        CSharp: LocalDateTime.PlusMinutes(Int64)
        VB: LocalDateTime.PlusMinutes(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.PlusMinutes(System.Int64)
        VB: NodaTime.LocalDateTime.PlusMinutes(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusMinutes
        path: src/NodaTime/LocalDateTime.cs
        startLine: 752
      summary: "\nReturns a new LocalDateTime representing the current value with the given number of minutes added.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime PlusMinutes(long minutes)
          VB: Public Function PlusMinutes(minutes As Long) As LocalDateTime
        parameters:
        - id: minutes
          type: System.Int64
          description: The number of minutes to add
        return:
          type: NodaTime.LocalDateTime
          description: The current value plus the given number of minutes.
      overload: NodaTime.LocalDateTime.PlusMinutes*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.PlusSeconds(System.Int64)
      commentId: M:NodaTime.LocalDateTime.PlusSeconds(System.Int64)
      language: CSharp
      name:
        CSharp: PlusSeconds(Int64)
        VB: PlusSeconds(Int64)
      nameWithType:
        CSharp: LocalDateTime.PlusSeconds(Int64)
        VB: LocalDateTime.PlusSeconds(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.PlusSeconds(System.Int64)
        VB: NodaTime.LocalDateTime.PlusSeconds(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusSeconds
        path: src/NodaTime/LocalDateTime.cs
        startLine: 763
      summary: "\nReturns a new LocalDateTime representing the current value with the given number of seconds added.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime PlusSeconds(long seconds)
          VB: Public Function PlusSeconds(seconds As Long) As LocalDateTime
        parameters:
        - id: seconds
          type: System.Int64
          description: The number of seconds to add
        return:
          type: NodaTime.LocalDateTime
          description: The current value plus the given number of seconds.
      overload: NodaTime.LocalDateTime.PlusSeconds*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.PlusMilliseconds(System.Int64)
      commentId: M:NodaTime.LocalDateTime.PlusMilliseconds(System.Int64)
      language: CSharp
      name:
        CSharp: PlusMilliseconds(Int64)
        VB: PlusMilliseconds(Int64)
      nameWithType:
        CSharp: LocalDateTime.PlusMilliseconds(Int64)
        VB: LocalDateTime.PlusMilliseconds(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.PlusMilliseconds(System.Int64)
        VB: NodaTime.LocalDateTime.PlusMilliseconds(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusMilliseconds
        path: src/NodaTime/LocalDateTime.cs
        startLine: 774
      summary: "\nReturns a new LocalDateTime representing the current value with the given number of milliseconds added.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime PlusMilliseconds(long milliseconds)
          VB: Public Function PlusMilliseconds(milliseconds As Long) As LocalDateTime
        parameters:
        - id: milliseconds
          type: System.Int64
          description: The number of milliseconds to add
        return:
          type: NodaTime.LocalDateTime
          description: The current value plus the given number of milliseconds.
      overload: NodaTime.LocalDateTime.PlusMilliseconds*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.PlusTicks(System.Int64)
      commentId: M:NodaTime.LocalDateTime.PlusTicks(System.Int64)
      language: CSharp
      name:
        CSharp: PlusTicks(Int64)
        VB: PlusTicks(Int64)
      nameWithType:
        CSharp: LocalDateTime.PlusTicks(Int64)
        VB: LocalDateTime.PlusTicks(Int64)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.PlusTicks(System.Int64)
        VB: NodaTime.LocalDateTime.PlusTicks(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusTicks
        path: src/NodaTime/LocalDateTime.cs
        startLine: 785
      summary: "\nReturns a new LocalDateTime representing the current value with the given number of ticks added.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime PlusTicks(long ticks)
          VB: Public Function PlusTicks(ticks As Long) As LocalDateTime
        parameters:
        - id: ticks
          type: System.Int64
          description: The number of ticks to add
        return:
          type: NodaTime.LocalDateTime
          description: The current value plus the given number of ticks.
      overload: NodaTime.LocalDateTime.PlusTicks*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.LocalDateTime.Next(NodaTime.IsoDayOfWeek)
      commentId: M:NodaTime.LocalDateTime.Next(NodaTime.IsoDayOfWeek)
      language: CSharp
      name:
        CSharp: Next(IsoDayOfWeek)
        VB: Next(IsoDayOfWeek)
      nameWithType:
        CSharp: LocalDateTime.Next(IsoDayOfWeek)
        VB: LocalDateTime.Next(IsoDayOfWeek)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Next(NodaTime.IsoDayOfWeek)
        VB: NodaTime.LocalDateTime.Next(NodaTime.IsoDayOfWeek)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Next
        path: src/NodaTime/LocalDateTime.cs
        startLine: 802
      summary: "\nReturns the next <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> falling on the specified <xref href=\"NodaTime.LocalDateTime.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref>,\nat the same time of day as this value.\nThis is a strict \"next\" - if this value on already falls on the target\nday of the week, the returned value will be a week later.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime Next(IsoDayOfWeek targetDayOfWeek)
          VB: Public Function Next(targetDayOfWeek As IsoDayOfWeek) As LocalDateTime
        parameters:
        - id: targetDayOfWeek
          type: NodaTime.IsoDayOfWeek
          description: The ISO day of the week to return the next date of.
        return:
          type: NodaTime.LocalDateTime
          description: The next <xref href="NodaTime.LocalDateTime" data-throw-if-not-resolved="false"></xref> falling on the specified day of the week.
      overload: NodaTime.LocalDateTime.Next*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The underlying calendar doesn't use ISO days of the week.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: >-
          <span class="paramref">targetDayOfWeek</span> is not a valid day of the
              week (Monday to Sunday).
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
        NodaTime.LocalDateTime.IsoDayOfWeek: 
    - id: NodaTime.LocalDateTime.Previous(NodaTime.IsoDayOfWeek)
      commentId: M:NodaTime.LocalDateTime.Previous(NodaTime.IsoDayOfWeek)
      language: CSharp
      name:
        CSharp: Previous(IsoDayOfWeek)
        VB: Previous(IsoDayOfWeek)
      nameWithType:
        CSharp: LocalDateTime.Previous(IsoDayOfWeek)
        VB: LocalDateTime.Previous(IsoDayOfWeek)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.Previous(NodaTime.IsoDayOfWeek)
        VB: NodaTime.LocalDateTime.Previous(NodaTime.IsoDayOfWeek)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Previous
        path: src/NodaTime/LocalDateTime.cs
        startLine: 830
      summary: "\nReturns the previous <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> falling on the specified <xref href=\"NodaTime.LocalDateTime.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref>,\nat the same time of day as this value.\nThis is a strict \"previous\" - if this value on already falls on the target\nday of the week, the returned value will be a week earlier.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime Previous(IsoDayOfWeek targetDayOfWeek)
          VB: Public Function Previous(targetDayOfWeek As IsoDayOfWeek) As LocalDateTime
        parameters:
        - id: targetDayOfWeek
          type: NodaTime.IsoDayOfWeek
          description: The ISO day of the week to return the previous date of.
        return:
          type: NodaTime.LocalDateTime
          description: The previous <xref href="NodaTime.LocalDateTime" data-throw-if-not-resolved="false"></xref> falling on the specified day of the week.
      overload: NodaTime.LocalDateTime.Previous*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The underlying calendar doesn't use ISO days of the week.
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: >-
          <span class="paramref">targetDayOfWeek</span> is not a valid day of the
              week (Monday to Sunday).
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
        NodaTime.LocalDateTime.IsoDayOfWeek: 
    - id: NodaTime.LocalDateTime.WithOffset(NodaTime.Offset)
      commentId: M:NodaTime.LocalDateTime.WithOffset(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: WithOffset(Offset)
        VB: WithOffset(Offset)
      nameWithType:
        CSharp: LocalDateTime.WithOffset(Offset)
        VB: LocalDateTime.WithOffset(Offset)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.WithOffset(NodaTime.Offset)
        VB: NodaTime.LocalDateTime.WithOffset(NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithOffset
        path: src/NodaTime/LocalDateTime.cs
        startLine: 853
      summary: "\nReturns an <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> for this local date/time with the given offset.\n"
      remarks: This method is purely a convenient alternative to calling the <xref href="NodaTime.OffsetDateTime" data-throw-if-not-resolved="false"></xref> constructor directly.
      example: []
      syntax:
        content:
          CSharp: public OffsetDateTime WithOffset(Offset offset)
          VB: Public Function WithOffset(offset As Offset) As OffsetDateTime
        parameters:
        - id: offset
          type: NodaTime.Offset
          description: The offset to apply.
        return:
          type: NodaTime.OffsetDateTime
          description: The result of this local date/time offset by the given amount.
      overload: NodaTime.LocalDateTime.WithOffset*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.OffsetDateTime: 
    - id: NodaTime.LocalDateTime.InUtc
      commentId: M:NodaTime.LocalDateTime.InUtc
      language: CSharp
      name:
        CSharp: InUtc()
        VB: InUtc()
      nameWithType:
        CSharp: LocalDateTime.InUtc()
        VB: LocalDateTime.InUtc()
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.InUtc()
        VB: NodaTime.LocalDateTime.InUtc()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: InUtc
        path: src/NodaTime/LocalDateTime.cs
        startLine: 863
      summary: "\nReturns the mapping of this local date/time within <xref href=\"NodaTime.DateTimeZone.Utc\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      remarks: As UTC is a fixed time zone, there is no chance that this local date/time is ambiguous or skipped.
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime InUtc()
          VB: Public Function InUtc As ZonedDateTime
        return:
          type: NodaTime.ZonedDateTime
          description: The result of mapping this local date/time in UTC.
      overload: NodaTime.LocalDateTime.InUtc*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.DateTimeZone.Utc: 
    - id: NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)
      commentId: M:NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: InZoneStrictly(DateTimeZone)
        VB: InZoneStrictly(DateTimeZone)
      nameWithType:
        CSharp: LocalDateTime.InZoneStrictly(DateTimeZone)
        VB: LocalDateTime.InZoneStrictly(DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)
        VB: NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: InZoneStrictly
        path: src/NodaTime/LocalDateTime.cs
        startLine: 880
      summary: "\nReturns the mapping of this local date/time within the given <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref>,\nwith \"strict\" rules applied such that an exception is thrown if either the mapping is\nambiguous or the time is skipped.\n"
      remarks: "\nThis is solely a convenience method for calling <xref href=\"NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime InZoneStrictly(DateTimeZone zone)
          VB: Public Function InZoneStrictly(zone As DateTimeZone) As ZonedDateTime
        parameters:
        - id: zone
          type: NodaTime.DateTimeZone
          description: The time zone in which to map this local date/time.
        return:
          type: NodaTime.ZonedDateTime
          description: The result of mapping this local date/time in the given time zone.
      overload: NodaTime.LocalDateTime.InZoneStrictly*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">zone</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.DateTimeZone: 
        NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime): 
    - id: NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)
      commentId: M:NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: InZoneLeniently(DateTimeZone)
        VB: InZoneLeniently(DateTimeZone)
      nameWithType:
        CSharp: LocalDateTime.InZoneLeniently(DateTimeZone)
        VB: LocalDateTime.InZoneLeniently(DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)
        VB: NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: InZoneLeniently
        path: src/NodaTime/LocalDateTime.cs
        startLine: 898
      summary: "\nReturns the mapping of this local date/time within the given <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref>,\nwith \"lenient\" rules applied such that ambiguous values map to the\nlater of the alternatives, and \"skipped\" values map to the start of the zone interval\nafter the \"gap\".\n"
      remarks: "\nThis is solely a convenience method for calling <xref href=\"NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime InZoneLeniently(DateTimeZone zone)
          VB: Public Function InZoneLeniently(zone As DateTimeZone) As ZonedDateTime
        parameters:
        - id: zone
          type: NodaTime.DateTimeZone
          description: The time zone in which to map this local date/time.
        return:
          type: NodaTime.ZonedDateTime
          description: The result of mapping this local date/time in the given time zone.
      overload: NodaTime.LocalDateTime.InZoneLeniently*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">zone</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.DateTimeZone: 
        NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime): 
    - id: NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)
      commentId: M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)
      language: CSharp
      name:
        CSharp: InZone(DateTimeZone, ZoneLocalMappingResolver)
        VB: InZone(DateTimeZone, ZoneLocalMappingResolver)
      nameWithType:
        CSharp: LocalDateTime.InZone(DateTimeZone, ZoneLocalMappingResolver)
        VB: LocalDateTime.InZone(DateTimeZone, ZoneLocalMappingResolver)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone, NodaTime.TimeZones.ZoneLocalMappingResolver)
        VB: NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone, NodaTime.TimeZones.ZoneLocalMappingResolver)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: InZone
        path: src/NodaTime/LocalDateTime.cs
        startLine: 915
      summary: "\nResolves this local date and time into a <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> in the given time zone, following\nthe given <xref href=\"NodaTime.TimeZones.ZoneLocalMappingResolver\" data-throw-if-not-resolved=\"false\"></xref> to handle ambiguity and skipped times.\n"
      remarks: "\nThis is a convenience method for calling <xref href=\"NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime%2cNodaTime.TimeZones.ZoneLocalMappingResolver)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime InZone(DateTimeZone zone, ZoneLocalMappingResolver resolver)
          VB: Public Function InZone(zone As DateTimeZone, resolver As ZoneLocalMappingResolver) As ZonedDateTime
        parameters:
        - id: zone
          type: NodaTime.DateTimeZone
          description: The time zone to map this local date and time into
        - id: resolver
          type: NodaTime.TimeZones.ZoneLocalMappingResolver
          description: The resolver to apply to the mapping.
        return:
          type: NodaTime.ZonedDateTime
          description: The result of resolving the mapping.
      overload: NodaTime.LocalDateTime.InZone*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">zone</span> or <span class="paramref">resolver</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
        NodaTime.TimeZones.ZoneLocalMappingResolver: 
        NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver): 
    - id: NodaTime.LocalDateTime.ToString
      commentId: M:NodaTime.LocalDateTime.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: LocalDateTime.ToString()
        VB: LocalDateTime.ToString()
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.ToString()
        VB: NodaTime.LocalDateTime.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/LocalDateTime.cs
        startLine: 930
      summary: "\nReturns a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nThe value of the current instance in the standard format pattern, using the current thread's\nculture to obtain a format provider.\n"
      overload: NodaTime.LocalDateTime.ToString*
      overridden: System.ValueType.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.String: 
    - id: NodaTime.LocalDateTime.ToString(System.String,System.IFormatProvider)
      commentId: M:NodaTime.LocalDateTime.ToString(System.String,System.IFormatProvider)
      language: CSharp
      name:
        CSharp: ToString(String, IFormatProvider)
        VB: ToString(String, IFormatProvider)
      nameWithType:
        CSharp: LocalDateTime.ToString(String, IFormatProvider)
        VB: LocalDateTime.ToString(String, IFormatProvider)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.ToString(System.String, System.IFormatProvider)
        VB: NodaTime.LocalDateTime.ToString(System.String, System.IFormatProvider)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/LocalDateTime.cs
        startLine: 948
      summary: "\nFormats the value of the current instance using the specified pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string ToString(string patternText, IFormatProvider formatProvider)
          VB: Public Function ToString(patternText As String, formatProvider As IFormatProvider) As String
        parameters:
        - id: patternText
          type: System.String
          description: >
            The <xref href="System.String" data-throw-if-not-resolved="false"></xref> specifying the pattern to use,

            or null to use the default format pattern.
        - id: formatProvider
          type: System.IFormatProvider
          description: >
            The <xref href="System.IFormatProvider" data-throw-if-not-resolved="false"></xref> to use when formatting the value,

            or null to use the current thread's culture to obtain a format provider.
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> containing the value of the current instance in the specified format.\n"
      overload: NodaTime.LocalDateTime.ToString*
      implements:
      - System.IFormattable.ToString(System.String,System.IFormatProvider)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.String: 
        System.IFormatProvider: 
    - isEii: true
      id: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema
      commentId: M:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema
      language: CSharp
      name:
        CSharp: IXmlSerializable.GetSchema()
        VB: System.Xml.Serialization.IXmlSerializable.GetSchema()
      nameWithType:
        CSharp: LocalDateTime.IXmlSerializable.GetSchema()
        VB: LocalDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
        VB: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.GetSchema
        path: src/NodaTime/LocalDateTime.cs
        startLine: 956
      example: []
      syntax:
        content:
          CSharp: XmlSchema IXmlSerializable.GetSchema()
          VB: Function System.Xml.Serialization.IXmlSerializable.GetSchema As XmlSchema Implements IXmlSerializable.GetSchema
        return:
          type: System.Xml.Schema.XmlSchema
      overload: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
      implements:
      - System.Xml.Serialization.IXmlSerializable.GetSchema
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      commentId: M:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      language: CSharp
      name:
        CSharp: IXmlSerializable.ReadXml(XmlReader)
        VB: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      nameWithType:
        CSharp: LocalDateTime.IXmlSerializable.ReadXml(XmlReader)
        VB: LocalDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        VB: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.ReadXml
        path: src/NodaTime/LocalDateTime.cs
        startLine: 962
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.ReadXml(XmlReader reader)
          VB: Sub System.Xml.Serialization.IXmlSerializable.ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
        parameters:
        - id: reader
          type: System.Xml.XmlReader
      overload: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      commentId: M:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      language: CSharp
      name:
        CSharp: IXmlSerializable.WriteXml(XmlWriter)
        VB: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      nameWithType:
        CSharp: LocalDateTime.IXmlSerializable.WriteXml(XmlWriter)
        VB: LocalDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        VB: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.WriteXml
        path: src/NodaTime/LocalDateTime.cs
        startLine: 979
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.WriteXml(XmlWriter writer)
          VB: Sub System.Xml.Serialization.IXmlSerializable.WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
        parameters:
        - id: writer
          type: System.Xml.XmlWriter
      overload: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.LocalDateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:NodaTime.LocalDateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: LocalDateTime.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: LocalDateTime.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: NodaTime.LocalDateTime.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: NodaTime.LocalDateTime.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/LocalDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Runtime.Serialization.ISerializable.GetObjectData
        path: src/NodaTime/LocalDateTime.cs
        startLine: 1011
      summary: "\nImplementation of <xref href=\"System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo%2cSystem.Runtime.Serialization.StreamingContext)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
          VB: Sub System.Runtime.Serialization.ISerializable.GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: The <xref href="System.Runtime.Serialization.SerializationInfo" data-throw-if-not-resolved="false"></xref> to populate with data.
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: The destination for this serialization.
      overload: NodaTime.LocalDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*
      implements:
      - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      modifiers:
        CSharp: []
        VB: []
      references:
        ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        : 
        System.Runtime.Serialization.SerializationInfo: 
    references:
      NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime): 
      NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime): 
      NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime): 
      System.IComparable`1: 
  - id: NodaTime.DateTimeZone
    commentId: T:NodaTime.DateTimeZone
    language: CSharp
    name:
      CSharp: DateTimeZone
      VB: DateTimeZone
    nameWithType:
      CSharp: DateTimeZone
      VB: DateTimeZone
    qualifiedName:
      CSharp: NodaTime.DateTimeZone
      VB: NodaTime.DateTimeZone
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/DateTimeZone.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: DateTimeZone
      path: src/NodaTime/DateTimeZone.cs
      startLine: 80
    summary: "\nRepresents a time zone - a mapping between UTC and local time. A time zone maps UTC instants to local times\n- or, equivalently, to the offset from UTC at any particular instant.\n"
    remarks: "\n<p>\nThe mapping is unambiguous in the \"UTC to local\" direction, but\nthe reverse is not true: when the offset changes, usually due to a Daylight Saving transition,\nthe change either creates a gap (a period of local time which never occurs in the time zone)\nor an ambiguity (a period of local time which occurs twice in the time zone). Mapping back from\nlocal time to an instant requires consideration of how these problematic times will be handled.\n</p>\n<p>\nNoda Time provides various options when mapping local time to a specific instant:\n<ul><li><xref href=\"NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref> will throw an exception if the mapping from local time is either ambiguous\n    or impossible, i.e. if there is anything other than one instant which maps to the given local time.</li><li><xref href=\"NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref> will never throw an exception due to ambiguous or skipped times,\n    resolving to the later option of ambiguous matches or the start of the zone interval after the gap for\n    skipped times.</li><li><xref href=\"NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime%2cNodaTime.TimeZones.ZoneLocalMappingResolver)\" data-throw-if-not-resolved=\"false\"></xref> will apply a <xref href=\"NodaTime.TimeZones.ZoneLocalMappingResolver\" data-throw-if-not-resolved=\"false\"></xref> to the result of\n    a mapping.</li><li><xref href=\"NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref> will return a <xref href=\"NodaTime.TimeZones.ZoneLocalMapping\" data-throw-if-not-resolved=\"false\"></xref>\n    with complete information about whether the given local time occurs zero times, once or twice. This is the most\n    fine-grained approach, which is the fiddliest to use but puts the caller in the most control.</li></ul>\n</p>\n<p>\nNoda Time has two built-in sources of time zone data available: a copy of the\n<a href=\"http://www.iana.org/time-zones\">tz database</a> (also known as the IANA Time Zone database, or zoneinfo\nor Olson database), and the ability to convert .NET's own <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref> format into a \"native\" Noda\nTime zone. Which of these is most appropriate for you to use will very much depend on your exact needs. The\nzoneinfo database is widely used outside Windows, and has more historical data than the Windows-provided\ninformation, but if you need to interoperate with other Windows systems by specifying time zone IDs, you may\nwish to stick to the Windows time zones.\n</p>\n<p>\nTo obtain a <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> for a given timezone ID, use one of the methods on\n<xref href=\"NodaTime.IDateTimeZoneProvider\" data-throw-if-not-resolved=\"false\"></xref> (and see <xref href=\"NodaTime.DateTimeZoneProviders\" data-throw-if-not-resolved=\"false\"></xref> for access to the built-in\nproviders). The UTC timezone is also available via the <xref href=\"NodaTime.DateTimeZone.Utc\" data-throw-if-not-resolved=\"false\"></xref> property on this class.\n</p>\n<p>\nTo obtain a <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> representing the system default time zone, you can either call\n<xref href=\"NodaTime.IDateTimeZoneProvider.GetSystemDefault\" data-throw-if-not-resolved=\"false\"></xref> on a provider to obtain the <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> that\nthe provider considers matches the system default time zone, or you can construct a\n<code>BclDateTimeZone</code> via <code>BclDateTimeZone.ForSystemDefault</code>, which returns a\n<xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> that wraps the system local <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref>. The latter will always\nsucceed, but has access only to that information available via the .NET time zone; the former may contain more\ncomplete data, but may (in uncommon cases) fail to find a matching <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref>.\nNote that <code>BclDateTimeZone</code> is not available on the PCL build of Noda Time, so this fallback strategy can\nonly be used with the desktop version.\n</p>\n<p>Note that Noda Time does not require that <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> instances be singletons.\nAs far as reasonably possible, implementations should implement <xref href=\"System.IEquatable%601\" data-throw-if-not-resolved=\"false\"></xref> in such a way\nthat equivalent time zones compare as equal.</p>\n"
    example: []
    syntax:
      content:
        CSharp: 'public abstract class DateTimeZone : IEquatable<DateTimeZone>, IZoneIntervalMap'
        VB: >-
          Public MustInherit Class DateTimeZone

              Implements IEquatable(Of DateTimeZone), IZoneIntervalMap
    inheritance:
    - System.Object
    implements:
    - System.IEquatable{NodaTime.DateTimeZone}
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - abstract
      - class
      VB:
      - Public
      - MustInherit
      - Class
    items:
    - id: NodaTime.DateTimeZone.Utc
      commentId: P:NodaTime.DateTimeZone.Utc
      language: CSharp
      name:
        CSharp: Utc
        VB: Utc
      nameWithType:
        CSharp: DateTimeZone.Utc
        VB: DateTimeZone.Utc
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.Utc
        VB: NodaTime.DateTimeZone.Utc
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Utc
        path: src/NodaTime/DateTimeZone.cs
        startLine: 110
      summary: "\nGets the UTC (Coordinated Universal Time) time zone. This is a single instance which is not\nprovider-specific; it is guaranteed to have the ID \"UTC\", but may or may not be the instance returned by\ne.g. <code>DateTimeZoneProviders.Tzdb[\"UTC\"]</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static DateTimeZone Utc { get; }
          VB: Public Shared ReadOnly Property Utc As DateTimeZone
        parameters: []
        return:
          type: NodaTime.DateTimeZone
          description: A UTC <xref href="NodaTime.DateTimeZone" data-throw-if-not-resolved="false"></xref>.
      overload: NodaTime.DateTimeZone.Utc*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.DateTimeZone: 
    - id: NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)
      commentId: M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: ForOffset(Offset)
        VB: ForOffset(Offset)
      nameWithType:
        CSharp: DateTimeZone.ForOffset(Offset)
        VB: DateTimeZone.ForOffset(Offset)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)
        VB: NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ForOffset
        path: src/NodaTime/DateTimeZone.cs
        startLine: 128
      summary: "\nReturns a fixed time zone with the given offset.\n"
      remarks: "\n<p>\nThe returned time zone will have an ID of \"UTC\" if the offset is zero, or \"UTC+/-Offset\"\notherwise. In the former case, the returned instance will be equal to <xref href=\"NodaTime.DateTimeZone.Utc\" data-throw-if-not-resolved=\"false\"></xref>.\n</p>\n<p>\nNote also that this method is not required to return the same <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> instance for\nsuccessive requests for the same offset; however, all instances returned for a given offset will compare\nas equal.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public static DateTimeZone ForOffset(Offset offset)
          VB: Public Shared Function ForOffset(offset As Offset) As DateTimeZone
        parameters:
        - id: offset
          type: NodaTime.Offset
          description: The offset for the returned time zone
        return:
          type: NodaTime.DateTimeZone
          description: A fixed time zone with the given offset.
      overload: NodaTime.DateTimeZone.ForOffset*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.DateTimeZone.Utc: 
        NodaTime.DateTimeZone: 
    - id: NodaTime.DateTimeZone.#ctor(System.String,System.Boolean,NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.DateTimeZone.#ctor(System.String,System.Boolean,NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: DateTimeZone(String, Boolean, Offset, Offset)
        VB: DateTimeZone(String, Boolean, Offset, Offset)
      nameWithType:
        CSharp: DateTimeZone.DateTimeZone(String, Boolean, Offset, Offset)
        VB: DateTimeZone.DateTimeZone(String, Boolean, Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.DateTimeZone(System.String, System.Boolean, NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.DateTimeZone.DateTimeZone(System.String, System.Boolean, NodaTime.Offset, NodaTime.Offset)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/DateTimeZone.cs
        startLine: 150
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> class.\n"
      example: []
      syntax:
        content:
          CSharp: protected DateTimeZone(string id, bool isFixed, Offset minOffset, Offset maxOffset)
          VB: Protected Sub New(id As String, isFixed As Boolean, minOffset As Offset, maxOffset As Offset)
        parameters:
        - id: id
          type: System.String
          description: The unique id of this time zone.
        - id: isFixed
          type: System.Boolean
          description: Set to <code>true</code> if this time zone has no transitions.
        - id: minOffset
          type: NodaTime.Offset
          description: Minimum offset applied within this zone
        - id: maxOffset
          type: NodaTime.Offset
          description: Maximum offset applied within this zone
      overload: NodaTime.DateTimeZone.#ctor*
      modifiers:
        CSharp:
        - protected
        VB:
        - Protected
      references:
        NodaTime.DateTimeZone: 
    - id: NodaTime.DateTimeZone.Id
      commentId: P:NodaTime.DateTimeZone.Id
      language: CSharp
      name:
        CSharp: Id
        VB: Id
      nameWithType:
        CSharp: DateTimeZone.Id
        VB: DateTimeZone.Id
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.Id
        VB: NodaTime.DateTimeZone.Id
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Id
        path: src/NodaTime/DateTimeZone.cs
        startLine: 167
      summary: "\nThe provider's ID for the time zone.\n"
      remarks: "\n<p>\nThis identifies the time zone within the current time zone provider; a different provider may\nprovide a different time zone with the same ID, or may not provide a time zone with that ID at all.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public string Id { get; }
          VB: Public ReadOnly Property Id As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.DateTimeZone.Id*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.DateTimeZone.MinOffset
      commentId: P:NodaTime.DateTimeZone.MinOffset
      language: CSharp
      name:
        CSharp: MinOffset
        VB: MinOffset
      nameWithType:
        CSharp: DateTimeZone.MinOffset
        VB: DateTimeZone.MinOffset
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.MinOffset
        VB: NodaTime.DateTimeZone.MinOffset
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MinOffset
        path: src/NodaTime/DateTimeZone.cs
        startLine: 183
      summary: "\nReturns the least (most negative) offset within this time zone, over all time.\n"
      example: []
      syntax:
        content:
          CSharp: public Offset MinOffset { get; }
          VB: Public ReadOnly Property MinOffset As Offset
        parameters: []
        return:
          type: NodaTime.Offset
      overload: NodaTime.DateTimeZone.MinOffset*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.DateTimeZone.MaxOffset
      commentId: P:NodaTime.DateTimeZone.MaxOffset
      language: CSharp
      name:
        CSharp: MaxOffset
        VB: MaxOffset
      nameWithType:
        CSharp: DateTimeZone.MaxOffset
        VB: DateTimeZone.MaxOffset
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.MaxOffset
        VB: NodaTime.DateTimeZone.MaxOffset
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MaxOffset
        path: src/NodaTime/DateTimeZone.cs
        startLine: 188
      summary: "\nReturns the greatest (most positive) offset within this time zone, over all time.\n"
      example: []
      syntax:
        content:
          CSharp: public Offset MaxOffset { get; }
          VB: Public ReadOnly Property MaxOffset As Offset
        parameters: []
        return:
          type: NodaTime.Offset
      overload: NodaTime.DateTimeZone.MaxOffset*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)
      commentId: M:NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)
      language: CSharp
      name:
        CSharp: GetUtcOffset(Instant)
        VB: GetUtcOffset(Instant)
      nameWithType:
        CSharp: DateTimeZone.GetUtcOffset(Instant)
        VB: DateTimeZone.GetUtcOffset(Instant)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)
        VB: NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetUtcOffset
        path: src/NodaTime/DateTimeZone.cs
        startLine: 203
      summary: "\nReturns the offset from UTC, where a positive duration indicates that local time is\nlater than UTC. In other words, local time = UTC + offset.\n"
      remarks: "\nThis is mostly a convenience method for calling <code>GetZoneInterval(instant).WallOffset</code>,\nalthough it can also be overridden for more efficiency.\n"
      example: []
      syntax:
        content:
          CSharp: public virtual Offset GetUtcOffset(Instant instant)
          VB: Public Overridable Function GetUtcOffset(instant As Instant) As Offset
        parameters:
        - id: instant
          type: NodaTime.Instant
          description: The instant for which to calculate the offset.
        return:
          type: NodaTime.Offset
          description: "\nThe offset from UTC at the specified instant.\n"
      overload: NodaTime.DateTimeZone.GetUtcOffset*
      modifiers:
        CSharp:
        - public
        - virtual
        VB:
        - Public
        - Overridable
    - id: NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
      commentId: M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
      language: CSharp
      name:
        CSharp: GetZoneInterval(Instant)
        VB: GetZoneInterval(Instant)
      nameWithType:
        CSharp: DateTimeZone.GetZoneInterval(Instant)
        VB: DateTimeZone.GetZoneInterval(Instant)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
        VB: NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetZoneInterval
        path: src/NodaTime/DateTimeZone.cs
        startLine: 218
      summary: "\nGets the zone interval for the given instant; the range of time around the instant in which the same Offset\napplies (with the same split between standard time and daylight saving time, and with the same offset).\n"
      remarks: "\nThis will always return a valid zone interval, as time zones cover the whole of time.\n"
      example: []
      syntax:
        content:
          CSharp: public abstract ZoneInterval GetZoneInterval(Instant instant)
          VB: Public MustOverride Function GetZoneInterval(instant As Instant) As ZoneInterval
        parameters:
        - id: instant
          type: NodaTime.Instant
          description: The <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> to query.
        return:
          type: NodaTime.TimeZones.ZoneInterval
          description: The defined <xref href="NodaTime.TimeZones.ZoneInterval" data-throw-if-not-resolved="false"></xref>.
      overload: NodaTime.DateTimeZone.GetZoneInterval*
      seealso:
      - linkId: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)
        commentId: M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)
      modifiers:
        CSharp:
        - public
        - abstract
        VB:
        - Public
        - MustOverride
      references:
        NodaTime.Instant: 
        NodaTime.TimeZones.ZoneInterval: 
        NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval): 
    - id: NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)
      commentId: M:NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: AtStartOfDay(LocalDate)
        VB: AtStartOfDay(LocalDate)
      nameWithType:
        CSharp: DateTimeZone.AtStartOfDay(LocalDate)
        VB: DateTimeZone.AtStartOfDay(LocalDate)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)
        VB: NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: AtStartOfDay
        path: src/NodaTime/DateTimeZone.cs
        startLine: 291
      summary: "\nReturns the earliest valid <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> with the given local date.\n"
      remarks: "\nIf midnight exists unambiguously on the given date, it is returned.\nIf the given date has an ambiguous start time (e.g. the clocks go back from 1am to midnight)\nthen the earlier ZonedDateTime is returned. If the given date has no midnight (e.g. the clocks\ngo forward from midnight to 1am) then the earliest valid value is returned; this will be the instant\nof the transition.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime AtStartOfDay(LocalDate date)
          VB: Public Function AtStartOfDay(date As LocalDate) As ZonedDateTime
        parameters:
        - id: date
          type: NodaTime.LocalDate
          description: The local date to map in this time zone.
        return:
          type: NodaTime.ZonedDateTime
          description: The <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> representing the earliest time in the given date, in this time zone.
      overload: NodaTime.DateTimeZone.AtStartOfDay*
      exceptions:
      - type: NodaTime.SkippedTimeException
        commentId: T:NodaTime.SkippedTimeException
        description: >-
          The entire day was skipped due to a very large time zone transition.

          (This is extremely rare.)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)
      commentId: M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: MapLocal(LocalDateTime)
        VB: MapLocal(LocalDateTime)
      nameWithType:
        CSharp: DateTimeZone.MapLocal(LocalDateTime)
        VB: DateTimeZone.MapLocal(LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)
        VB: NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MapLocal
        path: src/NodaTime/DateTimeZone.cs
        startLine: 330
      summary: "\nReturns complete information about how the given <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> is mapped in this time zone.\n"
      remarks: "\n<p>\nMapping a local date/time to a time zone can give an unambiguous, ambiguous or impossible result, depending on\ntime zone transitions. Use the return value of this method to handle these cases in an appropriate way for\nyour use case.\n</p>\n<p>\nAs an alternative, consider <xref href=\"NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime%2cNodaTime.TimeZones.ZoneLocalMappingResolver)\" data-throw-if-not-resolved=\"false\"></xref>, which uses a caller-provided strategy to\nconvert the <xref href=\"NodaTime.TimeZones.ZoneLocalMapping\" data-throw-if-not-resolved=\"false\"></xref> returned here to a <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public ZoneLocalMapping MapLocal(LocalDateTime localDateTime)
          VB: Public Function MapLocal(localDateTime As LocalDateTime) As ZoneLocalMapping
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: The local date and time to map in this time zone.
        return:
          type: NodaTime.TimeZones.ZoneLocalMapping
          description: A mapping of the given local date and time to zero, one or two zoned date/time values.
      overload: NodaTime.DateTimeZone.MapLocal*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
        NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver): 
        NodaTime.TimeZones.ZoneLocalMapping: 
        NodaTime.ZonedDateTime: 
    - id: NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)
      commentId: M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)
      language: CSharp
      name:
        CSharp: ResolveLocal(LocalDateTime, ZoneLocalMappingResolver)
        VB: ResolveLocal(LocalDateTime, ZoneLocalMappingResolver)
      nameWithType:
        CSharp: DateTimeZone.ResolveLocal(LocalDateTime, ZoneLocalMappingResolver)
        VB: DateTimeZone.ResolveLocal(LocalDateTime, ZoneLocalMappingResolver)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime, NodaTime.TimeZones.ZoneLocalMappingResolver)
        VB: NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime, NodaTime.TimeZones.ZoneLocalMappingResolver)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ResolveLocal
        path: src/NodaTime/DateTimeZone.cs
        startLine: 388
      summary: "\nMaps the given <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> to the corresponding <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>, following\nthe given <xref href=\"NodaTime.TimeZones.ZoneLocalMappingResolver\" data-throw-if-not-resolved=\"false\"></xref> to handle ambiguity and skipped times.\n"
      remarks: "\n<p>\nThis is a convenience method for calling <xref href=\"NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref> and passing the result to the resolver.\nCommon options for resolvers are provided in the static <xref href=\"NodaTime.TimeZones.Resolvers\" data-throw-if-not-resolved=\"false\"></xref> class.\n</p>\n<p>\nSee <xref href=\"NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref> for alternative ways to map a local time to a\nspecific instant.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime ResolveLocal(LocalDateTime localDateTime, ZoneLocalMappingResolver resolver)
          VB: Public Function ResolveLocal(localDateTime As LocalDateTime, resolver As ZoneLocalMappingResolver) As ZonedDateTime
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: The local date and time to map in this time zone.
        - id: resolver
          type: NodaTime.TimeZones.ZoneLocalMappingResolver
          description: The resolver to apply to the mapping.
        return:
          type: NodaTime.ZonedDateTime
          description: The result of resolving the mapping.
      overload: NodaTime.DateTimeZone.ResolveLocal*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">resolver</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
        NodaTime.ZonedDateTime: 
        NodaTime.TimeZones.ZoneLocalMappingResolver: 
        NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime): 
        NodaTime.TimeZones.Resolvers: 
        NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime): 
        NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime): 
    - id: NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)
      commentId: M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: AtStrictly(LocalDateTime)
        VB: AtStrictly(LocalDateTime)
      nameWithType:
        CSharp: DateTimeZone.AtStrictly(LocalDateTime)
        VB: DateTimeZone.AtStrictly(LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)
        VB: NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: AtStrictly
        path: src/NodaTime/DateTimeZone.cs
        startLine: 408
      summary: "\nMaps the given <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> to the corresponding <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>, if and only if\nthat mapping is unambiguous in this time zone.  Otherwise, <xref href=\"NodaTime.SkippedTimeException\" data-throw-if-not-resolved=\"false\"></xref> or\n<xref href=\"NodaTime.AmbiguousTimeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown, depending on whether the mapping is ambiguous or the local\ndate/time is skipped entirely.\n"
      remarks: "\nSee <xref href=\"NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime%2cNodaTime.TimeZones.ZoneLocalMappingResolver)\" data-throw-if-not-resolved=\"false\"></xref> for alternative ways to map a local time to a\nspecific instant.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime AtStrictly(LocalDateTime localDateTime)
          VB: Public Function AtStrictly(localDateTime As LocalDateTime) As ZonedDateTime
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: The local date and time to map into this time zone.
        return:
          type: NodaTime.ZonedDateTime
          description: The unambiguous matching <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> if it exists.
      overload: NodaTime.DateTimeZone.AtStrictly*
      exceptions:
      - type: NodaTime.SkippedTimeException
        commentId: T:NodaTime.SkippedTimeException
        description: The given local date/time is skipped in this time zone.
      - type: NodaTime.AmbiguousTimeException
        commentId: T:NodaTime.AmbiguousTimeException
        description: The given local date/time is ambiguous in this time zone.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
        NodaTime.ZonedDateTime: 
        NodaTime.SkippedTimeException: 
        NodaTime.AmbiguousTimeException: 
        NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime): 
        NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver): 
    - id: NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)
      commentId: M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: AtLeniently(LocalDateTime)
        VB: AtLeniently(LocalDateTime)
      nameWithType:
        CSharp: DateTimeZone.AtLeniently(LocalDateTime)
        VB: DateTimeZone.AtLeniently(LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)
        VB: NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: AtLeniently
        path: src/NodaTime/DateTimeZone.cs
        startLine: 425
      summary: "\nMaps the given <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> to the corresponding <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> in a lenient\nmanner: ambiguous values map to the later of the alternatives, and \"skipped\" values map to the start of the\nzone interval after the \"gap\".\n"
      remarks: "\nSee <xref href=\"NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime%2cNodaTime.TimeZones.ZoneLocalMappingResolver)\" data-throw-if-not-resolved=\"false\"></xref> for alternative ways to map a local time to a\nspecific instant.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime AtLeniently(LocalDateTime localDateTime)
          VB: Public Function AtLeniently(localDateTime As LocalDateTime) As ZonedDateTime
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: The local date/time to map.
        return:
          type: NodaTime.ZonedDateTime
          description: >-
            The unambiguous mapping if there is one, the later result if the mapping is ambiguous,

            or the start of the later zone interval if the given local date/time is skipped.
      overload: NodaTime.DateTimeZone.AtLeniently*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
        NodaTime.ZonedDateTime: 
        NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime): 
        NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver): 
    - id: NodaTime.DateTimeZone.ToString
      commentId: M:NodaTime.DateTimeZone.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: DateTimeZone.ToString()
        VB: DateTimeZone.ToString()
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.ToString()
        VB: NodaTime.DateTimeZone.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/DateTimeZone.cs
        startLine: 521
      summary: "\nReturns the ID of this time zone.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nThe ID of this time zone.\n"
      overload: NodaTime.DateTimeZone.ToString*
      overridden: System.Object.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.DateTimeZone.Equals(System.Object)
      commentId: M:NodaTime.DateTimeZone.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: DateTimeZone.Equals(Object)
        VB: DateTimeZone.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.Equals(System.Object)
        VB: NodaTime.DateTimeZone.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/DateTimeZone.cs
        startLine: 552
      summary: "\nDetermines whether the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override sealed bool Equals(object obj)
          VB: Public NotOverridable Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: The <xref href="System.Object" data-throw-if-not-resolved="false"></xref> to compare with this instance.
        return:
          type: System.Boolean
          description: "\n<code>true</code> if the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance;\notherwise, <code>false</code>.\n"
      overload: NodaTime.DateTimeZone.Equals*
      overridden: System.Object.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        - sealed
        VB:
        - Public
        - Overrides
        - NotOverridable
      references:
        System.Object: 
    - id: NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)
      commentId: M:NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: Equals(DateTimeZone)
        VB: Equals(DateTimeZone)
      nameWithType:
        CSharp: DateTimeZone.Equals(DateTimeZone)
        VB: DateTimeZone.Equals(DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)
        VB: NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/DateTimeZone.cs
        startLine: 569
      summary: "\nDetermines whether the specified <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance.\n"
      remarks: "\nThis implementation performs initial checks which would be common to all child implementations,\nand then delegates to <xref href=\"NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(DateTimeZone obj)
          VB: Public Function Equals(obj As DateTimeZone) As Boolean
        parameters:
        - id: obj
          type: NodaTime.DateTimeZone
          description: The <xref href="NodaTime.DateTimeZone" data-throw-if-not-resolved="false"></xref> to compare with this instance.
        return:
          type: System.Boolean
          description: "\n<code>true</code> if the specified <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance;\notherwise, <code>false</code>.\n"
      overload: NodaTime.DateTimeZone.Equals*
      implements:
      - System.IEquatable{NodaTime.DateTimeZone}.Equals(NodaTime.DateTimeZone)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.DateTimeZone: 
        NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone): 
    - id: NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
      commentId: M:NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: EqualsImpl(DateTimeZone)
        VB: EqualsImpl(DateTimeZone)
      nameWithType:
        CSharp: DateTimeZone.EqualsImpl(DateTimeZone)
        VB: DateTimeZone.EqualsImpl(DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
        VB: NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: EqualsImpl
        path: src/NodaTime/DateTimeZone.cs
        startLine: 587
      summary: "\nImplements equality in derived classes.\n"
      example: []
      syntax:
        content:
          CSharp: protected abstract bool EqualsImpl(DateTimeZone zone)
          VB: Protected MustOverride Function EqualsImpl(zone As DateTimeZone) As Boolean
        parameters:
        - id: zone
          type: NodaTime.DateTimeZone
          description: >-
            The zone to compare with this one. This is guaranteed (when called by <xref href="NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)" data-throw-if-not-resolved="false"></xref>) to

            be a non-null reference of the same type as this instance.
        return:
          type: System.Boolean
          description: "\n<code>true</code> if the specified <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance;\notherwise, <code>false</code>.\n"
      overload: NodaTime.DateTimeZone.EqualsImpl*
      modifiers:
        CSharp:
        - protected
        - abstract
        VB:
        - Protected
        - MustOverride
      references:
        NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone): 
        NodaTime.DateTimeZone: 
    - id: NodaTime.DateTimeZone.GetHashCode
      commentId: M:NodaTime.DateTimeZone.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: DateTimeZone.GetHashCode()
        VB: DateTimeZone.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.GetHashCode()
        VB: NodaTime.DateTimeZone.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/DateTimeZone.cs
        startLine: 596
      summary: "\nReturns a hash code for this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public abstract override int GetHashCode()
          VB: Public MustOverride Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: "\nA hash code for this instance, suitable for use in hashing algorithms and data\nstructures like a hash table. \n"
      overload: NodaTime.DateTimeZone.GetHashCode*
      overridden: System.Object.GetHashCode
      modifiers:
        CSharp:
        - public
        - abstract
        - override
        VB:
        - Public
        - MustOverride
        - Overrides
    - id: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: GetZoneIntervals(Instant, Instant)
        VB: GetZoneIntervals(Instant, Instant)
      nameWithType:
        CSharp: DateTimeZone.GetZoneIntervals(Instant, Instant)
        VB: DateTimeZone.GetZoneIntervals(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant, NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetZoneIntervals
        path: src/NodaTime/DateTimeZone.cs
        startLine: 612
      summary: "\nReturns all the zone intervals which occur for any instant in the interval [<span class=\"paramref\">start</span>, <span class=\"paramref\">end</span>).\n"
      remarks: "\n<p>This method is simply a convenience method for calling <xref href=\"NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)\" data-throw-if-not-resolved=\"false\"></xref> without\nexplicitly constructing the interval beforehand.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public IEnumerable<ZoneInterval> GetZoneIntervals(Instant start, Instant end)
          VB: Public Function GetZoneIntervals(start As Instant, end As Instant) As IEnumerable(Of ZoneInterval)
        parameters:
        - id: start
          type: NodaTime.Instant
          description: Inclusive start point of the interval for which to retrieve zone intervals.
        - id: end
          type: NodaTime.Instant
          description: Exclusive end point of the interval for which to retrieve zone intervals.
        return:
          type: System.Collections.Generic.IEnumerable{NodaTime.TimeZones.ZoneInterval}
          description: A sequence of zone intervals covering the given interval.
      overload: NodaTime.DateTimeZone.GetZoneIntervals*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: <span class="paramref">end</span> is earlier than <span class="paramref">start</span>.
      seealso:
      - linkId: NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
        commentId: M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval): 
        NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant): 
    - id: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)
      commentId: M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)
      language: CSharp
      name:
        CSharp: GetZoneIntervals(Interval)
        VB: GetZoneIntervals(Interval)
      nameWithType:
        CSharp: DateTimeZone.GetZoneIntervals(Interval)
        VB: DateTimeZone.GetZoneIntervals(Interval)
      qualifiedName:
        CSharp: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)
        VB: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/DateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetZoneIntervals
        path: src/NodaTime/DateTimeZone.cs
        startLine: 631
      summary: "\nReturns all the zone intervals which occur for any instant in the given interval.\n"
      remarks: "\n<p>The zone intervals are returned in chronological order. This method is equivalent to calling <xref href=\"NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)\" data-throw-if-not-resolved=\"false\"></xref> for every\ninstant in the interval and then collapsing to a set of distinct zone intervals.\nThe first and last zone intervals are likely to also cover instants outside the given interval;\nthe zone intervals returned are not truncated to match the start and end points.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public IEnumerable<ZoneInterval> GetZoneIntervals(Interval interval)
          VB: Public Function GetZoneIntervals(interval As Interval) As IEnumerable(Of ZoneInterval)
        parameters:
        - id: interval
          type: NodaTime.Interval
          description: Interval to find zone intervals for.
        return:
          type: System.Collections.Generic.IEnumerable{NodaTime.TimeZones.ZoneInterval}
          description: A sequence of zone intervals covering the given interval.
      overload: NodaTime.DateTimeZone.GetZoneIntervals*
      seealso:
      - linkId: NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
        commentId: M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant): 
    references:
      NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime): 
      NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime): 
      NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver): 
      NodaTime.TimeZones.ZoneLocalMappingResolver: 
      NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime): 
      NodaTime.TimeZones.ZoneLocalMapping: 
      System.TimeZoneInfo: 
      NodaTime.DateTimeZone: 
      NodaTime.IDateTimeZoneProvider: 
      NodaTime.DateTimeZoneProviders: 
      NodaTime.DateTimeZone.Utc: 
      NodaTime.IDateTimeZoneProvider.GetSystemDefault: 
      System.IEquatable`1: 
  - id: NodaTime.Duration
    commentId: T:NodaTime.Duration
    language: CSharp
    name:
      CSharp: Duration
      VB: Duration
    nameWithType:
      CSharp: Duration
      VB: Duration
    qualifiedName:
      CSharp: NodaTime.Duration
      VB: NodaTime.Duration
    type: Struct
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/Duration.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: Duration
      path: src/NodaTime/Duration.cs
      startLine: 38
    summary: "\nRepresents a fixed (and calendar-independent) length of time.\n"
    remarks: "\n<p>\nA duration is a length of time defined by an integral number of 'ticks', where a tick is equal to 100\nnanoseconds. There are 10,000 ticks in a millisecond.\nAlthough durations are usually used with a positive number of ticks, negative durations are valid, and may occur\nnaturally when e.g. subtracting an earlier <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> from a later one.\n</p>\n<p>\nA duration represents a fixed length of elapsed time along the time line that occupies the same amount of\ntime regardless of when it is applied.  In contrast, <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref> represents a period of time in\ncalendrical terms (hours, days, and so on) that may vary in elapsed time when applied.\n</p>\n<p>\nIn general, use <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> to represent durations applied to global types like <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref>\nand <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>; use <code>Period</code> to represent a period applied to local types like\n<xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref>.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public struct Duration : IEquatable<Duration>, IComparable<Duration>, IComparable, IXmlSerializable, IFormattable, ISerializable
        VB: >-
          <Serializable>

          Public Structure Duration

              Implements IEquatable(Of Duration), IComparable(Of Duration), IComparable, IXmlSerializable, IFormattable, ISerializable
    implements:
    - System.IEquatable{NodaTime.Duration}
    - System.IComparable{NodaTime.Duration}
    - System.IComparable
    - System.Xml.Serialization.IXmlSerializable
    - System.IFormattable
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: NodaTime.Duration.Zero
      commentId: F:NodaTime.Duration.Zero
      language: CSharp
      name:
        CSharp: Zero
        VB: Zero
      nameWithType:
        CSharp: Duration.Zero
        VB: Duration.Zero
      qualifiedName:
        CSharp: NodaTime.Duration.Zero
        VB: NodaTime.Duration.Zero
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Zero
        path: src/NodaTime/Duration.cs
        startLine: 50
      summary: "\nRepresents the zero <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> value. \nThis field is read-only.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Duration Zero
          VB: Public Shared ReadOnly Zero As Duration
        return:
          type: NodaTime.Duration
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.Epsilon
      commentId: F:NodaTime.Duration.Epsilon
      language: CSharp
      name:
        CSharp: Epsilon
        VB: Epsilon
      nameWithType:
        CSharp: Duration.Epsilon
        VB: Duration.Epsilon
      qualifiedName:
        CSharp: NodaTime.Duration.Epsilon
        VB: NodaTime.Duration.Epsilon
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Epsilon
        path: src/NodaTime/Duration.cs
        startLine: 56
      summary: "\nRepresents the <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> value equals to 1 tick; the smallest amount by which an instant can vary.\nThis field is read-only.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Duration Epsilon
          VB: Public Shared ReadOnly Epsilon As Duration
        return:
          type: NodaTime.Duration
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.Ticks
      commentId: P:NodaTime.Duration.Ticks
      language: CSharp
      name:
        CSharp: Ticks
        VB: Ticks
      nameWithType:
        CSharp: Duration.Ticks
        VB: Duration.Ticks
      qualifiedName:
        CSharp: NodaTime.Duration.Ticks
        VB: NodaTime.Duration.Ticks
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Ticks
        path: src/NodaTime/Duration.cs
        startLine: 131
      summary: "\nThe total number of ticks in the duration.\n"
      remarks: "\nThis property effectively represents all of the information within a Duration value; a duration\nis simply a number of ticks.\n"
      example: []
      syntax:
        content:
          CSharp: public long Ticks { get; }
          VB: Public ReadOnly Property Ticks As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Duration.Ticks*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Duration.Equals(System.Object)
      commentId: M:NodaTime.Duration.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: Duration.Equals(Object)
        VB: Duration.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.Duration.Equals(System.Object)
        VB: NodaTime.Duration.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/Duration.cs
        startLine: 142
      summary: "\nDetermines whether the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: The <xref href="System.Object" data-throw-if-not-resolved="false"></xref> to compare with this instance.
        return:
          type: System.Boolean
          description: "\n<code>true</code> if the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance;\notherwise, <code>false</code>.\n"
      overload: NodaTime.Duration.Equals*
      overridden: System.ValueType.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.Object: 
    - id: NodaTime.Duration.GetHashCode
      commentId: M:NodaTime.Duration.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: Duration.GetHashCode()
        VB: Duration.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.Duration.GetHashCode()
        VB: NodaTime.Duration.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/Duration.cs
        startLine: 158
      summary: "\nReturns a hash code for this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: "\nA hash code for this instance, suitable for use in hashing algorithms and data\nstructures like a hash table. \n"
      overload: NodaTime.Duration.GetHashCode*
      overridden: System.ValueType.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.Duration.ToString
      commentId: M:NodaTime.Duration.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: Duration.ToString()
        VB: Duration.ToString()
      qualifiedName:
        CSharp: NodaTime.Duration.ToString()
        VB: NodaTime.Duration.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/Duration.cs
        startLine: 171
      summary: "\nReturns a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      overload: NodaTime.Duration.ToString*
      overridden: System.ValueType.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.String: 
    - id: NodaTime.Duration.ToString(System.String,System.IFormatProvider)
      commentId: M:NodaTime.Duration.ToString(System.String,System.IFormatProvider)
      language: CSharp
      name:
        CSharp: ToString(String, IFormatProvider)
        VB: ToString(String, IFormatProvider)
      nameWithType:
        CSharp: Duration.ToString(String, IFormatProvider)
        VB: Duration.ToString(String, IFormatProvider)
      qualifiedName:
        CSharp: NodaTime.Duration.ToString(System.String, System.IFormatProvider)
        VB: NodaTime.Duration.ToString(System.String, System.IFormatProvider)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/Duration.cs
        startLine: 191
      summary: "\nFormats the value of the current instance using the specified format.\n"
      example: []
      syntax:
        content:
          CSharp: public string ToString(string patternText, IFormatProvider formatProvider)
          VB: Public Function ToString(patternText As String, formatProvider As IFormatProvider) As String
        parameters:
        - id: patternText
          type: System.String
          description: "The <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> specifying the pattern to use.\n  -or- \n  null to use the default pattern defined for the type of the <xref href=\"System.IFormattable\" data-throw-if-not-resolved=\"false\"></xref> implementation. \n"
        - id: formatProvider
          type: System.IFormatProvider
          description: "The <xref href=\"System.IFormatProvider\" data-throw-if-not-resolved=\"false\"></xref> to use to format the value.\n  -or- \n  null to obtain the numeric format information from the current locale setting of the operating system. \n"
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> containing the value of the current instance in the specified format.\n"
      overload: NodaTime.Duration.ToString*
      implements:
      - System.IFormattable.ToString(System.String,System.IFormatProvider)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.String: 
        System.IFormattable: 
        System.IFormatProvider: 
    - id: NodaTime.Duration.op_Addition(NodaTime.Duration,NodaTime.Duration)
      commentId: M:NodaTime.Duration.op_Addition(NodaTime.Duration,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Addition(Duration, Duration)
        VB: Addition(Duration, Duration)
      nameWithType:
        CSharp: Duration.Addition(Duration, Duration)
        VB: Duration.Addition(Duration, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Addition(NodaTime.Duration, NodaTime.Duration)
        VB: NodaTime.Duration.Addition(NodaTime.Duration, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Addition
        path: src/NodaTime/Duration.cs
        startLine: 204
      summary: "\nImplements the operator + (addition).\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration operator +(Duration left, Duration right)
          VB: Public Shared Operator +(left As Duration, right As Duration) As Duration
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the sum of the given values.
      overload: NodaTime.Duration.op_Addition*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.Add(NodaTime.Duration,NodaTime.Duration)
      commentId: M:NodaTime.Duration.Add(NodaTime.Duration,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Add(Duration, Duration)
        VB: Add(Duration, Duration)
      nameWithType:
        CSharp: Duration.Add(Duration, Duration)
        VB: Duration.Add(Duration, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Add(NodaTime.Duration, NodaTime.Duration)
        VB: NodaTime.Duration.Add(NodaTime.Duration, NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Add
        path: src/NodaTime/Duration.cs
        startLine: 215
      summary: "\nAdds one duration to another. Friendly alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration Add(Duration left, Duration right)
          VB: Public Shared Function Add(left As Duration, right As Duration) As Duration
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the sum of the given values.
      overload: NodaTime.Duration.Add*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.Plus(NodaTime.Duration)
      commentId: M:NodaTime.Duration.Plus(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Plus(Duration)
        VB: Plus(Duration)
      nameWithType:
        CSharp: Duration.Plus(Duration)
        VB: Duration.Plus(Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Plus(NodaTime.Duration)
        VB: NodaTime.Duration.Plus(NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Plus
        path: src/NodaTime/Duration.cs
        startLine: 225
      summary: "\nReturns the result of adding another duration to this one, for a fluent alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public Duration Plus(Duration other)
          VB: Public Function Plus(other As Duration) As Duration
        parameters:
        - id: other
          type: NodaTime.Duration
          description: The duration to add
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the result of the addition.
      overload: NodaTime.Duration.Plus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.op_Subtraction(NodaTime.Duration,NodaTime.Duration)
      commentId: M:NodaTime.Duration.op_Subtraction(NodaTime.Duration,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Subtraction(Duration, Duration)
        VB: Subtraction(Duration, Duration)
      nameWithType:
        CSharp: Duration.Subtraction(Duration, Duration)
        VB: Duration.Subtraction(Duration, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Subtraction(NodaTime.Duration, NodaTime.Duration)
        VB: NodaTime.Duration.Subtraction(NodaTime.Duration, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Subtraction
        path: src/NodaTime/Duration.cs
        startLine: 236
      summary: "\nImplements the operator - (subtraction).\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration operator -(Duration left, Duration right)
          VB: Public Shared Operator -(left As Duration, right As Duration) As Duration
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the difference of the given values.
      overload: NodaTime.Duration.op_Subtraction*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.Subtract(NodaTime.Duration,NodaTime.Duration)
      commentId: M:NodaTime.Duration.Subtract(NodaTime.Duration,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Subtract(Duration, Duration)
        VB: Subtract(Duration, Duration)
      nameWithType:
        CSharp: Duration.Subtract(Duration, Duration)
        VB: Duration.Subtract(Duration, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Subtract(NodaTime.Duration, NodaTime.Duration)
        VB: NodaTime.Duration.Subtract(NodaTime.Duration, NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Subtract
        path: src/NodaTime/Duration.cs
        startLine: 247
      summary: "\nSubtracts one duration from another. Friendly alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration Subtract(Duration left, Duration right)
          VB: Public Shared Function Subtract(left As Duration, right As Duration) As Duration
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the difference of the given values.
      overload: NodaTime.Duration.Subtract*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.Minus(NodaTime.Duration)
      commentId: M:NodaTime.Duration.Minus(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Minus(Duration)
        VB: Minus(Duration)
      nameWithType:
        CSharp: Duration.Minus(Duration)
        VB: Duration.Minus(Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Minus(NodaTime.Duration)
        VB: NodaTime.Duration.Minus(NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minus
        path: src/NodaTime/Duration.cs
        startLine: 257
      summary: "\nReturns the result of subtracting another duration from this one, for a fluent alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public Duration Minus(Duration other)
          VB: Public Function Minus(other As Duration) As Duration
        parameters:
        - id: other
          type: NodaTime.Duration
          description: The duration to subtract
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the result of the subtraction.
      overload: NodaTime.Duration.Minus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.op_Division(NodaTime.Duration,System.Int64)
      commentId: M:NodaTime.Duration.op_Division(NodaTime.Duration,System.Int64)
      language: CSharp
      name:
        CSharp: Division(Duration, Int64)
        VB: Division(Duration, Int64)
      nameWithType:
        CSharp: Duration.Division(Duration, Int64)
        VB: Duration.Division(Duration, Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.Division(NodaTime.Duration, System.Int64)
        VB: NodaTime.Duration.Division(NodaTime.Duration, System.Int64)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Division
        path: src/NodaTime/Duration.cs
        startLine: 269
      summary: "\nImplements the operator / (division).\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration operator /(Duration left, long right)
          VB: Public Shared Operator /(left As Duration, right As Long) As Duration
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: System.Int64
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: >-
            A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the result of dividing <span class="paramref">left</span> by

            <span class="paramref">right</span>.
      overload: NodaTime.Duration.op_Division*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.Divide(NodaTime.Duration,System.Int64)
      commentId: M:NodaTime.Duration.Divide(NodaTime.Duration,System.Int64)
      language: CSharp
      name:
        CSharp: Divide(Duration, Int64)
        VB: Divide(Duration, Int64)
      nameWithType:
        CSharp: Duration.Divide(Duration, Int64)
        VB: Duration.Divide(Duration, Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.Divide(NodaTime.Duration, System.Int64)
        VB: NodaTime.Duration.Divide(NodaTime.Duration, System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Divide
        path: src/NodaTime/Duration.cs
        startLine: 281
      summary: "\nDivides a duration by a number. Friendly alternative to <code>operator/()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration Divide(Duration left, long right)
          VB: Public Shared Function Divide(left As Duration, right As Long) As Duration
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: System.Int64
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: >-
            A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the result of dividing <span class="paramref">left</span> by

            <span class="paramref">right</span>.
      overload: NodaTime.Duration.Divide*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.op_Multiply(NodaTime.Duration,System.Int64)
      commentId: M:NodaTime.Duration.op_Multiply(NodaTime.Duration,System.Int64)
      language: CSharp
      name:
        CSharp: Multiply(Duration, Int64)
        VB: Multiply(Duration, Int64)
      nameWithType:
        CSharp: Duration.Multiply(Duration, Int64)
        VB: Duration.Multiply(Duration, Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.Multiply(NodaTime.Duration, System.Int64)
        VB: NodaTime.Duration.Multiply(NodaTime.Duration, System.Int64)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Multiply
        path: src/NodaTime/Duration.cs
        startLine: 293
      summary: "\nImplements the operator * (multiplication).\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration operator *(Duration left, long right)
          VB: Public Shared Operator *(left As Duration, right As Long) As Duration
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: System.Int64
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: >-
            A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the result of multiplying <span class="paramref">left</span> by

            <span class="paramref">right</span>.
      overload: NodaTime.Duration.op_Multiply*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.op_Multiply(System.Int64,NodaTime.Duration)
      commentId: M:NodaTime.Duration.op_Multiply(System.Int64,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Multiply(Int64, Duration)
        VB: Multiply(Int64, Duration)
      nameWithType:
        CSharp: Duration.Multiply(Int64, Duration)
        VB: Duration.Multiply(Int64, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Multiply(System.Int64, NodaTime.Duration)
        VB: NodaTime.Duration.Multiply(System.Int64, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Multiply
        path: src/NodaTime/Duration.cs
        startLine: 305
      summary: "\nImplements the operator * (multiplication).\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration operator *(long left, Duration right)
          VB: Public Shared Operator *(left As Long, right As Duration) As Duration
        parameters:
        - id: left
          type: System.Int64
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: >-
            A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the result of multiplying <span class="paramref">left</span> by

            <span class="paramref">right</span>.
      overload: NodaTime.Duration.op_Multiply*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.Multiply(NodaTime.Duration,System.Int64)
      commentId: M:NodaTime.Duration.Multiply(NodaTime.Duration,System.Int64)
      language: CSharp
      name:
        CSharp: Multiply(Duration, Int64)
        VB: Multiply(Duration, Int64)
      nameWithType:
        CSharp: Duration.Multiply(Duration, Int64)
        VB: Duration.Multiply(Duration, Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.Multiply(NodaTime.Duration, System.Int64)
        VB: NodaTime.Duration.Multiply(NodaTime.Duration, System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Multiply
        path: src/NodaTime/Duration.cs
        startLine: 316
      summary: "\nMultiplies a duration by a number. Friendly alternative to <code>operator*()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration Multiply(Duration left, long right)
          VB: Public Shared Function Multiply(left As Duration, right As Long) As Duration
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: System.Int64
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the product of the given values.
      overload: NodaTime.Duration.Multiply*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.Multiply(System.Int64,NodaTime.Duration)
      commentId: M:NodaTime.Duration.Multiply(System.Int64,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Multiply(Int64, Duration)
        VB: Multiply(Int64, Duration)
      nameWithType:
        CSharp: Duration.Multiply(Int64, Duration)
        VB: Duration.Multiply(Int64, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Multiply(System.Int64, NodaTime.Duration)
        VB: NodaTime.Duration.Multiply(System.Int64, NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Multiply
        path: src/NodaTime/Duration.cs
        startLine: 327
      summary: "\nMultiplies a duration by a number. Friendly alternative to <code>operator*()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration Multiply(long left, Duration right)
          VB: Public Shared Function Multiply(left As Long, right As Duration) As Duration
        parameters:
        - id: left
          type: System.Int64
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the product of the given values.
      overload: NodaTime.Duration.Multiply*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.op_Equality(NodaTime.Duration,NodaTime.Duration)
      commentId: M:NodaTime.Duration.op_Equality(NodaTime.Duration,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Equality(Duration, Duration)
        VB: Equality(Duration, Duration)
      nameWithType:
        CSharp: Duration.Equality(Duration, Duration)
        VB: Duration.Equality(Duration, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Equality(NodaTime.Duration, NodaTime.Duration)
        VB: NodaTime.Duration.Equality(NodaTime.Duration, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Equality
        path: src/NodaTime/Duration.cs
        startLine: 338
      summary: "\nImplements the operator == (equality).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator ==(Duration left, Duration right)
          VB: Public Shared Operator =(left As Duration, right As Duration) As Boolean
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if values are equal to each other, otherwise <code>false</code>.
      overload: NodaTime.Duration.op_Equality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Duration.op_Inequality(NodaTime.Duration,NodaTime.Duration)
      commentId: M:NodaTime.Duration.op_Inequality(NodaTime.Duration,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Inequality(Duration, Duration)
        VB: Inequality(Duration, Duration)
      nameWithType:
        CSharp: Duration.Inequality(Duration, Duration)
        VB: Duration.Inequality(Duration, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Inequality(NodaTime.Duration, NodaTime.Duration)
        VB: NodaTime.Duration.Inequality(NodaTime.Duration, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Inequality
        path: src/NodaTime/Duration.cs
        startLine: 349
      summary: "\nImplements the operator != (inequality).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator !=(Duration left, Duration right)
          VB: Public Shared Operator <>(left As Duration, right As Duration) As Boolean
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if values are not equal to each other, otherwise <code>false</code>.
      overload: NodaTime.Duration.op_Inequality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Duration.op_LessThan(NodaTime.Duration,NodaTime.Duration)
      commentId: M:NodaTime.Duration.op_LessThan(NodaTime.Duration,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: LessThan(Duration, Duration)
        VB: LessThan(Duration, Duration)
      nameWithType:
        CSharp: Duration.LessThan(Duration, Duration)
        VB: Duration.LessThan(Duration, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.LessThan(NodaTime.Duration, NodaTime.Duration)
        VB: NodaTime.Duration.LessThan(NodaTime.Duration, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThan
        path: src/NodaTime/Duration.cs
        startLine: 360
      summary: "\nImplements the operator &lt; (less than).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <(Duration left, Duration right)
          VB: Public Shared Operator <(left As Duration, right As Duration) As Boolean
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is less than the right value, otherwise <code>false</code>.
      overload: NodaTime.Duration.op_LessThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Duration.op_LessThanOrEqual(NodaTime.Duration,NodaTime.Duration)
      commentId: M:NodaTime.Duration.op_LessThanOrEqual(NodaTime.Duration,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: LessThanOrEqual(Duration, Duration)
        VB: LessThanOrEqual(Duration, Duration)
      nameWithType:
        CSharp: Duration.LessThanOrEqual(Duration, Duration)
        VB: Duration.LessThanOrEqual(Duration, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.LessThanOrEqual(NodaTime.Duration, NodaTime.Duration)
        VB: NodaTime.Duration.LessThanOrEqual(NodaTime.Duration, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThanOrEqual
        path: src/NodaTime/Duration.cs
        startLine: 371
      summary: "\nImplements the operator &lt;= (less than or equal).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <=(Duration left, Duration right)
          VB: Public Shared Operator <=(left As Duration, right As Duration) As Boolean
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is less than or equal to the right value, otherwise <code>false</code>.
      overload: NodaTime.Duration.op_LessThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Duration.op_GreaterThan(NodaTime.Duration,NodaTime.Duration)
      commentId: M:NodaTime.Duration.op_GreaterThan(NodaTime.Duration,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: GreaterThan(Duration, Duration)
        VB: GreaterThan(Duration, Duration)
      nameWithType:
        CSharp: Duration.GreaterThan(Duration, Duration)
        VB: Duration.GreaterThan(Duration, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.GreaterThan(NodaTime.Duration, NodaTime.Duration)
        VB: NodaTime.Duration.GreaterThan(NodaTime.Duration, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThan
        path: src/NodaTime/Duration.cs
        startLine: 382
      summary: "\nImplements the operator &gt; (greater than).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator>(Duration left, Duration right)
          VB: Public Shared Operator>(left As Duration, right As Duration) As Boolean
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is greater than the right value, otherwise <code>false</code>.
      overload: NodaTime.Duration.op_GreaterThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Duration.op_GreaterThanOrEqual(NodaTime.Duration,NodaTime.Duration)
      commentId: M:NodaTime.Duration.op_GreaterThanOrEqual(NodaTime.Duration,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: GreaterThanOrEqual(Duration, Duration)
        VB: GreaterThanOrEqual(Duration, Duration)
      nameWithType:
        CSharp: Duration.GreaterThanOrEqual(Duration, Duration)
        VB: Duration.GreaterThanOrEqual(Duration, Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.GreaterThanOrEqual(NodaTime.Duration, NodaTime.Duration)
        VB: NodaTime.Duration.GreaterThanOrEqual(NodaTime.Duration, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThanOrEqual
        path: src/NodaTime/Duration.cs
        startLine: 393
      summary: "\nImplements the operator &gt;= (greater than or equal).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator >=(Duration left, Duration right)
          VB: Public Shared Operator >=(left As Duration, right As Duration) As Boolean
        parameters:
        - id: left
          type: NodaTime.Duration
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is greater than or equal to the right value, otherwise <code>false</code>.
      overload: NodaTime.Duration.op_GreaterThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Duration.op_UnaryNegation(NodaTime.Duration)
      commentId: M:NodaTime.Duration.op_UnaryNegation(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: UnaryNegation(Duration)
        VB: UnaryNegation(Duration)
      nameWithType:
        CSharp: Duration.UnaryNegation(Duration)
        VB: Duration.UnaryNegation(Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.UnaryNegation(NodaTime.Duration)
        VB: NodaTime.Duration.UnaryNegation(NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_UnaryNegation
        path: src/NodaTime/Duration.cs
        startLine: 403
      summary: "\nImplements the unary negation operator.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration operator -(Duration duration)
          VB: Public Shared Operator -(duration As Duration) As Duration
        parameters:
        - id: duration
          type: NodaTime.Duration
          description: Duration to negate
        return:
          type: NodaTime.Duration
          description: The negative value of this duration
      overload: NodaTime.Duration.op_UnaryNegation*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Duration.Negate(NodaTime.Duration)
      commentId: M:NodaTime.Duration.Negate(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Negate(Duration)
        VB: Negate(Duration)
      nameWithType:
        CSharp: Duration.Negate(Duration)
        VB: Duration.Negate(Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Negate(NodaTime.Duration)
        VB: NodaTime.Duration.Negate(NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Negate
        path: src/NodaTime/Duration.cs
        startLine: 413
      summary: "\nImplements a friendly alternative to the unary negation operator.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration Negate(Duration duration)
          VB: Public Shared Function Negate(duration As Duration) As Duration
        parameters:
        - id: duration
          type: NodaTime.Duration
          description: Duration to negate
        return:
          type: NodaTime.Duration
          description: The negative value of this duration
      overload: NodaTime.Duration.Negate*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Duration.CompareTo(NodaTime.Duration)
      commentId: M:NodaTime.Duration.CompareTo(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: CompareTo(Duration)
        VB: CompareTo(Duration)
      nameWithType:
        CSharp: Duration.CompareTo(Duration)
        VB: Duration.CompareTo(Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.CompareTo(NodaTime.Duration)
        VB: NodaTime.Duration.CompareTo(NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CompareTo
        path: src/NodaTime/Duration.cs
        startLine: 446
      summary: "\nCompares the current object with another object of the same type.\n"
      example: []
      syntax:
        content:
          CSharp: public int CompareTo(Duration other)
          VB: Public Function CompareTo(other As Duration) As Integer
        parameters:
        - id: other
          type: NodaTime.Duration
          description: An object to compare with this object.
        return:
          type: System.Int32
          description: "\nA 32-bit signed integer that indicates the relative order of the objects being compared.\nThe return value has the following meanings:\n<table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>&lt; 0</td><td>This object is less than the <span class=\"paramref\">other</span> parameter.</td></tr><tr><td>0</td><td>This object is equal to <span class=\"paramref\">other</span>.</td></tr><tr><td>&gt; 0</td><td>This object is greater than <span class=\"paramref\">other</span>.</td></tr></tbody></table>\n"
      overload: NodaTime.Duration.CompareTo*
      implements:
      - System.IComparable{NodaTime.Duration}.CompareTo(NodaTime.Duration)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - isEii: true
      id: NodaTime.Duration.System#IComparable#CompareTo(System.Object)
      commentId: M:NodaTime.Duration.System#IComparable#CompareTo(System.Object)
      language: CSharp
      name:
        CSharp: IComparable.CompareTo(Object)
        VB: System.IComparable.CompareTo(Object)
      nameWithType:
        CSharp: Duration.IComparable.CompareTo(Object)
        VB: Duration.System.IComparable.CompareTo(Object)
      qualifiedName:
        CSharp: NodaTime.Duration.System.IComparable.CompareTo(System.Object)
        VB: NodaTime.Duration.System.IComparable.CompareTo(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.IComparable.CompareTo
        path: src/NodaTime/Duration.cs
        startLine: 462
      summary: "\nImplementation of <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to compare two offsets.\n"
      remarks: "\nThis uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.\n"
      example: []
      syntax:
        content:
          CSharp: int IComparable.CompareTo(object obj)
          VB: Function System.IComparable.CompareTo(obj As Object) As Integer Implements IComparable.CompareTo
        parameters:
        - id: obj
          type: System.Object
          description: The object to compare this value with.
        return:
          type: System.Int32
          description: >
            The result of comparing this instant with another one; see <xref href="NodaTime.Duration.CompareTo(NodaTime.Duration)" data-throw-if-not-resolved="false"></xref> for general details.

            If <span class="paramref">obj</span> is null, this method returns a value greater than 0.
      overload: NodaTime.Duration.System#IComparable#CompareTo*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">obj</span> is non-null but does not refer to an instance of <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref>.
      implements:
      - System.IComparable.CompareTo(System.Object)
      modifiers:
        CSharp: []
        VB: []
      references:
        System.IComparable.CompareTo(System.Object): 
        NodaTime.Duration: 
        NodaTime.Duration.CompareTo(NodaTime.Duration): 
    - id: NodaTime.Duration.Equals(NodaTime.Duration)
      commentId: M:NodaTime.Duration.Equals(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Equals(Duration)
        VB: Equals(Duration)
      nameWithType:
        CSharp: Duration.Equals(Duration)
        VB: Duration.Equals(Duration)
      qualifiedName:
        CSharp: NodaTime.Duration.Equals(NodaTime.Duration)
        VB: NodaTime.Duration.Equals(NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/Duration.cs
        startLine: 482
      summary: "\nIndicates whether the current object is equal to another object of the same type.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(Duration other)
          VB: Public Function Equals(other As Duration) As Boolean
        parameters:
        - id: other
          type: NodaTime.Duration
          description: An object to compare with this object.
        return:
          type: System.Boolean
          description: "\ntrue if the current object is equal to the <span class=\"paramref\">other</span> parameter;\notherwise, false.\n"
      overload: NodaTime.Duration.Equals*
      implements:
      - System.IEquatable{NodaTime.Duration}.Equals(NodaTime.Duration)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Duration.FromStandardWeeks(System.Int64)
      commentId: M:NodaTime.Duration.FromStandardWeeks(System.Int64)
      language: CSharp
      name:
        CSharp: FromStandardWeeks(Int64)
        VB: FromStandardWeeks(Int64)
      nameWithType:
        CSharp: Duration.FromStandardWeeks(Int64)
        VB: Duration.FromStandardWeeks(Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.FromStandardWeeks(System.Int64)
        VB: NodaTime.Duration.FromStandardWeeks(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromStandardWeeks
        path: src/NodaTime/Duration.cs
        startLine: 494
      summary: "\nReturns a <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> that represents the given number of weeks, assuming a 'standard' week\nconsisting of seven 24-hour days.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration FromStandardWeeks(long weeks)
          VB: Public Shared Function FromStandardWeeks(weeks As Long) As Duration
        parameters:
        - id: weeks
          type: System.Int64
          description: The number of weeks.
        return:
          type: NodaTime.Duration
          description: A <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the given number of weeks.
      overload: NodaTime.Duration.FromStandardWeeks*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.FromStandardDays(System.Int64)
      commentId: M:NodaTime.Duration.FromStandardDays(System.Int64)
      language: CSharp
      name:
        CSharp: FromStandardDays(Int64)
        VB: FromStandardDays(Int64)
      nameWithType:
        CSharp: Duration.FromStandardDays(Int64)
        VB: Duration.FromStandardDays(Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.FromStandardDays(System.Int64)
        VB: NodaTime.Duration.FromStandardDays(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromStandardDays
        path: src/NodaTime/Duration.cs
        startLine: 505
      summary: "\nReturns a <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> that represents the given number of days, assuming a 'standard' 24-hour\nday.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration FromStandardDays(long days)
          VB: Public Shared Function FromStandardDays(days As Long) As Duration
        parameters:
        - id: days
          type: System.Int64
          description: The number of days.
        return:
          type: NodaTime.Duration
          description: A <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the given number of days.
      overload: NodaTime.Duration.FromStandardDays*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.FromHours(System.Int64)
      commentId: M:NodaTime.Duration.FromHours(System.Int64)
      language: CSharp
      name:
        CSharp: FromHours(Int64)
        VB: FromHours(Int64)
      nameWithType:
        CSharp: Duration.FromHours(Int64)
        VB: Duration.FromHours(Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.FromHours(System.Int64)
        VB: NodaTime.Duration.FromHours(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromHours
        path: src/NodaTime/Duration.cs
        startLine: 515
      summary: "\nReturns a <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> that represents the given number of hours.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration FromHours(long hours)
          VB: Public Shared Function FromHours(hours As Long) As Duration
        parameters:
        - id: hours
          type: System.Int64
          description: The number of hours.
        return:
          type: NodaTime.Duration
          description: A <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the given number of hours.
      overload: NodaTime.Duration.FromHours*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.FromMinutes(System.Int64)
      commentId: M:NodaTime.Duration.FromMinutes(System.Int64)
      language: CSharp
      name:
        CSharp: FromMinutes(Int64)
        VB: FromMinutes(Int64)
      nameWithType:
        CSharp: Duration.FromMinutes(Int64)
        VB: Duration.FromMinutes(Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.FromMinutes(System.Int64)
        VB: NodaTime.Duration.FromMinutes(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromMinutes
        path: src/NodaTime/Duration.cs
        startLine: 525
      summary: "\nReturns a <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> that represents the given number of minutes.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration FromMinutes(long minutes)
          VB: Public Shared Function FromMinutes(minutes As Long) As Duration
        parameters:
        - id: minutes
          type: System.Int64
          description: The number of minutes.
        return:
          type: NodaTime.Duration
          description: A <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the given number of minutes.
      overload: NodaTime.Duration.FromMinutes*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.FromSeconds(System.Int64)
      commentId: M:NodaTime.Duration.FromSeconds(System.Int64)
      language: CSharp
      name:
        CSharp: FromSeconds(Int64)
        VB: FromSeconds(Int64)
      nameWithType:
        CSharp: Duration.FromSeconds(Int64)
        VB: Duration.FromSeconds(Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.FromSeconds(System.Int64)
        VB: NodaTime.Duration.FromSeconds(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromSeconds
        path: src/NodaTime/Duration.cs
        startLine: 535
      summary: "\nReturns a <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> that represents the given number of seconds.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration FromSeconds(long seconds)
          VB: Public Shared Function FromSeconds(seconds As Long) As Duration
        parameters:
        - id: seconds
          type: System.Int64
          description: The number of seconds.
        return:
          type: NodaTime.Duration
          description: A <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the given number of seconds.
      overload: NodaTime.Duration.FromSeconds*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.FromMilliseconds(System.Int64)
      commentId: M:NodaTime.Duration.FromMilliseconds(System.Int64)
      language: CSharp
      name:
        CSharp: FromMilliseconds(Int64)
        VB: FromMilliseconds(Int64)
      nameWithType:
        CSharp: Duration.FromMilliseconds(Int64)
        VB: Duration.FromMilliseconds(Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.FromMilliseconds(System.Int64)
        VB: NodaTime.Duration.FromMilliseconds(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromMilliseconds
        path: src/NodaTime/Duration.cs
        startLine: 545
      summary: "\nReturns a <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> that represents the given number of milliseconds.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration FromMilliseconds(long milliseconds)
          VB: Public Shared Function FromMilliseconds(milliseconds As Long) As Duration
        parameters:
        - id: milliseconds
          type: System.Int64
          description: The number of milliseconds.
        return:
          type: NodaTime.Duration
          description: A <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the given number of milliseconds.
      overload: NodaTime.Duration.FromMilliseconds*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.FromTicks(System.Int64)
      commentId: M:NodaTime.Duration.FromTicks(System.Int64)
      language: CSharp
      name:
        CSharp: FromTicks(Int64)
        VB: FromTicks(Int64)
      nameWithType:
        CSharp: Duration.FromTicks(Int64)
        VB: Duration.FromTicks(Int64)
      qualifiedName:
        CSharp: NodaTime.Duration.FromTicks(System.Int64)
        VB: NodaTime.Duration.FromTicks(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromTicks
        path: src/NodaTime/Duration.cs
        startLine: 555
      summary: "\nReturns a <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> that represents the given number of ticks.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration FromTicks(long ticks)
          VB: Public Shared Function FromTicks(ticks As Long) As Duration
        parameters:
        - id: ticks
          type: System.Int64
          description: The number of ticks.
        return:
          type: NodaTime.Duration
          description: A <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the given number of ticks.
      overload: NodaTime.Duration.FromTicks*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Duration.FromTimeSpan(System.TimeSpan)
      commentId: M:NodaTime.Duration.FromTimeSpan(System.TimeSpan)
      language: CSharp
      name:
        CSharp: FromTimeSpan(TimeSpan)
        VB: FromTimeSpan(TimeSpan)
      nameWithType:
        CSharp: Duration.FromTimeSpan(TimeSpan)
        VB: Duration.FromTimeSpan(TimeSpan)
      qualifiedName:
        CSharp: NodaTime.Duration.FromTimeSpan(System.TimeSpan)
        VB: NodaTime.Duration.FromTimeSpan(System.TimeSpan)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromTimeSpan
        path: src/NodaTime/Duration.cs
        startLine: 566
      summary: "\nReturns a <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> that represents the same number of ticks as the\ngiven <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration FromTimeSpan(TimeSpan timeSpan)
          VB: Public Shared Function FromTimeSpan(timeSpan As TimeSpan) As Duration
        parameters:
        - id: timeSpan
          type: System.TimeSpan
          description: The TimeSpan value to convert
        return:
          type: NodaTime.Duration
          description: A new Duration with the same number of ticks as the given TimeSpan.
      overload: NodaTime.Duration.FromTimeSpan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
        System.TimeSpan: 
    - id: NodaTime.Duration.ToTimeSpan
      commentId: M:NodaTime.Duration.ToTimeSpan
      language: CSharp
      name:
        CSharp: ToTimeSpan()
        VB: ToTimeSpan()
      nameWithType:
        CSharp: Duration.ToTimeSpan()
        VB: Duration.ToTimeSpan()
      qualifiedName:
        CSharp: NodaTime.Duration.ToTimeSpan()
        VB: NodaTime.Duration.ToTimeSpan()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToTimeSpan
        path: src/NodaTime/Duration.cs
        startLine: 576
      summary: "\nReturns a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents the same number of ticks as this\n<xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public TimeSpan ToTimeSpan()
          VB: Public Function ToTimeSpan As TimeSpan
        return:
          type: System.TimeSpan
          description: A new TimeSpan with the same number of ticks as this Duration.
      overload: NodaTime.Duration.ToTimeSpan*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.TimeSpan: 
        NodaTime.Duration: 
    - isEii: true
      id: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#GetSchema
      commentId: M:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#GetSchema
      language: CSharp
      name:
        CSharp: IXmlSerializable.GetSchema()
        VB: System.Xml.Serialization.IXmlSerializable.GetSchema()
      nameWithType:
        CSharp: Duration.IXmlSerializable.GetSchema()
        VB: Duration.System.Xml.Serialization.IXmlSerializable.GetSchema()
      qualifiedName:
        CSharp: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.GetSchema()
        VB: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.GetSchema()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.GetSchema
        path: src/NodaTime/Duration.cs
        startLine: 583
      example: []
      syntax:
        content:
          CSharp: XmlSchema IXmlSerializable.GetSchema()
          VB: Function System.Xml.Serialization.IXmlSerializable.GetSchema As XmlSchema Implements IXmlSerializable.GetSchema
        return:
          type: System.Xml.Schema.XmlSchema
      overload: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#GetSchema*
      implements:
      - System.Xml.Serialization.IXmlSerializable.GetSchema
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      commentId: M:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      language: CSharp
      name:
        CSharp: IXmlSerializable.ReadXml(XmlReader)
        VB: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      nameWithType:
        CSharp: Duration.IXmlSerializable.ReadXml(XmlReader)
        VB: Duration.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      qualifiedName:
        CSharp: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        VB: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.ReadXml
        path: src/NodaTime/Duration.cs
        startLine: 589
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.ReadXml(XmlReader reader)
          VB: Sub System.Xml.Serialization.IXmlSerializable.ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
        parameters:
        - id: reader
          type: System.Xml.XmlReader
      overload: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#ReadXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      commentId: M:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      language: CSharp
      name:
        CSharp: IXmlSerializable.WriteXml(XmlWriter)
        VB: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      nameWithType:
        CSharp: Duration.IXmlSerializable.WriteXml(XmlWriter)
        VB: Duration.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      qualifiedName:
        CSharp: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        VB: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.WriteXml
        path: src/NodaTime/Duration.cs
        startLine: 598
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.WriteXml(XmlWriter writer)
          VB: Sub System.Xml.Serialization.IXmlSerializable.WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
        parameters:
        - id: writer
          type: System.Xml.XmlWriter
      overload: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#WriteXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Duration.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:NodaTime.Duration.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: Duration.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: Duration.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: NodaTime.Duration.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: NodaTime.Duration.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Duration.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Runtime.Serialization.ISerializable.GetObjectData
        path: src/NodaTime/Duration.cs
        startLine: 624
      summary: "\nImplementation of <xref href=\"System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo%2cSystem.Runtime.Serialization.StreamingContext)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
          VB: Sub System.Runtime.Serialization.ISerializable.GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: The <xref href="System.Runtime.Serialization.SerializationInfo" data-throw-if-not-resolved="false"></xref> to populate with data.
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: The destination for this serialization.
      overload: NodaTime.Duration.System#Runtime#Serialization#ISerializable#GetObjectData*
      implements:
      - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      modifiers:
        CSharp: []
        VB: []
      references:
        ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        : 
        System.Runtime.Serialization.SerializationInfo: 
    references:
      NodaTime.Instant: 
      NodaTime.Period: 
      NodaTime.Duration: 
      NodaTime.ZonedDateTime: 
      NodaTime.LocalDateTime: 
  - id: NodaTime.Instant
    commentId: T:NodaTime.Instant
    language: CSharp
    name:
      CSharp: Instant
      VB: Instant
    nameWithType:
      CSharp: Instant
      VB: Instant
    qualifiedName:
      CSharp: NodaTime.Instant
      VB: NodaTime.Instant
    type: Struct
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/Instant.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: Instant
      path: src/NodaTime/Instant.cs
      startLine: 31
    summary: "\nRepresents an instant on the global timeline.\n"
    remarks: "\n<p>\nAn instant is defined by an integral number of 'ticks' since the Unix epoch (typically described as January 1st\n1970, midnight, UTC, ISO calendar), where a tick is equal to 100 nanoseconds. There are 10,000 ticks in a\nmillisecond.\n</p>\n<p>\nAn <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> has no concept of a particular time zone or calendar: it simply represents a point in\ntime that can be globally agreed-upon.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public struct Instant : IEquatable<Instant>, IComparable<Instant>, IFormattable, IComparable, IXmlSerializable, ISerializable
        VB: >-
          <Serializable>

          Public Structure Instant

              Implements IEquatable(Of Instant), IComparable(Of Instant), IFormattable, IComparable, IXmlSerializable, ISerializable
    implements:
    - System.IEquatable{NodaTime.Instant}
    - System.IComparable{NodaTime.Instant}
    - System.IFormattable
    - System.IComparable
    - System.Xml.Serialization.IXmlSerializable
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: NodaTime.Instant.MinValue
      commentId: F:NodaTime.Instant.MinValue
      language: CSharp
      name:
        CSharp: MinValue
        VB: MinValue
      nameWithType:
        CSharp: Instant.MinValue
        VB: Instant.MinValue
      qualifiedName:
        CSharp: NodaTime.Instant.MinValue
        VB: NodaTime.Instant.MinValue
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MinValue
        path: src/NodaTime/Instant.cs
        startLine: 44
      summary: "\nRepresents the smallest possible <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      remarks: "\nWithin Noda Time, this is also used to represent 'the beginning of time'.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Instant MinValue
          VB: Public Shared ReadOnly MinValue As Instant
        return:
          type: NodaTime.Instant
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.MaxValue
      commentId: F:NodaTime.Instant.MaxValue
      language: CSharp
      name:
        CSharp: MaxValue
        VB: MaxValue
      nameWithType:
        CSharp: Instant.MaxValue
        VB: Instant.MaxValue
      qualifiedName:
        CSharp: NodaTime.Instant.MaxValue
        VB: NodaTime.Instant.MaxValue
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MaxValue
        path: src/NodaTime/Instant.cs
        startLine: 51
      summary: "\nRepresents the largest possible <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      remarks: "\nWithin Noda Time, this is also used to represent 'the end of time'.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Instant MaxValue
          VB: Public Shared ReadOnly MaxValue As Instant
        return:
          type: NodaTime.Instant
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.#ctor(System.Int64)
      commentId: M:NodaTime.Instant.#ctor(System.Int64)
      language: CSharp
      name:
        CSharp: Instant(Int64)
        VB: Instant(Int64)
      nameWithType:
        CSharp: Instant.Instant(Int64)
        VB: Instant.Instant(Int64)
      qualifiedName:
        CSharp: NodaTime.Instant.Instant(System.Int64)
        VB: NodaTime.Instant.Instant(System.Int64)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/Instant.cs
        startLine: 67
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> struct.\n"
      remarks: "\nNote that while the Noda Time <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> type and BCL <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> and\n<xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> types are all defined in terms of a number of ticks, they use different\norigins: the Noda Time types count ticks from the Unix epoch (the start of 1970 AD), while the BCL types\ncount from the start of 1 AD. This constructor requires the former; to convert from a number-of-ticks since\nthe BCL epoch, construct a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> first, then use <xref href=\"NodaTime.Instant.FromDateTimeUtc(System.DateTime)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant(long ticks)
          VB: Public Sub New(ticks As Long)
        parameters:
        - id: ticks
          type: System.Int64
          description: >-
            The number of ticks since the Unix epoch. Negative values represent instants before the

            Unix epoch.
      overload: NodaTime.Instant.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Instant: 
        System.DateTime: 
        System.DateTimeOffset: 
        NodaTime.Instant.FromDateTimeUtc(System.DateTime): 
    - id: NodaTime.Instant.Ticks
      commentId: P:NodaTime.Instant.Ticks
      language: CSharp
      name:
        CSharp: Ticks
        VB: Ticks
      nameWithType:
        CSharp: Instant.Ticks
        VB: Instant.Ticks
      qualifiedName:
        CSharp: NodaTime.Instant.Ticks
        VB: NodaTime.Instant.Ticks
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Ticks
        path: src/NodaTime/Instant.cs
        startLine: 78
      summary: "\nThe number of ticks since the Unix epoch. Negative values represent instants before the Unix epoch.\n"
      remarks: "\nA tick is equal to 100 nanoseconds. There are 10,000 ticks in a millisecond.\n"
      example: []
      syntax:
        content:
          CSharp: public long Ticks { get; }
          VB: Public ReadOnly Property Ticks As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.Instant.Ticks*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Instant.CompareTo(NodaTime.Instant)
      commentId: M:NodaTime.Instant.CompareTo(NodaTime.Instant)
      language: CSharp
      name:
        CSharp: CompareTo(Instant)
        VB: CompareTo(Instant)
      nameWithType:
        CSharp: Instant.CompareTo(Instant)
        VB: Instant.CompareTo(Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.CompareTo(NodaTime.Instant)
        VB: NodaTime.Instant.CompareTo(NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CompareTo
        path: src/NodaTime/Instant.cs
        startLine: 107
      summary: "\nCompares the current object with another object of the same type.\n"
      example: []
      syntax:
        content:
          CSharp: public int CompareTo(Instant other)
          VB: Public Function CompareTo(other As Instant) As Integer
        parameters:
        - id: other
          type: NodaTime.Instant
          description: An object to compare with this object.
        return:
          type: System.Int32
          description: "\nA 32-bit signed integer that indicates the relative order of the objects being compared.\nThe return value has the following meanings:\n<table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>&lt; 0</td><td>This object is less than the <span class=\"paramref\">other</span> parameter.</td></tr><tr><td>0</td><td>This object is equal to <span class=\"paramref\">other</span>.</td></tr><tr><td>&gt; 0</td><td>This object is greater than <span class=\"paramref\">other</span>.</td></tr></tbody></table>\n"
      overload: NodaTime.Instant.CompareTo*
      implements:
      - System.IComparable{NodaTime.Instant}.CompareTo(NodaTime.Instant)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - isEii: true
      id: NodaTime.Instant.System#IComparable#CompareTo(System.Object)
      commentId: M:NodaTime.Instant.System#IComparable#CompareTo(System.Object)
      language: CSharp
      name:
        CSharp: IComparable.CompareTo(Object)
        VB: System.IComparable.CompareTo(Object)
      nameWithType:
        CSharp: Instant.IComparable.CompareTo(Object)
        VB: Instant.System.IComparable.CompareTo(Object)
      qualifiedName:
        CSharp: NodaTime.Instant.System.IComparable.CompareTo(System.Object)
        VB: NodaTime.Instant.System.IComparable.CompareTo(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.IComparable.CompareTo
        path: src/NodaTime/Instant.cs
        startLine: 123
      summary: "\nImplementation of <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to compare two instants.\n"
      remarks: "\nThis uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.\n"
      example: []
      syntax:
        content:
          CSharp: int IComparable.CompareTo(object obj)
          VB: Function System.IComparable.CompareTo(obj As Object) As Integer Implements IComparable.CompareTo
        parameters:
        - id: obj
          type: System.Object
          description: The object to compare this value with.
        return:
          type: System.Int32
          description: >
            The result of comparing this instant with another one; see <xref href="NodaTime.Instant.CompareTo(NodaTime.Instant)" data-throw-if-not-resolved="false"></xref> for general details.

            If <span class="paramref">obj</span> is null, this method returns a value greater than 0.
      overload: NodaTime.Instant.System#IComparable#CompareTo*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">obj</span> is non-null but does not refer to an instance of <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref>.
      implements:
      - System.IComparable.CompareTo(System.Object)
      modifiers:
        CSharp: []
        VB: []
      references:
        System.IComparable.CompareTo(System.Object): 
        NodaTime.Instant: 
        NodaTime.Instant.CompareTo(NodaTime.Instant): 
    - id: NodaTime.Instant.Equals(System.Object)
      commentId: M:NodaTime.Instant.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: Instant.Equals(Object)
        VB: Instant.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.Instant.Equals(System.Object)
        VB: NodaTime.Instant.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/Instant.cs
        startLine: 143
      summary: "\nDetermines whether the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: The <xref href="System.Object" data-throw-if-not-resolved="false"></xref> to compare with this instance.
        return:
          type: System.Boolean
          description: "\n<code>true</code> if the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance;\notherwise, <code>false</code>.\n"
      overload: NodaTime.Instant.Equals*
      overridden: System.ValueType.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.Object: 
    - id: NodaTime.Instant.GetHashCode
      commentId: M:NodaTime.Instant.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: Instant.GetHashCode()
        VB: Instant.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.Instant.GetHashCode()
        VB: NodaTime.Instant.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/Instant.cs
        startLine: 159
      summary: "\nReturns a hash code for this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: "\nA hash code for this instance, suitable for use in hashing algorithms and data\nstructures like a hash table. \n"
      overload: NodaTime.Instant.GetHashCode*
      overridden: System.ValueType.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.Instant.PlusTicks(System.Int64)
      commentId: M:NodaTime.Instant.PlusTicks(System.Int64)
      language: CSharp
      name:
        CSharp: PlusTicks(Int64)
        VB: PlusTicks(Int64)
      nameWithType:
        CSharp: Instant.PlusTicks(Int64)
        VB: Instant.PlusTicks(Int64)
      qualifiedName:
        CSharp: NodaTime.Instant.PlusTicks(System.Int64)
        VB: NodaTime.Instant.PlusTicks(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PlusTicks
        path: src/NodaTime/Instant.cs
        startLine: 170
      summary: "\nReturns a new value of this instant with the given number of ticks added to it.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant PlusTicks(long ticksToAdd)
          VB: Public Function PlusTicks(ticksToAdd As Long) As Instant
        parameters:
        - id: ticksToAdd
          type: System.Int64
          description: The ticks to add to this instant to create the return value.
        return:
          type: NodaTime.Instant
          description: The result of adding the given number of ticks to this instant.
      overload: NodaTime.Instant.PlusTicks*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Instant.op_Addition(NodaTime.Instant,NodaTime.Duration)
      commentId: M:NodaTime.Instant.op_Addition(NodaTime.Instant,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Addition(Instant, Duration)
        VB: Addition(Instant, Duration)
      nameWithType:
        CSharp: Instant.Addition(Instant, Duration)
        VB: Instant.Addition(Instant, Duration)
      qualifiedName:
        CSharp: NodaTime.Instant.Addition(NodaTime.Instant, NodaTime.Duration)
        VB: NodaTime.Instant.Addition(NodaTime.Instant, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Addition
        path: src/NodaTime/Instant.cs
        startLine: 182
      summary: "\nImplements the operator + (addition) for <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> + <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant operator +(Instant left, Duration right)
          VB: Public Shared Operator +(left As Instant, right As Duration) As Instant
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: NodaTime.Instant
          description: A new <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> representing the sum of the given values.
      overload: NodaTime.Instant.op_Addition*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Instant: 
        NodaTime.Duration: 
    - id: NodaTime.Instant.Add(NodaTime.Instant,NodaTime.Duration)
      commentId: M:NodaTime.Instant.Add(NodaTime.Instant,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Add(Instant, Duration)
        VB: Add(Instant, Duration)
      nameWithType:
        CSharp: Instant.Add(Instant, Duration)
        VB: Instant.Add(Instant, Duration)
      qualifiedName:
        CSharp: NodaTime.Instant.Add(NodaTime.Instant, NodaTime.Duration)
        VB: NodaTime.Instant.Add(NodaTime.Instant, NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Add
        path: src/NodaTime/Instant.cs
        startLine: 206
      summary: "\nAdds a duration to an instant. Friendly alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant Add(Instant left, Duration right)
          VB: Public Shared Function Add(left As Instant, right As Duration) As Instant
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: NodaTime.Instant
          description: A new <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> representing the sum of the given values.
      overload: NodaTime.Instant.Add*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.Plus(NodaTime.Duration)
      commentId: M:NodaTime.Instant.Plus(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Plus(Duration)
        VB: Plus(Duration)
      nameWithType:
        CSharp: Instant.Plus(Duration)
        VB: Instant.Plus(Duration)
      qualifiedName:
        CSharp: NodaTime.Instant.Plus(NodaTime.Duration)
        VB: NodaTime.Instant.Plus(NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Plus
        path: src/NodaTime/Instant.cs
        startLine: 216
      summary: "\nReturns the result of adding a duration to this instant, for a fluent alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant Plus(Duration duration)
          VB: Public Function Plus(duration As Duration) As Instant
        parameters:
        - id: duration
          type: NodaTime.Duration
          description: The duration to add
        return:
          type: NodaTime.Instant
          description: A new <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> representing the result of the addition.
      overload: NodaTime.Instant.Plus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Subtraction(Instant, Instant)
        VB: Subtraction(Instant, Instant)
      nameWithType:
        CSharp: Instant.Subtraction(Instant, Instant)
        VB: Instant.Subtraction(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.Subtraction(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Instant.Subtraction(NodaTime.Instant, NodaTime.Instant)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Subtraction
        path: src/NodaTime/Instant.cs
        startLine: 227
      summary: "\nImplements the operator - (subtraction) for <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> - <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration operator -(Instant left, Instant right)
          VB: Public Shared Operator -(left As Instant, right As Instant) As Duration
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Instant
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> representing the difference of the given values.
      overload: NodaTime.Instant.op_Subtraction*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Duration)
      commentId: M:NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Subtraction(Instant, Duration)
        VB: Subtraction(Instant, Duration)
      nameWithType:
        CSharp: Instant.Subtraction(Instant, Duration)
        VB: Instant.Subtraction(Instant, Duration)
      qualifiedName:
        CSharp: NodaTime.Instant.Subtraction(NodaTime.Instant, NodaTime.Duration)
        VB: NodaTime.Instant.Subtraction(NodaTime.Instant, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Subtraction
        path: src/NodaTime/Instant.cs
        startLine: 238
      summary: "\nImplements the operator - (subtraction) for <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> - <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant operator -(Instant left, Duration right)
          VB: Public Shared Operator -(left As Instant, right As Duration) As Instant
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: NodaTime.Instant
          description: A new <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> representing the difference of the given values.
      overload: NodaTime.Instant.op_Subtraction*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Instant: 
        NodaTime.Duration: 
    - id: NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Subtract(Instant, Instant)
        VB: Subtract(Instant, Instant)
      nameWithType:
        CSharp: Instant.Subtract(Instant, Instant)
        VB: Instant.Subtract(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.Subtract(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Instant.Subtract(NodaTime.Instant, NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Subtract
        path: src/NodaTime/Instant.cs
        startLine: 249
      summary: "\nSubtracts one instant from another. Friendly alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Duration Subtract(Instant left, Instant right)
          VB: Public Shared Function Subtract(left As Instant, right As Instant) As Duration
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Instant
          description: The right hand side of the operator.
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Duration" data-throw-if-not-resolved="false"></xref> representing the difference of the given values.
      overload: NodaTime.Instant.Subtract*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Duration: 
    - id: NodaTime.Instant.Minus(NodaTime.Instant)
      commentId: M:NodaTime.Instant.Minus(NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Minus(Instant)
        VB: Minus(Instant)
      nameWithType:
        CSharp: Instant.Minus(Instant)
        VB: Instant.Minus(Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.Minus(NodaTime.Instant)
        VB: NodaTime.Instant.Minus(NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minus
        path: src/NodaTime/Instant.cs
        startLine: 259
      summary: "\nReturns the result of subtracting another instant from this one, for a fluent alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public Duration Minus(Instant other)
          VB: Public Function Minus(other As Instant) As Duration
        parameters:
        - id: other
          type: NodaTime.Instant
          description: The other instant to subtract
        return:
          type: NodaTime.Duration
          description: A new <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> representing the result of the subtraction.
      overload: NodaTime.Instant.Minus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Duration)
      commentId: M:NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Subtract(Instant, Duration)
        VB: Subtract(Instant, Duration)
      nameWithType:
        CSharp: Instant.Subtract(Instant, Duration)
        VB: Instant.Subtract(Instant, Duration)
      qualifiedName:
        CSharp: NodaTime.Instant.Subtract(NodaTime.Instant, NodaTime.Duration)
        VB: NodaTime.Instant.Subtract(NodaTime.Instant, NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Subtract
        path: src/NodaTime/Instant.cs
        startLine: 270
      summary: "\nSubtracts a duration from an instant. Friendly alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant Subtract(Instant left, Duration right)
          VB: Public Shared Function Subtract(left As Instant, right As Duration) As Instant
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Duration
          description: The right hand side of the operator.
        return:
          type: NodaTime.Instant
          description: A new <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> representing the difference of the given values.
      overload: NodaTime.Instant.Subtract*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.Minus(NodaTime.Duration)
      commentId: M:NodaTime.Instant.Minus(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Minus(Duration)
        VB: Minus(Duration)
      nameWithType:
        CSharp: Instant.Minus(Duration)
        VB: Instant.Minus(Duration)
      qualifiedName:
        CSharp: NodaTime.Instant.Minus(NodaTime.Duration)
        VB: NodaTime.Instant.Minus(NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minus
        path: src/NodaTime/Instant.cs
        startLine: 280
      summary: "\nReturns the result of subtracting a duration from this instant, for a fluent alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant Minus(Duration duration)
          VB: Public Function Minus(duration As Duration) As Instant
        parameters:
        - id: duration
          type: NodaTime.Duration
          description: The duration to subtract
        return:
          type: NodaTime.Instant
          description: A new <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> representing the result of the subtraction.
      overload: NodaTime.Instant.Minus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.op_Equality(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Instant.op_Equality(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Equality(Instant, Instant)
        VB: Equality(Instant, Instant)
      nameWithType:
        CSharp: Instant.Equality(Instant, Instant)
        VB: Instant.Equality(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.Equality(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Instant.Equality(NodaTime.Instant, NodaTime.Instant)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Equality
        path: src/NodaTime/Instant.cs
        startLine: 291
      summary: "\nImplements the operator == (equality).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator ==(Instant left, Instant right)
          VB: Public Shared Operator =(left As Instant, right As Instant) As Boolean
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Instant
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if values are equal to each other, otherwise <code>false</code>.
      overload: NodaTime.Instant.op_Equality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Instant.op_Inequality(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Instant.op_Inequality(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Inequality(Instant, Instant)
        VB: Inequality(Instant, Instant)
      nameWithType:
        CSharp: Instant.Inequality(Instant, Instant)
        VB: Instant.Inequality(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.Inequality(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Instant.Inequality(NodaTime.Instant, NodaTime.Instant)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Inequality
        path: src/NodaTime/Instant.cs
        startLine: 302
      summary: "\nImplements the operator != (inequality).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator !=(Instant left, Instant right)
          VB: Public Shared Operator <>(left As Instant, right As Instant) As Boolean
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Instant
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if values are not equal to each other, otherwise <code>false</code>.
      overload: NodaTime.Instant.op_Inequality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Instant.op_LessThan(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Instant.op_LessThan(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: LessThan(Instant, Instant)
        VB: LessThan(Instant, Instant)
      nameWithType:
        CSharp: Instant.LessThan(Instant, Instant)
        VB: Instant.LessThan(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.LessThan(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Instant.LessThan(NodaTime.Instant, NodaTime.Instant)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThan
        path: src/NodaTime/Instant.cs
        startLine: 313
      summary: "\nImplements the operator &lt; (less than).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <(Instant left, Instant right)
          VB: Public Shared Operator <(left As Instant, right As Instant) As Boolean
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Instant
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is less than the right value, otherwise <code>false</code>.
      overload: NodaTime.Instant.op_LessThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Instant.op_LessThanOrEqual(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Instant.op_LessThanOrEqual(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: LessThanOrEqual(Instant, Instant)
        VB: LessThanOrEqual(Instant, Instant)
      nameWithType:
        CSharp: Instant.LessThanOrEqual(Instant, Instant)
        VB: Instant.LessThanOrEqual(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.LessThanOrEqual(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Instant.LessThanOrEqual(NodaTime.Instant, NodaTime.Instant)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThanOrEqual
        path: src/NodaTime/Instant.cs
        startLine: 324
      summary: "\nImplements the operator &lt;= (less than or equal).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <=(Instant left, Instant right)
          VB: Public Shared Operator <=(left As Instant, right As Instant) As Boolean
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Instant
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is less than or equal to the right value, otherwise <code>false</code>.
      overload: NodaTime.Instant.op_LessThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Instant.op_GreaterThan(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Instant.op_GreaterThan(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: GreaterThan(Instant, Instant)
        VB: GreaterThan(Instant, Instant)
      nameWithType:
        CSharp: Instant.GreaterThan(Instant, Instant)
        VB: Instant.GreaterThan(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.GreaterThan(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Instant.GreaterThan(NodaTime.Instant, NodaTime.Instant)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThan
        path: src/NodaTime/Instant.cs
        startLine: 335
      summary: "\nImplements the operator &gt; (greater than).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator>(Instant left, Instant right)
          VB: Public Shared Operator>(left As Instant, right As Instant) As Boolean
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Instant
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is greater than the right value, otherwise <code>false</code>.
      overload: NodaTime.Instant.op_GreaterThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Instant.op_GreaterThanOrEqual(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Instant.op_GreaterThanOrEqual(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: GreaterThanOrEqual(Instant, Instant)
        VB: GreaterThanOrEqual(Instant, Instant)
      nameWithType:
        CSharp: Instant.GreaterThanOrEqual(Instant, Instant)
        VB: Instant.GreaterThanOrEqual(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.GreaterThanOrEqual(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Instant.GreaterThanOrEqual(NodaTime.Instant, NodaTime.Instant)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThanOrEqual
        path: src/NodaTime/Instant.cs
        startLine: 346
      summary: "\nImplements the operator &gt;= (greater than or equal).\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator >=(Instant left, Instant right)
          VB: Public Shared Operator >=(left As Instant, right As Instant) As Boolean
        parameters:
        - id: left
          type: NodaTime.Instant
          description: The left hand side of the operator.
        - id: right
          type: NodaTime.Instant
          description: The right hand side of the operator.
        return:
          type: System.Boolean
          description: <code>true</code> if the left value is greater than or equal to the right value, otherwise <code>false</code>.
      overload: NodaTime.Instant.op_GreaterThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: FromUtc(Int32, Int32, Int32, Int32, Int32)
        VB: FromUtc(Int32, Int32, Int32, Int32, Int32)
      nameWithType:
        CSharp: Instant.FromUtc(Int32, Int32, Int32, Int32, Int32)
        VB: Instant.FromUtc(Int32, Int32, Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.Instant.FromUtc(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
        VB: NodaTime.Instant.FromUtc(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromUtc
        path: src/NodaTime/Instant.cs
        startLine: 366
      summary: "\nReturns a new instant corresponding to the given UTC date and time in the ISO calendar.\nIn most cases applications should use <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> to represent a date\nand time, but this method is useful in some situations where an <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> is\nrequired, such as time zone testing.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant FromUtc(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour)
          VB: Public Shared Function FromUtc(year As Integer, monthOfYear As Integer, dayOfMonth As Integer, hourOfDay As Integer, minuteOfHour As Integer) As Instant
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year",

            so a value of 0 means 1 BC, for example.
        - id: monthOfYear
          type: System.Int32
          description: The month of year.
        - id: dayOfMonth
          type: System.Int32
          description: The day of month.
        - id: hourOfDay
          type: System.Int32
          description: The hour.
        - id: minuteOfHour
          type: System.Int32
          description: The minute.
        return:
          type: NodaTime.Instant
          description: An <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> value representing the given date and time in UTC and the ISO calendar.
      overload: NodaTime.Instant.FromUtc*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime: 
        NodaTime.Instant: 
    - id: NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      commentId: M:NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: FromUtc(Int32, Int32, Int32, Int32, Int32, Int32)
        VB: FromUtc(Int32, Int32, Int32, Int32, Int32, Int32)
      nameWithType:
        CSharp: Instant.FromUtc(Int32, Int32, Int32, Int32, Int32, Int32)
        VB: Instant.FromUtc(Int32, Int32, Int32, Int32, Int32, Int32)
      qualifiedName:
        CSharp: NodaTime.Instant.FromUtc(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
        VB: NodaTime.Instant.FromUtc(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromUtc
        path: src/NodaTime/Instant.cs
        startLine: 387
      summary: "\nReturns a new instant corresponding to the given UTC date and\ntime in the ISO calendar. In most cases applications should \nuse <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>\nto represent a date and time, but this method is useful in some \nsituations where an Instant is required, such as time zone testing.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant FromUtc(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute)
          VB: Public Shared Function FromUtc(year As Integer, monthOfYear As Integer, dayOfMonth As Integer, hourOfDay As Integer, minuteOfHour As Integer, secondOfMinute As Integer) As Instant
        parameters:
        - id: year
          type: System.Int32
          description: >-
            The year. This is the "absolute year",

            so a value of 0 means 1 BC, for example.
        - id: monthOfYear
          type: System.Int32
          description: The month of year.
        - id: dayOfMonth
          type: System.Int32
          description: The day of month.
        - id: hourOfDay
          type: System.Int32
          description: The hour.
        - id: minuteOfHour
          type: System.Int32
          description: The minute.
        - id: secondOfMinute
          type: System.Int32
          description: The second.
        return:
          type: NodaTime.Instant
          description: An <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> value representing the given date and time in UTC and the ISO calendar.
      overload: NodaTime.Instant.FromUtc*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime: 
        NodaTime.Instant: 
    - id: NodaTime.Instant.Max(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Instant.Max(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Max(Instant, Instant)
        VB: Max(Instant, Instant)
      nameWithType:
        CSharp: Instant.Max(Instant, Instant)
        VB: Instant.Max(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.Max(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Instant.Max(NodaTime.Instant, NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Max
        path: src/NodaTime/Instant.cs
        startLine: 399
      summary: "\nReturns the later instant of the given two.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant Max(Instant x, Instant y)
          VB: Public Shared Function Max(x As Instant, y As Instant) As Instant
        parameters:
        - id: x
          type: NodaTime.Instant
          description: The first instant to compare.
        - id: y
          type: NodaTime.Instant
          description: The second instant to compare.
        return:
          type: NodaTime.Instant
          description: The later instant of <span class="paramref">x</span> or <span class="paramref">y</span>.
      overload: NodaTime.Instant.Max*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Instant.Min(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Instant.Min(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Min(Instant, Instant)
        VB: Min(Instant, Instant)
      nameWithType:
        CSharp: Instant.Min(Instant, Instant)
        VB: Instant.Min(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.Min(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Instant.Min(NodaTime.Instant, NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Min
        path: src/NodaTime/Instant.cs
        startLine: 410
      summary: "\nReturns the earlier instant of the given two.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant Min(Instant x, Instant y)
          VB: Public Shared Function Min(x As Instant, y As Instant) As Instant
        parameters:
        - id: x
          type: NodaTime.Instant
          description: The first instant to compare.
        - id: y
          type: NodaTime.Instant
          description: The second instant to compare.
        return:
          type: NodaTime.Instant
          description: The earlier instant of <span class="paramref">x</span> or <span class="paramref">y</span>.
      overload: NodaTime.Instant.Min*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Instant.ToString
      commentId: M:NodaTime.Instant.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: Instant.ToString()
        VB: Instant.ToString()
      qualifiedName:
        CSharp: NodaTime.Instant.ToString()
        VB: NodaTime.Instant.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/Instant.cs
        startLine: 424
      summary: "\nReturns a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nThe value of the current instance in the standard format pattern, using the current thread's\nculture to obtain a format provider.\n"
      overload: NodaTime.Instant.ToString*
      overridden: System.ValueType.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.String: 
    - id: NodaTime.Instant.ToString(System.String,System.IFormatProvider)
      commentId: M:NodaTime.Instant.ToString(System.String,System.IFormatProvider)
      language: CSharp
      name:
        CSharp: ToString(String, IFormatProvider)
        VB: ToString(String, IFormatProvider)
      nameWithType:
        CSharp: Instant.ToString(String, IFormatProvider)
        VB: Instant.ToString(String, IFormatProvider)
      qualifiedName:
        CSharp: NodaTime.Instant.ToString(System.String, System.IFormatProvider)
        VB: NodaTime.Instant.ToString(System.String, System.IFormatProvider)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/Instant.cs
        startLine: 442
      summary: "\nFormats the value of the current instance using the specified pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string ToString(string patternText, IFormatProvider formatProvider)
          VB: Public Function ToString(patternText As String, formatProvider As IFormatProvider) As String
        parameters:
        - id: patternText
          type: System.String
          description: >
            The <xref href="System.String" data-throw-if-not-resolved="false"></xref> specifying the pattern to use,

            or null to use the default format pattern.
        - id: formatProvider
          type: System.IFormatProvider
          description: >
            The <xref href="System.IFormatProvider" data-throw-if-not-resolved="false"></xref> to use when formatting the value,

            or null to use the current thread's culture to obtain a format provider.
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> containing the value of the current instance in the specified format.\n"
      overload: NodaTime.Instant.ToString*
      implements:
      - System.IFormattable.ToString(System.String,System.IFormatProvider)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.String: 
        System.IFormatProvider: 
    - id: NodaTime.Instant.Equals(NodaTime.Instant)
      commentId: M:NodaTime.Instant.Equals(NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Equals(Instant)
        VB: Equals(Instant)
      nameWithType:
        CSharp: Instant.Equals(Instant)
        VB: Instant.Equals(Instant)
      qualifiedName:
        CSharp: NodaTime.Instant.Equals(NodaTime.Instant)
        VB: NodaTime.Instant.Equals(NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/Instant.cs
        startLine: 457
      summary: "\nIndicates whether the value of this instant is equal to the value of the specified instant.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(Instant other)
          VB: Public Function Equals(other As Instant) As Boolean
        parameters:
        - id: other
          type: NodaTime.Instant
          description: The value to compare with this instance.
        return:
          type: System.Boolean
          description: "\ntrue if the value of this instant is equal to the value of the <span class=\"paramref\">other</span> parameter;\notherwise, false.\n"
      overload: NodaTime.Instant.Equals*
      implements:
      - System.IEquatable{NodaTime.Instant}.Equals(NodaTime.Instant)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Instant.ToDateTimeUtc
      commentId: M:NodaTime.Instant.ToDateTimeUtc
      language: CSharp
      name:
        CSharp: ToDateTimeUtc()
        VB: ToDateTimeUtc()
      nameWithType:
        CSharp: Instant.ToDateTimeUtc()
        VB: Instant.ToDateTimeUtc()
      qualifiedName:
        CSharp: NodaTime.Instant.ToDateTimeUtc()
        VB: NodaTime.Instant.ToDateTimeUtc()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToDateTimeUtc
        path: src/NodaTime/Instant.cs
        startLine: 468
      summary: "\nConstructs a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> from this Instant which has a <xref href=\"System.DateTime.Kind\" data-throw-if-not-resolved=\"false\"></xref>\nof <xref href=\"System.DateTimeKind.Utc\" data-throw-if-not-resolved=\"false\"></xref> and represents the same instant of time as this value.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTime ToDateTimeUtc()
          VB: Public Function ToDateTimeUtc As Date
        return:
          type: System.DateTime
          description: A <xref href="System.DateTime" data-throw-if-not-resolved="false"></xref> representing the same instant in time as this value, with a kind of "universal".
      overload: NodaTime.Instant.ToDateTimeUtc*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.DateTime: 
        System.DateTime.Kind: 
        System.DateTimeKind.Utc: 
    - id: NodaTime.Instant.ToDateTimeOffset
      commentId: M:NodaTime.Instant.ToDateTimeOffset
      language: CSharp
      name:
        CSharp: ToDateTimeOffset()
        VB: ToDateTimeOffset()
      nameWithType:
        CSharp: Instant.ToDateTimeOffset()
        VB: Instant.ToDateTimeOffset()
      qualifiedName:
        CSharp: NodaTime.Instant.ToDateTimeOffset()
        VB: NodaTime.Instant.ToDateTimeOffset()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToDateTimeOffset
        path: src/NodaTime/Instant.cs
        startLine: 477
      summary: "\nConstructs a <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> from this Instant which has an offset of zero.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTimeOffset ToDateTimeOffset()
          VB: Public Function ToDateTimeOffset As DateTimeOffset
        return:
          type: System.DateTimeOffset
          description: A <xref href="System.DateTimeOffset" data-throw-if-not-resolved="false"></xref> representing the same instant in time as this value.
      overload: NodaTime.Instant.ToDateTimeOffset*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.DateTimeOffset: 
    - id: NodaTime.Instant.FromDateTimeOffset(System.DateTimeOffset)
      commentId: M:NodaTime.Instant.FromDateTimeOffset(System.DateTimeOffset)
      language: CSharp
      name:
        CSharp: FromDateTimeOffset(DateTimeOffset)
        VB: FromDateTimeOffset(DateTimeOffset)
      nameWithType:
        CSharp: Instant.FromDateTimeOffset(DateTimeOffset)
        VB: Instant.FromDateTimeOffset(DateTimeOffset)
      qualifiedName:
        CSharp: NodaTime.Instant.FromDateTimeOffset(System.DateTimeOffset)
        VB: NodaTime.Instant.FromDateTimeOffset(System.DateTimeOffset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromDateTimeOffset
        path: src/NodaTime/Instant.cs
        startLine: 488
      summary: "\nConverts a <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> into a new Instant representing the same instant in time. Note that\nthe offset information is not preserved in the returned Instant.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant FromDateTimeOffset(DateTimeOffset dateTimeOffset)
          VB: Public Shared Function FromDateTimeOffset(dateTimeOffset As DateTimeOffset) As Instant
        parameters:
        - id: dateTimeOffset
          type: System.DateTimeOffset
          description: Date and time value with an offset.
        return:
          type: NodaTime.Instant
          description: An <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> value representing the same instant in time as the given <xref href="System.DateTimeOffset" data-throw-if-not-resolved="false"></xref>.
      overload: NodaTime.Instant.FromDateTimeOffset*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.DateTimeOffset: 
        NodaTime.Instant: 
    - id: NodaTime.Instant.FromDateTimeUtc(System.DateTime)
      commentId: M:NodaTime.Instant.FromDateTimeUtc(System.DateTime)
      language: CSharp
      name:
        CSharp: FromDateTimeUtc(DateTime)
        VB: FromDateTimeUtc(DateTime)
      nameWithType:
        CSharp: Instant.FromDateTimeUtc(DateTime)
        VB: Instant.FromDateTimeUtc(DateTime)
      qualifiedName:
        CSharp: NodaTime.Instant.FromDateTimeUtc(System.DateTime)
        VB: NodaTime.Instant.FromDateTimeUtc(System.DateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromDateTimeUtc
        path: src/NodaTime/Instant.cs
        startLine: 500
      summary: "\nConverts a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> into a new Instant representing the same instant in time.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant FromDateTimeUtc(DateTime dateTime)
          VB: Public Shared Function FromDateTimeUtc(dateTime As Date) As Instant
        parameters:
        - id: dateTime
          type: System.DateTime
          description: Date and time value which must have a <xref href="System.DateTime.Kind" data-throw-if-not-resolved="false"></xref> of <xref href="System.DateTimeKind.Utc" data-throw-if-not-resolved="false"></xref>
        return:
          type: NodaTime.Instant
          description: An <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> value representing the same instant in time as the given universal <xref href="System.DateTime" data-throw-if-not-resolved="false"></xref>.
      overload: NodaTime.Instant.FromDateTimeUtc*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: >-
          <span class="paramref">dateTime</span> is not of <xref href="System.DateTime.Kind" data-throw-if-not-resolved="false"></xref>

          <xref href="System.DateTimeKind.Utc" data-throw-if-not-resolved="false"></xref>.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.DateTime: 
        NodaTime.Instant: 
        System.DateTime.Kind: 
        System.DateTimeKind.Utc: 
    - id: NodaTime.Instant.FromSecondsSinceUnixEpoch(System.Int64)
      commentId: M:NodaTime.Instant.FromSecondsSinceUnixEpoch(System.Int64)
      language: CSharp
      name:
        CSharp: FromSecondsSinceUnixEpoch(Int64)
        VB: FromSecondsSinceUnixEpoch(Int64)
      nameWithType:
        CSharp: Instant.FromSecondsSinceUnixEpoch(Int64)
        VB: Instant.FromSecondsSinceUnixEpoch(Int64)
      qualifiedName:
        CSharp: NodaTime.Instant.FromSecondsSinceUnixEpoch(System.Int64)
        VB: NodaTime.Instant.FromSecondsSinceUnixEpoch(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromSecondsSinceUnixEpoch
        path: src/NodaTime/Instant.cs
        startLine: 513
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> struct based\non a number of seconds since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant FromSecondsSinceUnixEpoch(long seconds)
          VB: Public Shared Function FromSecondsSinceUnixEpoch(seconds As Long) As Instant
        parameters:
        - id: seconds
          type: System.Int64
          description: Number of seconds since the Unix epoch. May be negative (for instants before the epoch).
        return:
          type: NodaTime.Instant
          description: An <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> at exactly the given number of seconds since the Unix epoch.
      overload: NodaTime.Instant.FromSecondsSinceUnixEpoch*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The constructed instant would be out of the range representable in Noda Time.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.FromMillisecondsSinceUnixEpoch(System.Int64)
      commentId: M:NodaTime.Instant.FromMillisecondsSinceUnixEpoch(System.Int64)
      language: CSharp
      name:
        CSharp: FromMillisecondsSinceUnixEpoch(Int64)
        VB: FromMillisecondsSinceUnixEpoch(Int64)
      nameWithType:
        CSharp: Instant.FromMillisecondsSinceUnixEpoch(Int64)
        VB: Instant.FromMillisecondsSinceUnixEpoch(Int64)
      qualifiedName:
        CSharp: NodaTime.Instant.FromMillisecondsSinceUnixEpoch(System.Int64)
        VB: NodaTime.Instant.FromMillisecondsSinceUnixEpoch(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromMillisecondsSinceUnixEpoch
        path: src/NodaTime/Instant.cs
        startLine: 527
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> struct based\non a number of milliseconds since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.\n"
      example: []
      syntax:
        content:
          CSharp: public static Instant FromMillisecondsSinceUnixEpoch(long milliseconds)
          VB: Public Shared Function FromMillisecondsSinceUnixEpoch(milliseconds As Long) As Instant
        parameters:
        - id: milliseconds
          type: System.Int64
          description: Number of milliseconds since the Unix epoch. May be negative (for instants before the epoch).
        return:
          type: NodaTime.Instant
          description: An <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> at exactly the given number of milliseconds since the Unix epoch.
      overload: NodaTime.Instant.FromMillisecondsSinceUnixEpoch*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The constructed instant would be out of the range representable in Noda Time.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.FromTicksSinceUnixEpoch(System.Int64)
      commentId: M:NodaTime.Instant.FromTicksSinceUnixEpoch(System.Int64)
      language: CSharp
      name:
        CSharp: FromTicksSinceUnixEpoch(Int64)
        VB: FromTicksSinceUnixEpoch(Int64)
      nameWithType:
        CSharp: Instant.FromTicksSinceUnixEpoch(Int64)
        VB: Instant.FromTicksSinceUnixEpoch(Int64)
      qualifiedName:
        CSharp: NodaTime.Instant.FromTicksSinceUnixEpoch(System.Int64)
        VB: NodaTime.Instant.FromTicksSinceUnixEpoch(System.Int64)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromTicksSinceUnixEpoch
        path: src/NodaTime/Instant.cs
        startLine: 542
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> struct based\non a number of ticks since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.\n"
      remarks: >-
        This is equivalent to calling the constructor directly, but indicates

        intent more explicitly.
      example: []
      syntax:
        content:
          CSharp: public static Instant FromTicksSinceUnixEpoch(long ticks)
          VB: Public Shared Function FromTicksSinceUnixEpoch(ticks As Long) As Instant
        parameters:
        - id: ticks
          type: System.Int64
          description: Number of ticks since the Unix epoch. May be negative (for instants before the epoch).
        return:
          type: NodaTime.Instant
          description: An <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> at exactly the given number of ticks since the Unix epoch.
      overload: NodaTime.Instant.FromTicksSinceUnixEpoch*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.Instant: 
    - id: NodaTime.Instant.InUtc
      commentId: M:NodaTime.Instant.InUtc
      language: CSharp
      name:
        CSharp: InUtc()
        VB: InUtc()
      nameWithType:
        CSharp: Instant.InUtc()
        VB: Instant.InUtc()
      qualifiedName:
        CSharp: NodaTime.Instant.InUtc()
        VB: NodaTime.Instant.InUtc()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: InUtc
        path: src/NodaTime/Instant.cs
        startLine: 554
      summary: "\nReturns the <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> representing the same point in time as this instant, in the UTC time\nzone and ISO-8601 calendar. This is a shortcut for calling <xref href=\"NodaTime.Instant.InZone(NodaTime.DateTimeZone)\" data-throw-if-not-resolved=\"false\"></xref> with an\nargument of <xref href=\"NodaTime.DateTimeZone.Utc\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime InUtc()
          VB: Public Function InUtc As ZonedDateTime
        return:
          type: NodaTime.ZonedDateTime
          description: >-
            A <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> for the same instant, in the UTC time zone

            and the ISO-8601 calendar
      overload: NodaTime.Instant.InUtc*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
        NodaTime.Instant.InZone(NodaTime.DateTimeZone): 
        NodaTime.DateTimeZone.Utc: 
    - id: NodaTime.Instant.InZone(NodaTime.DateTimeZone)
      commentId: M:NodaTime.Instant.InZone(NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: InZone(DateTimeZone)
        VB: InZone(DateTimeZone)
      nameWithType:
        CSharp: Instant.InZone(DateTimeZone)
        VB: Instant.InZone(DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.Instant.InZone(NodaTime.DateTimeZone)
        VB: NodaTime.Instant.InZone(NodaTime.DateTimeZone)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: InZone
        path: src/NodaTime/Instant.cs
        startLine: 567
      summary: "\nReturns the <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> representing the same point in time as this instant, in the\nspecified time zone and ISO-8601 calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime InZone(DateTimeZone zone)
          VB: Public Function InZone(zone As DateTimeZone) As ZonedDateTime
        parameters:
        - id: zone
          type: NodaTime.DateTimeZone
          description: The time zone in which to represent this instant.
        return:
          type: NodaTime.ZonedDateTime
          description: >-
            A <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> for the same instant, in the given time zone

            and the ISO-8601 calendar
      overload: NodaTime.Instant.InZone*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">zone</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.Instant.InZone(NodaTime.DateTimeZone,NodaTime.CalendarSystem)
      commentId: M:NodaTime.Instant.InZone(NodaTime.DateTimeZone,NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: InZone(DateTimeZone, CalendarSystem)
        VB: InZone(DateTimeZone, CalendarSystem)
      nameWithType:
        CSharp: Instant.InZone(DateTimeZone, CalendarSystem)
        VB: Instant.InZone(DateTimeZone, CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.Instant.InZone(NodaTime.DateTimeZone, NodaTime.CalendarSystem)
        VB: NodaTime.Instant.InZone(NodaTime.DateTimeZone, NodaTime.CalendarSystem)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: InZone
        path: src/NodaTime/Instant.cs
        startLine: 582
      summary: "\nReturns the <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> representing the same point in time as this instant, in the\nspecified time zone and calendar system.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime InZone(DateTimeZone zone, CalendarSystem calendar)
          VB: Public Function InZone(zone As DateTimeZone, calendar As CalendarSystem) As ZonedDateTime
        parameters:
        - id: zone
          type: NodaTime.DateTimeZone
          description: The time zone in which to represent this instant.
        - id: calendar
          type: NodaTime.CalendarSystem
          description: The calendar system in which to represent this instant.
        return:
          type: NodaTime.ZonedDateTime
          description: >-
            A <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> for the same instant, in the given time zone

            and calendar
      overload: NodaTime.Instant.InZone*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">zone</span> or <span class="paramref">calendar</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.Instant.WithOffset(NodaTime.Offset)
      commentId: M:NodaTime.Instant.WithOffset(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: WithOffset(Offset)
        VB: WithOffset(Offset)
      nameWithType:
        CSharp: Instant.WithOffset(Offset)
        VB: Instant.WithOffset(Offset)
      qualifiedName:
        CSharp: NodaTime.Instant.WithOffset(NodaTime.Offset)
        VB: NodaTime.Instant.WithOffset(NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithOffset
        path: src/NodaTime/Instant.cs
        startLine: 596
      summary: "\nReturns the <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> representing the same point in time as this instant, with\nthe specified UTC offset in the ISO calendar system.\n"
      example: []
      syntax:
        content:
          CSharp: public OffsetDateTime WithOffset(Offset offset)
          VB: Public Function WithOffset(offset As Offset) As OffsetDateTime
        parameters:
        - id: offset
          type: NodaTime.Offset
          description: The offset from UTC with which to represent this instant.
        return:
          type: NodaTime.OffsetDateTime
          description: >-
            An <xref href="NodaTime.OffsetDateTime" data-throw-if-not-resolved="false"></xref> for the same instant, with the given offset

            in the ISO calendar system
      overload: NodaTime.Instant.WithOffset*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.OffsetDateTime: 
    - id: NodaTime.Instant.WithOffset(NodaTime.Offset,NodaTime.CalendarSystem)
      commentId: M:NodaTime.Instant.WithOffset(NodaTime.Offset,NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: WithOffset(Offset, CalendarSystem)
        VB: WithOffset(Offset, CalendarSystem)
      nameWithType:
        CSharp: Instant.WithOffset(Offset, CalendarSystem)
        VB: Instant.WithOffset(Offset, CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.Instant.WithOffset(NodaTime.Offset, NodaTime.CalendarSystem)
        VB: NodaTime.Instant.WithOffset(NodaTime.Offset, NodaTime.CalendarSystem)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithOffset
        path: src/NodaTime/Instant.cs
        startLine: 610
      summary: "\nReturns the <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> representing the same point in time as this instant, with\nthe specified UTC offset and calendar system.\n"
      example: []
      syntax:
        content:
          CSharp: public OffsetDateTime WithOffset(Offset offset, CalendarSystem calendar)
          VB: Public Function WithOffset(offset As Offset, calendar As CalendarSystem) As OffsetDateTime
        parameters:
        - id: offset
          type: NodaTime.Offset
          description: The offset from UTC with which to represent this instant.
        - id: calendar
          type: NodaTime.CalendarSystem
          description: The calendar system in which to represent this instant.
        return:
          type: NodaTime.OffsetDateTime
          description: >-
            An <xref href="NodaTime.OffsetDateTime" data-throw-if-not-resolved="false"></xref> for the same instant, with the given offset

            and calendar
      overload: NodaTime.Instant.WithOffset*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">calendar</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.OffsetDateTime: 
    - isEii: true
      id: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#GetSchema
      commentId: M:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#GetSchema
      language: CSharp
      name:
        CSharp: IXmlSerializable.GetSchema()
        VB: System.Xml.Serialization.IXmlSerializable.GetSchema()
      nameWithType:
        CSharp: Instant.IXmlSerializable.GetSchema()
        VB: Instant.System.Xml.Serialization.IXmlSerializable.GetSchema()
      qualifiedName:
        CSharp: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.GetSchema()
        VB: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.GetSchema()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.GetSchema
        path: src/NodaTime/Instant.cs
        startLine: 618
      example: []
      syntax:
        content:
          CSharp: XmlSchema IXmlSerializable.GetSchema()
          VB: Function System.Xml.Serialization.IXmlSerializable.GetSchema As XmlSchema Implements IXmlSerializable.GetSchema
        return:
          type: System.Xml.Schema.XmlSchema
      overload: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#GetSchema*
      implements:
      - System.Xml.Serialization.IXmlSerializable.GetSchema
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      commentId: M:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      language: CSharp
      name:
        CSharp: IXmlSerializable.ReadXml(XmlReader)
        VB: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      nameWithType:
        CSharp: Instant.IXmlSerializable.ReadXml(XmlReader)
        VB: Instant.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      qualifiedName:
        CSharp: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        VB: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.ReadXml
        path: src/NodaTime/Instant.cs
        startLine: 624
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.ReadXml(XmlReader reader)
          VB: Sub System.Xml.Serialization.IXmlSerializable.ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
        parameters:
        - id: reader
          type: System.Xml.XmlReader
      overload: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#ReadXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      commentId: M:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      language: CSharp
      name:
        CSharp: IXmlSerializable.WriteXml(XmlWriter)
        VB: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      nameWithType:
        CSharp: Instant.IXmlSerializable.WriteXml(XmlWriter)
        VB: Instant.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      qualifiedName:
        CSharp: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        VB: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.WriteXml
        path: src/NodaTime/Instant.cs
        startLine: 633
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.WriteXml(XmlWriter writer)
          VB: Sub System.Xml.Serialization.IXmlSerializable.WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
        parameters:
        - id: writer
          type: System.Xml.XmlWriter
      overload: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#WriteXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Instant.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:NodaTime.Instant.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: Instant.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: Instant.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: NodaTime.Instant.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: NodaTime.Instant.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Instant.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Runtime.Serialization.ISerializable.GetObjectData
        path: src/NodaTime/Instant.cs
        startLine: 659
      summary: "\nImplementation of <xref href=\"System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo%2cSystem.Runtime.Serialization.StreamingContext)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
          VB: Sub System.Runtime.Serialization.ISerializable.GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: The <xref href="System.Runtime.Serialization.SerializationInfo" data-throw-if-not-resolved="false"></xref> to populate with data.
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: The destination for this serialization.
      overload: NodaTime.Instant.System#Runtime#Serialization#ISerializable#GetObjectData*
      implements:
      - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      modifiers:
        CSharp: []
        VB: []
      references:
        ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        : 
        System.Runtime.Serialization.SerializationInfo: 
    references:
      NodaTime.Instant: 
  - id: NodaTime.Interval
    commentId: T:NodaTime.Interval
    language: CSharp
    name:
      CSharp: Interval
      VB: Interval
    nameWithType:
      CSharp: Interval
      VB: Interval
    qualifiedName:
      CSharp: NodaTime.Interval
      VB: NodaTime.Interval
    type: Struct
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/Interval.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: Interval
      path: src/NodaTime/Interval.cs
      startLine: 29
    summary: "\nAn interval between two instants in time (start and end).\n"
    remarks: "\n<p>\nThe interval includes the start instant and excludes the end instant, unless the end instant\nis <xref href=\"NodaTime.Instant.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> in which case it's deemed to be inclusive.\n(An interval stretching to infinity includes the end of time.)\n</p>\n<p>\nThe end may equal the start (resulting in an empty interval), but will not be before the start.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public struct Interval : IEquatable<Interval>, IXmlSerializable, ISerializable
        VB: >-
          <Serializable>

          Public Structure Interval

              Implements IEquatable(Of Interval), IXmlSerializable, ISerializable
    implements:
    - System.IEquatable{NodaTime.Interval}
    - System.Xml.Serialization.IXmlSerializable
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: NodaTime.Interval.#ctor(NodaTime.Instant,NodaTime.Instant)
      commentId: M:NodaTime.Interval.#ctor(NodaTime.Instant,NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Interval(Instant, Instant)
        VB: Interval(Instant, Instant)
      nameWithType:
        CSharp: Interval.Interval(Instant, Instant)
        VB: Interval.Interval(Instant, Instant)
      qualifiedName:
        CSharp: NodaTime.Interval.Interval(NodaTime.Instant, NodaTime.Instant)
        VB: NodaTime.Interval.Interval(NodaTime.Instant, NodaTime.Instant)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/Interval.cs
        startLine: 50
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.Interval\" data-throw-if-not-resolved=\"false\"></xref> struct.\nThe interval includes the <span class=\"paramref\">start</span> instant and excludes the\n<span class=\"paramref\">end</span> instant. The end may equal the start (resulting in an empty interval), but must not be before the start.\n"
      example: []
      syntax:
        content:
          CSharp: public Interval(Instant start, Instant end)
          VB: Public Sub New(start As Instant, end As Instant)
        parameters:
        - id: start
          type: NodaTime.Instant
          description: The start <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref>.
        - id: end
          type: NodaTime.Instant
          description: The end <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref>.
      overload: NodaTime.Interval.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: <span class="paramref">end</span> is earlier than <span class="paramref">start</span>.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Interval: 
        NodaTime.Instant: 
    - id: NodaTime.Interval.Start
      commentId: P:NodaTime.Interval.Start
      language: CSharp
      name:
        CSharp: Start
        VB: Start
      nameWithType:
        CSharp: Interval.Start
        VB: Interval.Start
      qualifiedName:
        CSharp: NodaTime.Interval.Start
        VB: NodaTime.Interval.Start
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Start
        path: src/NodaTime/Interval.cs
        startLine: 67
      summary: "\nGets the start instant - the inclusive lower bound of the interval.\n"
      remarks: "\nThis will never be later than <xref href=\"NodaTime.Interval.End\" data-throw-if-not-resolved=\"false\"></xref>, though it may be equal to it.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant Start { get; }
          VB: Public ReadOnly Property Start As Instant
        parameters: []
        return:
          type: NodaTime.Instant
          description: The start <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref>.
      overload: NodaTime.Interval.Start*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.Interval.End: 
        NodaTime.Instant: 
    - id: NodaTime.Interval.End
      commentId: P:NodaTime.Interval.End
      language: CSharp
      name:
        CSharp: End
        VB: End
      nameWithType:
        CSharp: Interval.End
        VB: Interval.End
      qualifiedName:
        CSharp: NodaTime.Interval.End
        VB: NodaTime.Interval.End
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: End
        path: src/NodaTime/Interval.cs
        startLine: 78
      summary: "\nGets the end instant - the exclusive upper bound of the interval.\n"
      remarks: "\nThis will never be earlier than <xref href=\"NodaTime.Interval.Start\" data-throw-if-not-resolved=\"false\"></xref>, though it may be equal to it.\nIf this value is <xref href=\"NodaTime.Instant.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>, it is treated as an inclusive\nupper bound: an interval stretching to infinity includes the end of time.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant End { get; }
          VB: Public ReadOnly Property End As Instant
        parameters: []
        return:
          type: NodaTime.Instant
          description: The end <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref>.
      overload: NodaTime.Interval.End*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.Interval.Start: 
        NodaTime.Instant.MaxValue: 
        NodaTime.Instant: 
    - id: NodaTime.Interval.Duration
      commentId: P:NodaTime.Interval.Duration
      language: CSharp
      name:
        CSharp: Duration
        VB: Duration
      nameWithType:
        CSharp: Interval.Duration
        VB: Interval.Duration
      qualifiedName:
        CSharp: NodaTime.Interval.Duration
        VB: NodaTime.Interval.Duration
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Duration
        path: src/NodaTime/Interval.cs
        startLine: 87
      summary: "\nReturns the duration of the interval.\n"
      remarks: "\nThis will always be a non-negative duration, though it may be zero.\n"
      example: []
      syntax:
        content:
          CSharp: public Duration Duration { get; }
          VB: Public ReadOnly Property Duration As Duration
        parameters: []
        return:
          type: NodaTime.Duration
          description: The duration of the interval.
      overload: NodaTime.Interval.Duration*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Interval.Contains(NodaTime.Instant)
      commentId: M:NodaTime.Interval.Contains(NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Contains(Instant)
        VB: Contains(Instant)
      nameWithType:
        CSharp: Interval.Contains(Instant)
        VB: Interval.Contains(Instant)
      qualifiedName:
        CSharp: NodaTime.Interval.Contains(NodaTime.Instant)
        VB: NodaTime.Interval.Contains(NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Contains
        path: src/NodaTime/Interval.cs
        startLine: 99
      summary: "\nReturns whether or not this interval contains the given instant.\n"
      remarks: "\nThe interval is considered to include the <xref href=\"NodaTime.Interval.Start\" data-throw-if-not-resolved=\"false\"></xref> instant but\nnot the <xref href=\"NodaTime.Interval.End\" data-throw-if-not-resolved=\"false\"></xref> instant - unless the end is <xref href=\"NodaTime.Instant.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>, in\nwhich case it's considered to be infinite from the start point onwards.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Contains(Instant instant)
          VB: Public Function Contains(instant As Instant) As Boolean
        parameters:
        - id: instant
          type: NodaTime.Instant
          description: Instant to test.
        return:
          type: System.Boolean
          description: True if this interval contains the given instant; false otherwise.
      overload: NodaTime.Interval.Contains*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Interval.Start: 
        NodaTime.Interval.End: 
        NodaTime.Instant.MaxValue: 
    - id: NodaTime.Interval.Equals(NodaTime.Interval)
      commentId: M:NodaTime.Interval.Equals(NodaTime.Interval)
      language: CSharp
      name:
        CSharp: Equals(Interval)
        VB: Equals(Interval)
      nameWithType:
        CSharp: Interval.Equals(Interval)
        VB: Interval.Equals(Interval)
      qualifiedName:
        CSharp: NodaTime.Interval.Equals(NodaTime.Interval)
        VB: NodaTime.Interval.Equals(NodaTime.Interval)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/Interval.cs
        startLine: 113
      summary: "\nIndicates whether the value of this interval is equal to the value of the specified interval.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(Interval other)
          VB: Public Function Equals(other As Interval) As Boolean
        parameters:
        - id: other
          type: NodaTime.Interval
          description: The value to compare with this instance.
        return:
          type: System.Boolean
          description: "\ntrue if the value of this instant is equal to the value of the <span class=\"paramref\">other</span> parameter;\notherwise, false.\n"
      overload: NodaTime.Interval.Equals*
      implements:
      - System.IEquatable{NodaTime.Interval}.Equals(NodaTime.Interval)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Interval.Equals(System.Object)
      commentId: M:NodaTime.Interval.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: Interval.Equals(Object)
        VB: Interval.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.Interval.Equals(System.Object)
        VB: NodaTime.Interval.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/Interval.cs
        startLine: 129
      summary: "\nDetermines whether the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: The <xref href="System.Object" data-throw-if-not-resolved="false"></xref> to compare with this instance.
        return:
          type: System.Boolean
          description: "\n<code>true</code> if the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to this instance;\notherwise, <code>false</code>.\n"
      overload: NodaTime.Interval.Equals*
      overridden: System.ValueType.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.Object: 
    - id: NodaTime.Interval.GetHashCode
      commentId: M:NodaTime.Interval.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: Interval.GetHashCode()
        VB: Interval.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.Interval.GetHashCode()
        VB: NodaTime.Interval.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/Interval.cs
        startLine: 145
      summary: "\nReturns the hash code for this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: "\nA 32-bit signed integer that is the hash code for this instance.\n"
      overload: NodaTime.Interval.GetHashCode*
      overridden: System.ValueType.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.Interval.ToString
      commentId: M:NodaTime.Interval.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: Interval.ToString()
        VB: Interval.ToString()
      qualifiedName:
        CSharp: NodaTime.Interval.ToString()
        VB: NodaTime.Interval.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/Interval.cs
        startLine: 158
      summary: "\nReturns a string representation of this interval. The format of this string is\nnot yet specified, and may change without notice. \n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: A string representation of this interval.
      overload: NodaTime.Interval.ToString*
      overridden: System.ValueType.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.Interval.op_Equality(NodaTime.Interval,NodaTime.Interval)
      commentId: M:NodaTime.Interval.op_Equality(NodaTime.Interval,NodaTime.Interval)
      language: CSharp
      name:
        CSharp: Equality(Interval, Interval)
        VB: Equality(Interval, Interval)
      nameWithType:
        CSharp: Interval.Equality(Interval, Interval)
        VB: Interval.Equality(Interval, Interval)
      qualifiedName:
        CSharp: NodaTime.Interval.Equality(NodaTime.Interval, NodaTime.Interval)
        VB: NodaTime.Interval.Equality(NodaTime.Interval, NodaTime.Interval)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Equality
        path: src/NodaTime/Interval.cs
        startLine: 171
      summary: "\nImplements the operator ==.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator ==(Interval left, Interval right)
          VB: Public Shared Operator =(left As Interval, right As Interval) As Boolean
        parameters:
        - id: left
          type: NodaTime.Interval
          description: The left.
        - id: right
          type: NodaTime.Interval
          description: The right.
        return:
          type: System.Boolean
          description: The result of the operator.
      overload: NodaTime.Interval.op_Equality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Interval.op_Inequality(NodaTime.Interval,NodaTime.Interval)
      commentId: M:NodaTime.Interval.op_Inequality(NodaTime.Interval,NodaTime.Interval)
      language: CSharp
      name:
        CSharp: Inequality(Interval, Interval)
        VB: Inequality(Interval, Interval)
      nameWithType:
        CSharp: Interval.Inequality(Interval, Interval)
        VB: Interval.Inequality(Interval, Interval)
      qualifiedName:
        CSharp: NodaTime.Interval.Inequality(NodaTime.Interval, NodaTime.Interval)
        VB: NodaTime.Interval.Inequality(NodaTime.Interval, NodaTime.Interval)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Inequality
        path: src/NodaTime/Interval.cs
        startLine: 182
      summary: "\nImplements the operator !=.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator !=(Interval left, Interval right)
          VB: Public Shared Operator <>(left As Interval, right As Interval) As Boolean
        parameters:
        - id: left
          type: NodaTime.Interval
          description: The left.
        - id: right
          type: NodaTime.Interval
          description: The right.
        return:
          type: System.Boolean
          description: The result of the operator.
      overload: NodaTime.Interval.op_Inequality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isEii: true
      id: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#GetSchema
      commentId: M:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#GetSchema
      language: CSharp
      name:
        CSharp: IXmlSerializable.GetSchema()
        VB: System.Xml.Serialization.IXmlSerializable.GetSchema()
      nameWithType:
        CSharp: Interval.IXmlSerializable.GetSchema()
        VB: Interval.System.Xml.Serialization.IXmlSerializable.GetSchema()
      qualifiedName:
        CSharp: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.GetSchema()
        VB: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.GetSchema()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.GetSchema
        path: src/NodaTime/Interval.cs
        startLine: 190
      example: []
      syntax:
        content:
          CSharp: XmlSchema IXmlSerializable.GetSchema()
          VB: Function System.Xml.Serialization.IXmlSerializable.GetSchema As XmlSchema Implements IXmlSerializable.GetSchema
        return:
          type: System.Xml.Schema.XmlSchema
      overload: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#GetSchema*
      implements:
      - System.Xml.Serialization.IXmlSerializable.GetSchema
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      commentId: M:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      language: CSharp
      name:
        CSharp: IXmlSerializable.ReadXml(XmlReader)
        VB: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      nameWithType:
        CSharp: Interval.IXmlSerializable.ReadXml(XmlReader)
        VB: Interval.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      qualifiedName:
        CSharp: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        VB: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.ReadXml
        path: src/NodaTime/Interval.cs
        startLine: 196
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.ReadXml(XmlReader reader)
          VB: Sub System.Xml.Serialization.IXmlSerializable.ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
        parameters:
        - id: reader
          type: System.Xml.XmlReader
      overload: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#ReadXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      commentId: M:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      language: CSharp
      name:
        CSharp: IXmlSerializable.WriteXml(XmlWriter)
        VB: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      nameWithType:
        CSharp: Interval.IXmlSerializable.WriteXml(XmlWriter)
        VB: Interval.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      qualifiedName:
        CSharp: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        VB: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.WriteXml
        path: src/NodaTime/Interval.cs
        startLine: 216
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.WriteXml(XmlWriter writer)
          VB: Sub System.Xml.Serialization.IXmlSerializable.WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
        parameters:
        - id: writer
          type: System.Xml.XmlWriter
      overload: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#WriteXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.Interval.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:NodaTime.Interval.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: Interval.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: Interval.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: NodaTime.Interval.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: NodaTime.Interval.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/Interval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Runtime.Serialization.ISerializable.GetObjectData
        path: src/NodaTime/Interval.cs
        startLine: 246
      summary: "\nImplementation of <xref href=\"System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo%2cSystem.Runtime.Serialization.StreamingContext)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
          VB: Sub System.Runtime.Serialization.ISerializable.GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: The <xref href="System.Runtime.Serialization.SerializationInfo" data-throw-if-not-resolved="false"></xref> to populate with data.
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: The destination for this serialization.
      overload: NodaTime.Interval.System#Runtime#Serialization#ISerializable#GetObjectData*
      implements:
      - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      modifiers:
        CSharp: []
        VB: []
      references:
        ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        : 
        System.Runtime.Serialization.SerializationInfo: 
    references:
      NodaTime.Instant.MaxValue: 
  - id: NodaTime.NodaConstants
    commentId: T:NodaTime.NodaConstants
    language: CSharp
    name:
      CSharp: NodaConstants
      VB: NodaConstants
    nameWithType:
      CSharp: NodaConstants
      VB: NodaConstants
    qualifiedName:
      CSharp: NodaTime.NodaConstants
      VB: NodaTime.NodaConstants
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/NodaConstants.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: NodaConstants
      path: src/NodaTime/NodaConstants.cs
      startLine: 11
    summary: "\nUseful constants, mostly along the lines of \"number of milliseconds in an hour\".\n"
    example: []
    syntax:
      content:
        CSharp: public static class NodaConstants
        VB: Public Module NodaConstants
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: NodaTime.NodaConstants.TicksPerMillisecond
      commentId: F:NodaTime.NodaConstants.TicksPerMillisecond
      language: CSharp
      name:
        CSharp: TicksPerMillisecond
        VB: TicksPerMillisecond
      nameWithType:
        CSharp: NodaConstants.TicksPerMillisecond
        VB: NodaConstants.TicksPerMillisecond
      qualifiedName:
        CSharp: NodaTime.NodaConstants.TicksPerMillisecond
        VB: NodaTime.NodaConstants.TicksPerMillisecond
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TicksPerMillisecond
        path: src/NodaTime/NodaConstants.cs
        startLine: 16
      summary: "\nA constant for the number of ticks in a millisecond. The value of this constant is 10,000.\n"
      example: []
      syntax:
        content:
          CSharp: public const long TicksPerMillisecond = 10000L
          VB: Public Const TicksPerMillisecond As Long = 10000L
        return:
          type: System.Int64
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.TicksPerSecond
      commentId: F:NodaTime.NodaConstants.TicksPerSecond
      language: CSharp
      name:
        CSharp: TicksPerSecond
        VB: TicksPerSecond
      nameWithType:
        CSharp: NodaConstants.TicksPerSecond
        VB: NodaConstants.TicksPerSecond
      qualifiedName:
        CSharp: NodaTime.NodaConstants.TicksPerSecond
        VB: NodaTime.NodaConstants.TicksPerSecond
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TicksPerSecond
        path: src/NodaTime/NodaConstants.cs
        startLine: 20
      summary: "\nA constant for the number of ticks in a second. The value of this constant is 10,000,000.\n"
      example: []
      syntax:
        content:
          CSharp: public const long TicksPerSecond = 10000000L
          VB: Public Const TicksPerSecond As Long = 10000000L
        return:
          type: System.Int64
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.TicksPerMinute
      commentId: F:NodaTime.NodaConstants.TicksPerMinute
      language: CSharp
      name:
        CSharp: TicksPerMinute
        VB: TicksPerMinute
      nameWithType:
        CSharp: NodaConstants.TicksPerMinute
        VB: NodaConstants.TicksPerMinute
      qualifiedName:
        CSharp: NodaTime.NodaConstants.TicksPerMinute
        VB: NodaTime.NodaConstants.TicksPerMinute
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TicksPerMinute
        path: src/NodaTime/NodaConstants.cs
        startLine: 24
      summary: "\nA constant for the number of ticks in a minute. The value of this constant is 600,000,000.\n"
      example: []
      syntax:
        content:
          CSharp: public const long TicksPerMinute = 600000000L
          VB: Public Const TicksPerMinute As Long = 600000000L
        return:
          type: System.Int64
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.TicksPerHour
      commentId: F:NodaTime.NodaConstants.TicksPerHour
      language: CSharp
      name:
        CSharp: TicksPerHour
        VB: TicksPerHour
      nameWithType:
        CSharp: NodaConstants.TicksPerHour
        VB: NodaConstants.TicksPerHour
      qualifiedName:
        CSharp: NodaTime.NodaConstants.TicksPerHour
        VB: NodaTime.NodaConstants.TicksPerHour
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TicksPerHour
        path: src/NodaTime/NodaConstants.cs
        startLine: 28
      summary: "\nA constant for the number of ticks in an hour. The value of this constant is 36,000,000,000.\n"
      example: []
      syntax:
        content:
          CSharp: public const long TicksPerHour = 36000000000L
          VB: Public Const TicksPerHour As Long = 36000000000L
        return:
          type: System.Int64
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.TicksPerStandardDay
      commentId: F:NodaTime.NodaConstants.TicksPerStandardDay
      language: CSharp
      name:
        CSharp: TicksPerStandardDay
        VB: TicksPerStandardDay
      nameWithType:
        CSharp: NodaConstants.TicksPerStandardDay
        VB: NodaConstants.TicksPerStandardDay
      qualifiedName:
        CSharp: NodaTime.NodaConstants.TicksPerStandardDay
        VB: NodaTime.NodaConstants.TicksPerStandardDay
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TicksPerStandardDay
        path: src/NodaTime/NodaConstants.cs
        startLine: 34
      summary: "\nA constant for the number of ticks in a standard 24-hour day.\nThe value of this constant is 864,000,000,000.\n"
      example: []
      syntax:
        content:
          CSharp: public const long TicksPerStandardDay = 864000000000L
          VB: Public Const TicksPerStandardDay As Long = 864000000000L
        return:
          type: System.Int64
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.TicksPerStandardWeek
      commentId: F:NodaTime.NodaConstants.TicksPerStandardWeek
      language: CSharp
      name:
        CSharp: TicksPerStandardWeek
        VB: TicksPerStandardWeek
      nameWithType:
        CSharp: NodaConstants.TicksPerStandardWeek
        VB: NodaConstants.TicksPerStandardWeek
      qualifiedName:
        CSharp: NodaTime.NodaConstants.TicksPerStandardWeek
        VB: NodaTime.NodaConstants.TicksPerStandardWeek
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TicksPerStandardWeek
        path: src/NodaTime/NodaConstants.cs
        startLine: 40
      summary: "\nA constant for the number of ticks in a standard week of seven 24-hour days.\nThe value of this constant is 6,048,000,000,000.\n"
      example: []
      syntax:
        content:
          CSharp: public const long TicksPerStandardWeek = 6048000000000L
          VB: Public Const TicksPerStandardWeek As Long = 6048000000000L
        return:
          type: System.Int64
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.MillisecondsPerSecond
      commentId: F:NodaTime.NodaConstants.MillisecondsPerSecond
      language: CSharp
      name:
        CSharp: MillisecondsPerSecond
        VB: MillisecondsPerSecond
      nameWithType:
        CSharp: NodaConstants.MillisecondsPerSecond
        VB: NodaConstants.MillisecondsPerSecond
      qualifiedName:
        CSharp: NodaTime.NodaConstants.MillisecondsPerSecond
        VB: NodaTime.NodaConstants.MillisecondsPerSecond
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MillisecondsPerSecond
        path: src/NodaTime/NodaConstants.cs
        startLine: 46
      summary: "\nA constant for the number of milliseconds per second.\nThe value of this constant is 1000.\n"
      example: []
      syntax:
        content:
          CSharp: public const int MillisecondsPerSecond = 1000
          VB: Public Const MillisecondsPerSecond As Integer = 1000
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.MillisecondsPerMinute
      commentId: F:NodaTime.NodaConstants.MillisecondsPerMinute
      language: CSharp
      name:
        CSharp: MillisecondsPerMinute
        VB: MillisecondsPerMinute
      nameWithType:
        CSharp: NodaConstants.MillisecondsPerMinute
        VB: NodaConstants.MillisecondsPerMinute
      qualifiedName:
        CSharp: NodaTime.NodaConstants.MillisecondsPerMinute
        VB: NodaTime.NodaConstants.MillisecondsPerMinute
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MillisecondsPerMinute
        path: src/NodaTime/NodaConstants.cs
        startLine: 51
      summary: "\nA constant for the number of milliseconds per minute.\nThe value of this constant is 60,000.\n"
      example: []
      syntax:
        content:
          CSharp: public const int MillisecondsPerMinute = 60000
          VB: Public Const MillisecondsPerMinute As Integer = 60000
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.MillisecondsPerHour
      commentId: F:NodaTime.NodaConstants.MillisecondsPerHour
      language: CSharp
      name:
        CSharp: MillisecondsPerHour
        VB: MillisecondsPerHour
      nameWithType:
        CSharp: NodaConstants.MillisecondsPerHour
        VB: NodaConstants.MillisecondsPerHour
      qualifiedName:
        CSharp: NodaTime.NodaConstants.MillisecondsPerHour
        VB: NodaTime.NodaConstants.MillisecondsPerHour
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MillisecondsPerHour
        path: src/NodaTime/NodaConstants.cs
        startLine: 56
      summary: "\nA constant for the number of milliseconds per hour.\nThe value of this constant is 3,600,000.\n"
      example: []
      syntax:
        content:
          CSharp: public const int MillisecondsPerHour = 3600000
          VB: Public Const MillisecondsPerHour As Integer = 3600000
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.MillisecondsPerStandardDay
      commentId: F:NodaTime.NodaConstants.MillisecondsPerStandardDay
      language: CSharp
      name:
        CSharp: MillisecondsPerStandardDay
        VB: MillisecondsPerStandardDay
      nameWithType:
        CSharp: NodaConstants.MillisecondsPerStandardDay
        VB: NodaConstants.MillisecondsPerStandardDay
      qualifiedName:
        CSharp: NodaTime.NodaConstants.MillisecondsPerStandardDay
        VB: NodaTime.NodaConstants.MillisecondsPerStandardDay
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MillisecondsPerStandardDay
        path: src/NodaTime/NodaConstants.cs
        startLine: 61
      summary: "\nA constant for the number of milliseconds per standard 24-hour day.\nThe value of this constant is 86,400,000.\n"
      example: []
      syntax:
        content:
          CSharp: public const int MillisecondsPerStandardDay = 86400000
          VB: Public Const MillisecondsPerStandardDay As Integer = 86400000
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.MillisecondsPerStandardWeek
      commentId: F:NodaTime.NodaConstants.MillisecondsPerStandardWeek
      language: CSharp
      name:
        CSharp: MillisecondsPerStandardWeek
        VB: MillisecondsPerStandardWeek
      nameWithType:
        CSharp: NodaConstants.MillisecondsPerStandardWeek
        VB: NodaConstants.MillisecondsPerStandardWeek
      qualifiedName:
        CSharp: NodaTime.NodaConstants.MillisecondsPerStandardWeek
        VB: NodaTime.NodaConstants.MillisecondsPerStandardWeek
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MillisecondsPerStandardWeek
        path: src/NodaTime/NodaConstants.cs
        startLine: 66
      summary: "\nA constant for the number of milliseconds per standard week of seven 24-hour days.\nThe value of this constant is 604,800,000.\n"
      example: []
      syntax:
        content:
          CSharp: public const int MillisecondsPerStandardWeek = 604800000
          VB: Public Const MillisecondsPerStandardWeek As Integer = 604800000
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.SecondsPerMinute
      commentId: F:NodaTime.NodaConstants.SecondsPerMinute
      language: CSharp
      name:
        CSharp: SecondsPerMinute
        VB: SecondsPerMinute
      nameWithType:
        CSharp: NodaConstants.SecondsPerMinute
        VB: NodaConstants.SecondsPerMinute
      qualifiedName:
        CSharp: NodaTime.NodaConstants.SecondsPerMinute
        VB: NodaTime.NodaConstants.SecondsPerMinute
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: SecondsPerMinute
        path: src/NodaTime/NodaConstants.cs
        startLine: 72
      summary: "\nA constant for the number of seconds per minute.\nThe value of this constant is 60.\n"
      example: []
      syntax:
        content:
          CSharp: public const int SecondsPerMinute = 60
          VB: Public Const SecondsPerMinute As Integer = 60
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.SecondsPerHour
      commentId: F:NodaTime.NodaConstants.SecondsPerHour
      language: CSharp
      name:
        CSharp: SecondsPerHour
        VB: SecondsPerHour
      nameWithType:
        CSharp: NodaConstants.SecondsPerHour
        VB: NodaConstants.SecondsPerHour
      qualifiedName:
        CSharp: NodaTime.NodaConstants.SecondsPerHour
        VB: NodaTime.NodaConstants.SecondsPerHour
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: SecondsPerHour
        path: src/NodaTime/NodaConstants.cs
        startLine: 77
      summary: "\nA constant for the number of seconds per hour.\nThe value of this constant is 3,600.\n"
      example: []
      syntax:
        content:
          CSharp: public const int SecondsPerHour = 3600
          VB: Public Const SecondsPerHour As Integer = 3600
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.SecondsPerStandardDay
      commentId: F:NodaTime.NodaConstants.SecondsPerStandardDay
      language: CSharp
      name:
        CSharp: SecondsPerStandardDay
        VB: SecondsPerStandardDay
      nameWithType:
        CSharp: NodaConstants.SecondsPerStandardDay
        VB: NodaConstants.SecondsPerStandardDay
      qualifiedName:
        CSharp: NodaTime.NodaConstants.SecondsPerStandardDay
        VB: NodaTime.NodaConstants.SecondsPerStandardDay
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: SecondsPerStandardDay
        path: src/NodaTime/NodaConstants.cs
        startLine: 82
      summary: "\nA constant for the number of seconds per standard 24-hour day.\nThe value of this constant is 86,400.\n"
      example: []
      syntax:
        content:
          CSharp: public const int SecondsPerStandardDay = 86400
          VB: Public Const SecondsPerStandardDay As Integer = 86400
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.SecondsPerWeek
      commentId: F:NodaTime.NodaConstants.SecondsPerWeek
      language: CSharp
      name:
        CSharp: SecondsPerWeek
        VB: SecondsPerWeek
      nameWithType:
        CSharp: NodaConstants.SecondsPerWeek
        VB: NodaConstants.SecondsPerWeek
      qualifiedName:
        CSharp: NodaTime.NodaConstants.SecondsPerWeek
        VB: NodaTime.NodaConstants.SecondsPerWeek
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: SecondsPerWeek
        path: src/NodaTime/NodaConstants.cs
        startLine: 87
      summary: "\nA constant for the number of seconds per standard week of seven 24-hour days.\nThe value of this constant is 604,800.\n"
      example: []
      syntax:
        content:
          CSharp: public const int SecondsPerWeek = 604800
          VB: Public Const SecondsPerWeek As Integer = 604800
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.MinutesPerHour
      commentId: F:NodaTime.NodaConstants.MinutesPerHour
      language: CSharp
      name:
        CSharp: MinutesPerHour
        VB: MinutesPerHour
      nameWithType:
        CSharp: NodaConstants.MinutesPerHour
        VB: NodaConstants.MinutesPerHour
      qualifiedName:
        CSharp: NodaTime.NodaConstants.MinutesPerHour
        VB: NodaTime.NodaConstants.MinutesPerHour
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MinutesPerHour
        path: src/NodaTime/NodaConstants.cs
        startLine: 93
      summary: "\nA constant for the number of minutes per hour.\nThe value of this constant is 60.\n"
      example: []
      syntax:
        content:
          CSharp: public const int MinutesPerHour = 60
          VB: Public Const MinutesPerHour As Integer = 60
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.MinutesPerStandardDay
      commentId: F:NodaTime.NodaConstants.MinutesPerStandardDay
      language: CSharp
      name:
        CSharp: MinutesPerStandardDay
        VB: MinutesPerStandardDay
      nameWithType:
        CSharp: NodaConstants.MinutesPerStandardDay
        VB: NodaConstants.MinutesPerStandardDay
      qualifiedName:
        CSharp: NodaTime.NodaConstants.MinutesPerStandardDay
        VB: NodaTime.NodaConstants.MinutesPerStandardDay
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MinutesPerStandardDay
        path: src/NodaTime/NodaConstants.cs
        startLine: 98
      summary: "\nA constant for the number of minutes per standard 24-hour day.\nThe value of this constant is 1,440.\n"
      example: []
      syntax:
        content:
          CSharp: public const int MinutesPerStandardDay = 1440
          VB: Public Const MinutesPerStandardDay As Integer = 1440
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.MinutesPerStandardWeek
      commentId: F:NodaTime.NodaConstants.MinutesPerStandardWeek
      language: CSharp
      name:
        CSharp: MinutesPerStandardWeek
        VB: MinutesPerStandardWeek
      nameWithType:
        CSharp: NodaConstants.MinutesPerStandardWeek
        VB: NodaConstants.MinutesPerStandardWeek
      qualifiedName:
        CSharp: NodaTime.NodaConstants.MinutesPerStandardWeek
        VB: NodaTime.NodaConstants.MinutesPerStandardWeek
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MinutesPerStandardWeek
        path: src/NodaTime/NodaConstants.cs
        startLine: 103
      summary: "\nA constant for the number of minutes per standard week of seven 24-hour days.\nThe value of this constant is 10,080.\n"
      example: []
      syntax:
        content:
          CSharp: public const int MinutesPerStandardWeek = 10080
          VB: Public Const MinutesPerStandardWeek As Integer = 10080
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.HoursPerStandardDay
      commentId: F:NodaTime.NodaConstants.HoursPerStandardDay
      language: CSharp
      name:
        CSharp: HoursPerStandardDay
        VB: HoursPerStandardDay
      nameWithType:
        CSharp: NodaConstants.HoursPerStandardDay
        VB: NodaConstants.HoursPerStandardDay
      qualifiedName:
        CSharp: NodaTime.NodaConstants.HoursPerStandardDay
        VB: NodaTime.NodaConstants.HoursPerStandardDay
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: HoursPerStandardDay
        path: src/NodaTime/NodaConstants.cs
        startLine: 110
      summary: "\nA constant for the number of hours in a standard day. Note that the number of hours\nin a day can vary due to daylight saving effects.\nThe value of this constant is 24.\n"
      example: []
      syntax:
        content:
          CSharp: public const int HoursPerStandardDay = 24
          VB: Public Const HoursPerStandardDay As Integer = 24
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.HoursPerStandardWeek
      commentId: F:NodaTime.NodaConstants.HoursPerStandardWeek
      language: CSharp
      name:
        CSharp: HoursPerStandardWeek
        VB: HoursPerStandardWeek
      nameWithType:
        CSharp: NodaConstants.HoursPerStandardWeek
        VB: NodaConstants.HoursPerStandardWeek
      qualifiedName:
        CSharp: NodaTime.NodaConstants.HoursPerStandardWeek
        VB: NodaTime.NodaConstants.HoursPerStandardWeek
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: HoursPerStandardWeek
        path: src/NodaTime/NodaConstants.cs
        startLine: 115
      summary: "\nA constant for the number of hours in a standard week of seven 24-hour days.\nThe value of this constant is 168.\n"
      example: []
      syntax:
        content:
          CSharp: public const int HoursPerStandardWeek = 168
          VB: Public Const HoursPerStandardWeek As Integer = 168
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.DaysPerStandardWeek
      commentId: F:NodaTime.NodaConstants.DaysPerStandardWeek
      language: CSharp
      name:
        CSharp: DaysPerStandardWeek
        VB: DaysPerStandardWeek
      nameWithType:
        CSharp: NodaConstants.DaysPerStandardWeek
        VB: NodaConstants.DaysPerStandardWeek
      qualifiedName:
        CSharp: NodaTime.NodaConstants.DaysPerStandardWeek
        VB: NodaTime.NodaConstants.DaysPerStandardWeek
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DaysPerStandardWeek
        path: src/NodaTime/NodaConstants.cs
        startLine: 121
      summary: "\nNumber of days in a standard Gregorian week.\nThe value of this constant is 7.\n"
      example: []
      syntax:
        content:
          CSharp: public const int DaysPerStandardWeek = 7
          VB: Public Const DaysPerStandardWeek As Integer = 7
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.NodaConstants.UnixEpoch
      commentId: F:NodaTime.NodaConstants.UnixEpoch
      language: CSharp
      name:
        CSharp: UnixEpoch
        VB: UnixEpoch
      nameWithType:
        CSharp: NodaConstants.UnixEpoch
        VB: NodaConstants.UnixEpoch
      qualifiedName:
        CSharp: NodaTime.NodaConstants.UnixEpoch
        VB: NodaTime.NodaConstants.UnixEpoch
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: UnixEpoch
        path: src/NodaTime/NodaConstants.cs
        startLine: 130
      summary: "\nThe instant at the Unix epoch of midnight 1st January 1970 UTC.\n"
      remarks: "\nThis value is not only the Unix epoch, but the Noda Time epoch, as it represents the value\nwith a <xref href=\"NodaTime.Instant.Ticks\" data-throw-if-not-resolved=\"false\"></xref> property of 0.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Instant UnixEpoch
          VB: Public Shared ReadOnly UnixEpoch As Instant
        return:
          type: NodaTime.Instant
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.Instant.Ticks: 
    - id: NodaTime.NodaConstants.BclEpoch
      commentId: F:NodaTime.NodaConstants.BclEpoch
      language: CSharp
      name:
        CSharp: BclEpoch
        VB: BclEpoch
      nameWithType:
        CSharp: NodaConstants.BclEpoch
        VB: NodaConstants.BclEpoch
      qualifiedName:
        CSharp: NodaTime.NodaConstants.BclEpoch
        VB: NodaTime.NodaConstants.BclEpoch
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/NodaConstants.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: BclEpoch
        path: src/NodaTime/NodaConstants.cs
        startLine: 135
      summary: "\nThe instant at the BCL epoch of midnight 1st January 0001 UTC.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Instant BclEpoch
          VB: Public Shared ReadOnly BclEpoch As Instant
        return:
          type: NodaTime.Instant
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
  - id: NodaTime.ZonedDateTime
    commentId: T:NodaTime.ZonedDateTime
    language: CSharp
    name:
      CSharp: ZonedDateTime
      VB: ZonedDateTime
    nameWithType:
      CSharp: ZonedDateTime
      VB: ZonedDateTime
    qualifiedName:
      CSharp: NodaTime.ZonedDateTime
      VB: NodaTime.ZonedDateTime
    type: Struct
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/ZonedDateTime.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: ZonedDateTime
      path: src/NodaTime/ZonedDateTime.cs
      startLine: 48
    summary: "\nA <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> in a specific time zone and with a particular offset to distinguish\nbetween otherwise-ambiguous instants. A <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> is global, in that it maps to a single\n<xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    remarks: "\n<p>Although <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> includes both local and global concepts, it only supports\nduration-based - and not calendar-based - arithmetic. This avoids ambiguities\nand skipped date/time values becoming a problem within a series of calculations; instead,\nthese can be considered just once, at the point of conversion to a <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>.\n</p>\n<p>Comparisons of values can be handled in a way which is either calendar and zone sensitive or insensitive.\nNoda Time implements all the operators (and the <xref href=\"NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)\" data-throw-if-not-resolved=\"false\"></xref> method) such that all operators other than <xref href=\"NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime%2cNodaTime.ZonedDateTime)\" data-throw-if-not-resolved=\"false\"></xref>\nwill return false if asked to compare two values in different calendar systems or time zones.\n</p>\n<p>\nHowever, the <xref href=\"NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)\" data-throw-if-not-resolved=\"false\"></xref> method (implementing <xref href=\"System.IComparable%601\" data-throw-if-not-resolved=\"false\"></xref>) is calendar and zone insensitive; it compares the two\nglobal instants in terms of when they actually occurred.\n</p>\n<p>\nIt's unclear at the time of this writing whether this is the most appropriate approach, and it may change in future versions. In general,\nit would be a good idea for users to avoid comparing dates in different calendar systems, and indeed most users are unlikely to ever explicitly\nconsider which calendar system they're working in anyway.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public struct ZonedDateTime : IEquatable<ZonedDateTime>, IComparable<ZonedDateTime>, IComparable, IFormattable, IXmlSerializable, ISerializable
        VB: >-
          <Serializable>

          Public Structure ZonedDateTime

              Implements IEquatable(Of ZonedDateTime), IComparable(Of ZonedDateTime), IComparable, IFormattable, IXmlSerializable, ISerializable
    implements:
    - System.IEquatable{NodaTime.ZonedDateTime}
    - System.IComparable{NodaTime.ZonedDateTime}
    - System.IComparable
    - System.IFormattable
    - System.Xml.Serialization.IXmlSerializable
    - System.Runtime.Serialization.ISerializable
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone,NodaTime.CalendarSystem)
      commentId: M:NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone,NodaTime.CalendarSystem)
      language: CSharp
      name:
        CSharp: ZonedDateTime(Instant, DateTimeZone, CalendarSystem)
        VB: ZonedDateTime(Instant, DateTimeZone, CalendarSystem)
      nameWithType:
        CSharp: ZonedDateTime.ZonedDateTime(Instant, DateTimeZone, CalendarSystem)
        VB: ZonedDateTime.ZonedDateTime(Instant, DateTimeZone, CalendarSystem)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ZonedDateTime(NodaTime.Instant, NodaTime.DateTimeZone, NodaTime.CalendarSystem)
        VB: NodaTime.ZonedDateTime.ZonedDateTime(NodaTime.Instant, NodaTime.DateTimeZone, NodaTime.CalendarSystem)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 77
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime(Instant instant, DateTimeZone zone, CalendarSystem calendar)
          VB: Public Sub New(instant As Instant, zone As DateTimeZone, calendar As CalendarSystem)
        parameters:
        - id: instant
          type: NodaTime.Instant
          description: The instant.
        - id: zone
          type: NodaTime.DateTimeZone
          description: The time zone.
        - id: calendar
          type: NodaTime.CalendarSystem
          description: The calendar system.
      overload: NodaTime.ZonedDateTime.#ctor*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">zone</span> or <span class="paramref">calendar</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone)
      commentId: M:NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: ZonedDateTime(Instant, DateTimeZone)
        VB: ZonedDateTime(Instant, DateTimeZone)
      nameWithType:
        CSharp: ZonedDateTime.ZonedDateTime(Instant, DateTimeZone)
        VB: ZonedDateTime.ZonedDateTime(Instant, DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ZonedDateTime(NodaTime.Instant, NodaTime.DateTimeZone)
        VB: NodaTime.ZonedDateTime.ZonedDateTime(NodaTime.Instant, NodaTime.DateTimeZone)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 92
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct in the specified time zone\nand the ISO calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime(Instant instant, DateTimeZone zone)
          VB: Public Sub New(instant As Instant, zone As DateTimeZone)
        parameters:
        - id: instant
          type: NodaTime.Instant
          description: The instant.
        - id: zone
          type: NodaTime.DateTimeZone
          description: The time zone.
      overload: NodaTime.ZonedDateTime.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone,NodaTime.Offset)
      commentId: M:NodaTime.ZonedDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: ZonedDateTime(LocalDateTime, DateTimeZone, Offset)
        VB: ZonedDateTime(LocalDateTime, DateTimeZone, Offset)
      nameWithType:
        CSharp: ZonedDateTime.ZonedDateTime(LocalDateTime, DateTimeZone, Offset)
        VB: ZonedDateTime.ZonedDateTime(LocalDateTime, DateTimeZone, Offset)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ZonedDateTime(NodaTime.LocalDateTime, NodaTime.DateTimeZone, NodaTime.Offset)
        VB: NodaTime.ZonedDateTime.ZonedDateTime(NodaTime.LocalDateTime, NodaTime.DateTimeZone, NodaTime.Offset)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 108
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> struct in the specified time zone\nfrom a given local time and offset. The offset is validated to be correct as part of initialization.\nIn most cases a local time can only map to a single instant anyway, but the offset is included here for cases\nwhere the local time is ambiguous, usually due to daylight saving transitions.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime(LocalDateTime localDateTime, DateTimeZone zone, Offset offset)
          VB: Public Sub New(localDateTime As LocalDateTime, zone As DateTimeZone, offset As Offset)
        parameters:
        - id: localDateTime
          type: NodaTime.LocalDateTime
          description: The local date and time.
        - id: zone
          type: NodaTime.DateTimeZone
          description: The time zone.
        - id: offset
          type: NodaTime.Offset
          description: The offset between UTC and local time at the desired instant.
      overload: NodaTime.ZonedDateTime.#ctor*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">zone</span> is null.
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: >-
          <span class="paramref">offset</span> is not a valid offset at the given
              local date and time.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.Offset
      commentId: P:NodaTime.ZonedDateTime.Offset
      language: CSharp
      name:
        CSharp: Offset
        VB: Offset
      nameWithType:
        CSharp: ZonedDateTime.Offset
        VB: ZonedDateTime.Offset
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Offset
        VB: NodaTime.ZonedDateTime.Offset
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Offset
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 125
      summary: Gets the offset of the local representation of this value from UTC.
      example: []
      syntax:
        content:
          CSharp: public Offset Offset { get; }
          VB: Public ReadOnly Property Offset As Offset
        parameters: []
        return:
          type: NodaTime.Offset
      overload: NodaTime.ZonedDateTime.Offset*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.Zone
      commentId: P:NodaTime.ZonedDateTime.Zone
      language: CSharp
      name:
        CSharp: Zone
        VB: Zone
      nameWithType:
        CSharp: ZonedDateTime.Zone
        VB: ZonedDateTime.Zone
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Zone
        VB: NodaTime.ZonedDateTime.Zone
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Zone
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 128
      summary: Gets the time zone associated with this value.
      example: []
      syntax:
        content:
          CSharp: public DateTimeZone Zone { get; }
          VB: Public ReadOnly Property Zone As DateTimeZone
        parameters: []
        return:
          type: NodaTime.DateTimeZone
      overload: NodaTime.ZonedDateTime.Zone*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.LocalDateTime
      commentId: P:NodaTime.ZonedDateTime.LocalDateTime
      language: CSharp
      name:
        CSharp: LocalDateTime
        VB: LocalDateTime
      nameWithType:
        CSharp: ZonedDateTime.LocalDateTime
        VB: ZonedDateTime.LocalDateTime
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.LocalDateTime
        VB: NodaTime.ZonedDateTime.LocalDateTime
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: LocalDateTime
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 139
      summary: "\nGets the local date and time represented by this zoned date and time. The returned\n<xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> will have the same calendar system and return the same values for\neach of the calendar properties (Year, MonthOfYear and so on), but will not be associated with any\nparticular time zone.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime LocalDateTime { get; }
          VB: Public ReadOnly Property LocalDateTime As LocalDateTime
        parameters: []
        return:
          type: NodaTime.LocalDateTime
      overload: NodaTime.ZonedDateTime.LocalDateTime*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.ZonedDateTime.Calendar
      commentId: P:NodaTime.ZonedDateTime.Calendar
      language: CSharp
      name:
        CSharp: Calendar
        VB: Calendar
      nameWithType:
        CSharp: ZonedDateTime.Calendar
        VB: ZonedDateTime.Calendar
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Calendar
        VB: NodaTime.ZonedDateTime.Calendar
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Calendar
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 142
      summary: Gets the calendar system associated with this zoned date and time.
      example: []
      syntax:
        content:
          CSharp: public CalendarSystem Calendar { get; }
          VB: Public ReadOnly Property Calendar As CalendarSystem
        parameters: []
        return:
          type: NodaTime.CalendarSystem
      overload: NodaTime.ZonedDateTime.Calendar*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.Date
      commentId: P:NodaTime.ZonedDateTime.Date
      language: CSharp
      name:
        CSharp: Date
        VB: Date
      nameWithType:
        CSharp: ZonedDateTime.Date
        VB: ZonedDateTime.Date
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Date
        VB: NodaTime.ZonedDateTime.Date
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Date
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 152
      summary: "\nGets the local date represented by this zoned date and time. The returned <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref>\nwill have the same calendar system and return the same values for each of the date-based calendar\nproperties (Year, MonthOfYear and so on), but will not be associated with any particular time zone.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate Date { get; }
          VB: Public ReadOnly Property Date As LocalDate
        parameters: []
        return:
          type: NodaTime.LocalDate
      overload: NodaTime.ZonedDateTime.Date*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDate: 
    - id: NodaTime.ZonedDateTime.TimeOfDay
      commentId: P:NodaTime.ZonedDateTime.TimeOfDay
      language: CSharp
      name:
        CSharp: TimeOfDay
        VB: TimeOfDay
      nameWithType:
        CSharp: ZonedDateTime.TimeOfDay
        VB: ZonedDateTime.TimeOfDay
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.TimeOfDay
        VB: NodaTime.ZonedDateTime.TimeOfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TimeOfDay
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 159
      summary: "\nGets the time portion of this zoned date and time. The returned <xref href=\"NodaTime.LocalTime\" data-throw-if-not-resolved=\"false\"></xref> will\nreturn the same values for each of the time-based properties (Hour, Minute and so on), but\nwill not be associated with any particular time zone.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime TimeOfDay { get; }
          VB: Public ReadOnly Property TimeOfDay As LocalTime
        parameters: []
        return:
          type: NodaTime.LocalTime
      overload: NodaTime.ZonedDateTime.TimeOfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalTime: 
    - id: NodaTime.ZonedDateTime.Era
      commentId: P:NodaTime.ZonedDateTime.Era
      language: CSharp
      name:
        CSharp: Era
        VB: Era
      nameWithType:
        CSharp: ZonedDateTime.Era
        VB: ZonedDateTime.Era
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Era
        VB: NodaTime.ZonedDateTime.Era
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Era
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 162
      summary: Gets the era for this zoned date and time.
      example: []
      syntax:
        content:
          CSharp: public Era Era { get; }
          VB: Public ReadOnly Property Era As Era
        parameters: []
        return:
          type: NodaTime.Calendars.Era
      overload: NodaTime.ZonedDateTime.Era*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.CenturyOfEra
      commentId: P:NodaTime.ZonedDateTime.CenturyOfEra
      language: CSharp
      name:
        CSharp: CenturyOfEra
        VB: CenturyOfEra
      nameWithType:
        CSharp: ZonedDateTime.CenturyOfEra
        VB: ZonedDateTime.CenturyOfEra
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.CenturyOfEra
        VB: NodaTime.ZonedDateTime.CenturyOfEra
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CenturyOfEra
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 165
      summary: Gets the century within the era of this zoned date and time.
      example: []
      syntax:
        content:
          CSharp: public int CenturyOfEra { get; }
          VB: Public ReadOnly Property CenturyOfEra As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.CenturyOfEra*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.Year
      commentId: P:NodaTime.ZonedDateTime.Year
      language: CSharp
      name:
        CSharp: Year
        VB: Year
      nameWithType:
        CSharp: ZonedDateTime.Year
        VB: ZonedDateTime.Year
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Year
        VB: NodaTime.ZonedDateTime.Year
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Year
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 170
      summary: Gets the year of this zoned date and time.
      remarks: >-
        This returns the "absolute year", so, for the ISO calendar,

        a value of 0 means 1 BC, for example.
      example: []
      syntax:
        content:
          CSharp: public int Year { get; }
          VB: Public ReadOnly Property Year As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.Year*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.YearOfCentury
      commentId: P:NodaTime.ZonedDateTime.YearOfCentury
      language: CSharp
      name:
        CSharp: YearOfCentury
        VB: YearOfCentury
      nameWithType:
        CSharp: ZonedDateTime.YearOfCentury
        VB: ZonedDateTime.YearOfCentury
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.YearOfCentury
        VB: NodaTime.ZonedDateTime.YearOfCentury
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: YearOfCentury
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 174
      summary: Gets the year of this zoned date and time within its century.
      remarks: This always returns a value in the range 0 to 99 inclusive.
      example: []
      syntax:
        content:
          CSharp: public int YearOfCentury { get; }
          VB: Public ReadOnly Property YearOfCentury As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.YearOfCentury*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.YearOfEra
      commentId: P:NodaTime.ZonedDateTime.YearOfEra
      language: CSharp
      name:
        CSharp: YearOfEra
        VB: YearOfEra
      nameWithType:
        CSharp: ZonedDateTime.YearOfEra
        VB: ZonedDateTime.YearOfEra
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.YearOfEra
        VB: NodaTime.ZonedDateTime.YearOfEra
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: YearOfEra
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 177
      summary: Gets the year of this zoned date and time within its era.
      example: []
      syntax:
        content:
          CSharp: public int YearOfEra { get; }
          VB: Public ReadOnly Property YearOfEra As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.YearOfEra*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.WeekYear
      commentId: P:NodaTime.ZonedDateTime.WeekYear
      language: CSharp
      name:
        CSharp: WeekYear
        VB: WeekYear
      nameWithType:
        CSharp: ZonedDateTime.WeekYear
        VB: ZonedDateTime.WeekYear
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.WeekYear
        VB: NodaTime.ZonedDateTime.WeekYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WeekYear
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 197
      summary: "\nGets the \"week year\" of this date and time.\n"
      remarks: "\n<p>\nThe WeekYear is the year that matches with the <xref href=\"NodaTime.ZonedDateTime.WeekOfWeekYear\" data-throw-if-not-resolved=\"false\"></xref> field.\nIn the standard ISO-8601 week algorithm, the first week of the year\nis that in which at least 4 days are in the year. As a result of this\ndefinition, day 1 of the first week may be in the previous year.\nThe WeekYear allows you to query the effective year for that day.\n</p>\n<p>\nFor example, January 1st 2011 was a Saturday, so only two days of that week\n(Saturday and Sunday) were in 2011. Therefore January 1st is part of\nweek 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,\nso is part of week 1 of WeekYear 2013.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public int WeekYear { get; }
          VB: Public ReadOnly Property WeekYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.WeekYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.ZonedDateTime.WeekOfWeekYear: 
    - id: NodaTime.ZonedDateTime.Month
      commentId: P:NodaTime.ZonedDateTime.Month
      language: CSharp
      name:
        CSharp: Month
        VB: Month
      nameWithType:
        CSharp: ZonedDateTime.Month
        VB: ZonedDateTime.Month
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Month
        VB: NodaTime.ZonedDateTime.Month
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Month
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 200
      summary: Gets the month of this zoned date and time within the year.
      example: []
      syntax:
        content:
          CSharp: public int Month { get; }
          VB: Public ReadOnly Property Month As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.Month*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.WeekOfWeekYear
      commentId: P:NodaTime.ZonedDateTime.WeekOfWeekYear
      language: CSharp
      name:
        CSharp: WeekOfWeekYear
        VB: WeekOfWeekYear
      nameWithType:
        CSharp: ZonedDateTime.WeekOfWeekYear
        VB: ZonedDateTime.WeekOfWeekYear
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.WeekOfWeekYear
        VB: NodaTime.ZonedDateTime.WeekOfWeekYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WeekOfWeekYear
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 203
      summary: Gets the week within the WeekYear. See <xref href="NodaTime.ZonedDateTime.WeekYear" data-throw-if-not-resolved="false"></xref> for more details.
      example: []
      syntax:
        content:
          CSharp: public int WeekOfWeekYear { get; }
          VB: Public ReadOnly Property WeekOfWeekYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.WeekOfWeekYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.ZonedDateTime.WeekYear: 
    - id: NodaTime.ZonedDateTime.DayOfYear
      commentId: P:NodaTime.ZonedDateTime.DayOfYear
      language: CSharp
      name:
        CSharp: DayOfYear
        VB: DayOfYear
      nameWithType:
        CSharp: ZonedDateTime.DayOfYear
        VB: ZonedDateTime.DayOfYear
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.DayOfYear
        VB: NodaTime.ZonedDateTime.DayOfYear
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DayOfYear
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 206
      summary: Gets the day of this zoned date and time within the year.
      example: []
      syntax:
        content:
          CSharp: public int DayOfYear { get; }
          VB: Public ReadOnly Property DayOfYear As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.DayOfYear*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.Day
      commentId: P:NodaTime.ZonedDateTime.Day
      language: CSharp
      name:
        CSharp: Day
        VB: Day
      nameWithType:
        CSharp: ZonedDateTime.Day
        VB: ZonedDateTime.Day
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Day
        VB: NodaTime.ZonedDateTime.Day
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Day
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 211
      summary: "\nGets the day of this zoned date and time within the month.\n"
      example: []
      syntax:
        content:
          CSharp: public int Day { get; }
          VB: Public ReadOnly Property Day As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.Day*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.IsoDayOfWeek
      commentId: P:NodaTime.ZonedDateTime.IsoDayOfWeek
      language: CSharp
      name:
        CSharp: IsoDayOfWeek
        VB: IsoDayOfWeek
      nameWithType:
        CSharp: ZonedDateTime.IsoDayOfWeek
        VB: ZonedDateTime.IsoDayOfWeek
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.IsoDayOfWeek
        VB: NodaTime.ZonedDateTime.IsoDayOfWeek
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: IsoDayOfWeek
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 219
      summary: "\nGets the week day of this zoned date and time expressed as an <xref href=\"NodaTime.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref> value,\nfor calendars which use ISO days of the week.\n"
      example: []
      syntax:
        content:
          CSharp: public IsoDayOfWeek IsoDayOfWeek { get; }
          VB: Public ReadOnly Property IsoDayOfWeek As IsoDayOfWeek
        parameters: []
        return:
          type: NodaTime.IsoDayOfWeek
      overload: NodaTime.ZonedDateTime.IsoDayOfWeek*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The underlying calendar doesn't use ISO days of the week.
      seealso:
      - linkId: NodaTime.ZonedDateTime.DayOfWeek
        commentId: P:NodaTime.ZonedDateTime.DayOfWeek
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.IsoDayOfWeek: 
        NodaTime.ZonedDateTime.DayOfWeek: 
    - id: NodaTime.ZonedDateTime.DayOfWeek
      commentId: P:NodaTime.ZonedDateTime.DayOfWeek
      language: CSharp
      name:
        CSharp: DayOfWeek
        VB: DayOfWeek
      nameWithType:
        CSharp: ZonedDateTime.DayOfWeek
        VB: ZonedDateTime.DayOfWeek
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.DayOfWeek
        VB: NodaTime.ZonedDateTime.DayOfWeek
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DayOfWeek
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 228
      summary: "\nGets the week day of this zoned date and time as a number.\n"
      remarks: "\nFor calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.\n"
      example: []
      syntax:
        content:
          CSharp: public int DayOfWeek { get; }
          VB: Public ReadOnly Property DayOfWeek As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.DayOfWeek*
      seealso:
      - linkId: NodaTime.ZonedDateTime.IsoDayOfWeek
        commentId: P:NodaTime.ZonedDateTime.IsoDayOfWeek
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.ZonedDateTime.IsoDayOfWeek: 
    - id: NodaTime.ZonedDateTime.Hour
      commentId: P:NodaTime.ZonedDateTime.Hour
      language: CSharp
      name:
        CSharp: Hour
        VB: Hour
      nameWithType:
        CSharp: ZonedDateTime.Hour
        VB: ZonedDateTime.Hour
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Hour
        VB: NodaTime.ZonedDateTime.Hour
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Hour
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 233
      summary: "\nGets the hour of day of this zoned date and time, in the range 0 to 23 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Hour { get; }
          VB: Public ReadOnly Property Hour As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.Hour*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.ClockHourOfHalfDay
      commentId: P:NodaTime.ZonedDateTime.ClockHourOfHalfDay
      language: CSharp
      name:
        CSharp: ClockHourOfHalfDay
        VB: ClockHourOfHalfDay
      nameWithType:
        CSharp: ZonedDateTime.ClockHourOfHalfDay
        VB: ZonedDateTime.ClockHourOfHalfDay
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ClockHourOfHalfDay
        VB: NodaTime.ZonedDateTime.ClockHourOfHalfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ClockHourOfHalfDay
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 238
      summary: "\nGets the hour of the half-day of this zoned date and time, in the range 1 to 12 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int ClockHourOfHalfDay { get; }
          VB: Public ReadOnly Property ClockHourOfHalfDay As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.ClockHourOfHalfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.Minute
      commentId: P:NodaTime.ZonedDateTime.Minute
      language: CSharp
      name:
        CSharp: Minute
        VB: Minute
      nameWithType:
        CSharp: ZonedDateTime.Minute
        VB: ZonedDateTime.Minute
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Minute
        VB: NodaTime.ZonedDateTime.Minute
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minute
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 243
      summary: "\nGets the minute of this zoned date and time, in the range 0 to 59 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Minute { get; }
          VB: Public ReadOnly Property Minute As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.Minute*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.Second
      commentId: P:NodaTime.ZonedDateTime.Second
      language: CSharp
      name:
        CSharp: Second
        VB: Second
      nameWithType:
        CSharp: ZonedDateTime.Second
        VB: ZonedDateTime.Second
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Second
        VB: NodaTime.ZonedDateTime.Second
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Second
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 248
      summary: "\nGets the second of this zoned date and time within the minute, in the range 0 to 59 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Second { get; }
          VB: Public ReadOnly Property Second As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.Second*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.Millisecond
      commentId: P:NodaTime.ZonedDateTime.Millisecond
      language: CSharp
      name:
        CSharp: Millisecond
        VB: Millisecond
      nameWithType:
        CSharp: ZonedDateTime.Millisecond
        VB: ZonedDateTime.Millisecond
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Millisecond
        VB: NodaTime.ZonedDateTime.Millisecond
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Millisecond
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 253
      summary: "\nGets the millisecond of this zoned date and time within the second, in the range 0 to 999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int Millisecond { get; }
          VB: Public ReadOnly Property Millisecond As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.Millisecond*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.TickOfSecond
      commentId: P:NodaTime.ZonedDateTime.TickOfSecond
      language: CSharp
      name:
        CSharp: TickOfSecond
        VB: TickOfSecond
      nameWithType:
        CSharp: ZonedDateTime.TickOfSecond
        VB: ZonedDateTime.TickOfSecond
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.TickOfSecond
        VB: NodaTime.ZonedDateTime.TickOfSecond
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TickOfSecond
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 258
      summary: "\nGets the tick of this zoned date and time within the second, in the range 0 to 9,999,999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public int TickOfSecond { get; }
          VB: Public ReadOnly Property TickOfSecond As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.ZonedDateTime.TickOfSecond*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.TickOfDay
      commentId: P:NodaTime.ZonedDateTime.TickOfDay
      language: CSharp
      name:
        CSharp: TickOfDay
        VB: TickOfDay
      nameWithType:
        CSharp: ZonedDateTime.TickOfDay
        VB: ZonedDateTime.TickOfDay
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.TickOfDay
        VB: NodaTime.ZonedDateTime.TickOfDay
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TickOfDay
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 263
      summary: "\nGets the tick of this zoned date and time within the day, in the range 0 to 863,999,999,999 inclusive.\n"
      example: []
      syntax:
        content:
          CSharp: public long TickOfDay { get; }
          VB: Public ReadOnly Property TickOfDay As Long
        parameters: []
        return:
          type: System.Int64
      overload: NodaTime.ZonedDateTime.TickOfDay*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.ZonedDateTime.ToInstant
      commentId: M:NodaTime.ZonedDateTime.ToInstant
      language: CSharp
      name:
        CSharp: ToInstant()
        VB: ToInstant()
      nameWithType:
        CSharp: ZonedDateTime.ToInstant()
        VB: ZonedDateTime.ToInstant()
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ToInstant()
        VB: NodaTime.ZonedDateTime.ToInstant()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToInstant
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 275
      summary: "\nConverts this value to the instant it represents on the time line.\n"
      remarks: "\nThis is always an unambiguous conversion. Any difficulties due to daylight saving\ntransitions or other changes in time zone are handled when converting from a\n<xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>; the <code>ZonedDateTime</code> remembers\nthe actual offset from UTC to local time, so it always knows the exact instant represented.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant ToInstant()
          VB: Public Function ToInstant As Instant
        return:
          type: NodaTime.Instant
          description: The instant corresponding to this value.
      overload: NodaTime.ZonedDateTime.ToInstant*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.LocalDateTime: 
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.WithZone(NodaTime.DateTimeZone)
      commentId: M:NodaTime.ZonedDateTime.WithZone(NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: WithZone(DateTimeZone)
        VB: WithZone(DateTimeZone)
      nameWithType:
        CSharp: ZonedDateTime.WithZone(DateTimeZone)
        VB: ZonedDateTime.WithZone(DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.WithZone(NodaTime.DateTimeZone)
        VB: NodaTime.ZonedDateTime.WithZone(NodaTime.DateTimeZone)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithZone
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 287
      summary: "\nCreates a new <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> representing the same instant in time, in the\nsame calendar but a different time zone.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime WithZone(DateTimeZone targetZone)
          VB: Public Function WithZone(targetZone As DateTimeZone) As ZonedDateTime
        parameters:
        - id: targetZone
          type: NodaTime.DateTimeZone
          description: The target time zone to convert to.
        return:
          type: NodaTime.ZonedDateTime
          description: A new value in the target time zone.
      overload: NodaTime.ZonedDateTime.WithZone*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">targetZone</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)
      commentId: M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: Equals(ZonedDateTime)
        VB: Equals(ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTime.Equals(ZonedDateTime)
        VB: ZonedDateTime.Equals(ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)
        VB: NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 302
      summary: "\nIndicates whether the current object is equal to another object of the same type.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(ZonedDateTime other)
          VB: Public Function Equals(other As ZonedDateTime) As Boolean
        parameters:
        - id: other
          type: NodaTime.ZonedDateTime
          description: An object to compare with this object.
        return:
          type: System.Boolean
          description: "\ntrue if the current object is equal to the <span class=\"paramref\">other</span> parameter; otherwise, false.\n"
      overload: NodaTime.ZonedDateTime.Equals*
      implements:
      - System.IEquatable{NodaTime.ZonedDateTime}.Equals(NodaTime.ZonedDateTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.ZonedDateTime.Equals(System.Object)
      commentId: M:NodaTime.ZonedDateTime.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: ZonedDateTime.Equals(Object)
        VB: ZonedDateTime.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Equals(System.Object)
        VB: NodaTime.ZonedDateTime.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 316
      summary: "\nIndicates whether this instance and a specified object are equal.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: Another object to compare to.
        return:
          type: System.Boolean
          description: "\ntrue if <span class=\"paramref\">obj</span> and this instance are the same type and represent the same value; otherwise, false.\n"
      overload: NodaTime.ZonedDateTime.Equals*
      overridden: System.ValueType.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.GetHashCode
      commentId: M:NodaTime.ZonedDateTime.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: ZonedDateTime.GetHashCode()
        VB: ZonedDateTime.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.GetHashCode()
        VB: NodaTime.ZonedDateTime.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 332
      summary: "\nComputes the hash code for this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: "\nA 32-bit signed integer that is the hash code for this instance.\n"
      overload: NodaTime.ZonedDateTime.GetHashCode*
      overridden: System.ValueType.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.ZonedDateTime.op_Equality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      commentId: M:NodaTime.ZonedDateTime.op_Equality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: Equality(ZonedDateTime, ZonedDateTime)
        VB: Equality(ZonedDateTime, ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTime.Equality(ZonedDateTime, ZonedDateTime)
        VB: ZonedDateTime.Equality(ZonedDateTime, ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Equality(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
        VB: NodaTime.ZonedDateTime.Equality(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Equality
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 349
      summary: "\nImplements the operator ==.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator ==(ZonedDateTime left, ZonedDateTime right)
          VB: Public Shared Operator =(left As ZonedDateTime, right As ZonedDateTime) As Boolean
        parameters:
        - id: left
          type: NodaTime.ZonedDateTime
          description: The first value to compare
        - id: right
          type: NodaTime.ZonedDateTime
          description: The second value to compare
        return:
          type: System.Boolean
          description: True if the two operands are equal according to <xref href="NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)" data-throw-if-not-resolved="false"></xref>; false otherwise
      overload: NodaTime.ZonedDateTime.op_Equality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime): 
    - id: NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      commentId: M:NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: Inequality(ZonedDateTime, ZonedDateTime)
        VB: Inequality(ZonedDateTime, ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTime.Inequality(ZonedDateTime, ZonedDateTime)
        VB: ZonedDateTime.Inequality(ZonedDateTime, ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Inequality(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
        VB: NodaTime.ZonedDateTime.Inequality(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Inequality
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 360
      summary: "\nImplements the operator !=.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator !=(ZonedDateTime left, ZonedDateTime right)
          VB: Public Shared Operator <>(left As ZonedDateTime, right As ZonedDateTime) As Boolean
        parameters:
        - id: left
          type: NodaTime.ZonedDateTime
          description: The first value to compare
        - id: right
          type: NodaTime.ZonedDateTime
          description: The second value to compare
        return:
          type: System.Boolean
          description: False if the two operands are equal according to <xref href="NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)" data-throw-if-not-resolved="false"></xref>; true otherwise
      overload: NodaTime.ZonedDateTime.op_Inequality*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime): 
    - id: NodaTime.ZonedDateTime.op_LessThan(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      commentId: M:NodaTime.ZonedDateTime.op_LessThan(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: LessThan(ZonedDateTime, ZonedDateTime)
        VB: LessThan(ZonedDateTime, ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTime.LessThan(ZonedDateTime, ZonedDateTime)
        VB: ZonedDateTime.LessThan(ZonedDateTime, ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.LessThan(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
        VB: NodaTime.ZonedDateTime.LessThan(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThan
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 376
      summary: "\nCompares two <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> values to see if the left one is strictly earlier than the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars or time zones.\nSee the top-level type documentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <(ZonedDateTime lhs, ZonedDateTime rhs)
          VB: Public Shared Operator <(lhs As ZonedDateTime, rhs As ZonedDateTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.ZonedDateTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.ZonedDateTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is strictly earlier than <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.ZonedDateTime.op_LessThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.op_LessThanOrEqual(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      commentId: M:NodaTime.ZonedDateTime.op_LessThanOrEqual(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: LessThanOrEqual(ZonedDateTime, ZonedDateTime)
        VB: LessThanOrEqual(ZonedDateTime, ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTime.LessThanOrEqual(ZonedDateTime, ZonedDateTime)
        VB: ZonedDateTime.LessThanOrEqual(ZonedDateTime, ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.LessThanOrEqual(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
        VB: NodaTime.ZonedDateTime.LessThanOrEqual(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_LessThanOrEqual
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 392
      summary: "\nCompares two <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> values to see if the left one is earlier than or equal to the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars or time zones.\nSee the top-level type documentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator <=(ZonedDateTime lhs, ZonedDateTime rhs)
          VB: Public Shared Operator <=(lhs As ZonedDateTime, rhs As ZonedDateTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.ZonedDateTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.ZonedDateTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is earlier than or equal to <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.ZonedDateTime.op_LessThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.op_GreaterThan(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      commentId: M:NodaTime.ZonedDateTime.op_GreaterThan(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: GreaterThan(ZonedDateTime, ZonedDateTime)
        VB: GreaterThan(ZonedDateTime, ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTime.GreaterThan(ZonedDateTime, ZonedDateTime)
        VB: ZonedDateTime.GreaterThan(ZonedDateTime, ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.GreaterThan(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
        VB: NodaTime.ZonedDateTime.GreaterThan(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThan
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 408
      summary: "\nCompares two <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> values to see if the left one is strictly later than the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars or time zones.\nSee the top-level type documentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator>(ZonedDateTime lhs, ZonedDateTime rhs)
          VB: Public Shared Operator>(lhs As ZonedDateTime, rhs As ZonedDateTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.ZonedDateTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.ZonedDateTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is strictly later than <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.ZonedDateTime.op_GreaterThan*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.op_GreaterThanOrEqual(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      commentId: M:NodaTime.ZonedDateTime.op_GreaterThanOrEqual(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: GreaterThanOrEqual(ZonedDateTime, ZonedDateTime)
        VB: GreaterThanOrEqual(ZonedDateTime, ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTime.GreaterThanOrEqual(ZonedDateTime, ZonedDateTime)
        VB: ZonedDateTime.GreaterThanOrEqual(ZonedDateTime, ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.GreaterThanOrEqual(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
        VB: NodaTime.ZonedDateTime.GreaterThanOrEqual(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_GreaterThanOrEqual
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 424
      summary: "\nCompares two <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> values to see if the left one is later than or equal to the right\none.\n"
      remarks: "\nThis operator always returns false if the two operands have different calendars or time zones.\nSee the top-level type documentation for more information about comparisons.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool operator >=(ZonedDateTime lhs, ZonedDateTime rhs)
          VB: Public Shared Operator >=(lhs As ZonedDateTime, rhs As ZonedDateTime) As Boolean
        parameters:
        - id: lhs
          type: NodaTime.ZonedDateTime
          description: First operand of the comparison
        - id: rhs
          type: NodaTime.ZonedDateTime
          description: Second operand of the comparison
        return:
          type: System.Boolean
          description: true if the <span class="paramref">lhs</span> is later than or equal to <span class="paramref">rhs</span>, false otherwise.
      overload: NodaTime.ZonedDateTime.op_GreaterThanOrEqual*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)
      commentId: M:NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: CompareTo(ZonedDateTime)
        VB: CompareTo(ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTime.CompareTo(ZonedDateTime)
        VB: ZonedDateTime.CompareTo(ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)
        VB: NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CompareTo
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 439
      summary: "\nIndicates whether this date/time is earlier, later or the same as another one.\n"
      remarks: "\nThis is purely done in terms of the instant represented; the calendar system and time zone are ignored.\n"
      example: []
      syntax:
        content:
          CSharp: public int CompareTo(ZonedDateTime other)
          VB: Public Function CompareTo(other As ZonedDateTime) As Integer
        parameters:
        - id: other
          type: NodaTime.ZonedDateTime
          description: The other zoned date/time to compare this one with
        return:
          type: System.Int32
          description: >-
            A value less than zero if the instant represented by this zoned date/time is earlier than the one in

            <span class="paramref">other</span>; zero if the instant is the same as the one in <span class="paramref">other</span>;

            a value greater than zero if the instant is later than the one in <span class="paramref">other</span>.
      overload: NodaTime.ZonedDateTime.CompareTo*
      implements:
      - System.IComparable{NodaTime.ZonedDateTime}.CompareTo(NodaTime.ZonedDateTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - isEii: true
      id: NodaTime.ZonedDateTime.System#IComparable#CompareTo(System.Object)
      commentId: M:NodaTime.ZonedDateTime.System#IComparable#CompareTo(System.Object)
      language: CSharp
      name:
        CSharp: IComparable.CompareTo(Object)
        VB: System.IComparable.CompareTo(Object)
      nameWithType:
        CSharp: ZonedDateTime.IComparable.CompareTo(Object)
        VB: ZonedDateTime.System.IComparable.CompareTo(Object)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.System.IComparable.CompareTo(System.Object)
        VB: NodaTime.ZonedDateTime.System.IComparable.CompareTo(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.IComparable.CompareTo
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 455
      summary: "\nImplementation of <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to compare two ZonedDateTimes.\n"
      remarks: "\nThis uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.\n"
      example: []
      syntax:
        content:
          CSharp: int IComparable.CompareTo(object obj)
          VB: Function System.IComparable.CompareTo(obj As Object) As Integer Implements IComparable.CompareTo
        parameters:
        - id: obj
          type: System.Object
          description: The object to compare this value with.
        return:
          type: System.Int32
          description: >
            The result of comparing this ZonedDateTime with another one; see <xref href="NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)" data-throw-if-not-resolved="false"></xref> for general details.

            If <span class="paramref">obj</span> is null, this method returns a value greater than 0.
      overload: NodaTime.ZonedDateTime.System#IComparable#CompareTo*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">obj</span> is non-null but does not refer to an instance of <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref>.
      implements:
      - System.IComparable.CompareTo(System.Object)
      modifiers:
        CSharp: []
        VB: []
      references:
        System.IComparable.CompareTo(System.Object): 
        NodaTime.ZonedDateTime: 
        NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime): 
    - id: NodaTime.ZonedDateTime.op_Addition(NodaTime.ZonedDateTime,NodaTime.Duration)
      commentId: M:NodaTime.ZonedDateTime.op_Addition(NodaTime.ZonedDateTime,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Addition(ZonedDateTime, Duration)
        VB: Addition(ZonedDateTime, Duration)
      nameWithType:
        CSharp: ZonedDateTime.Addition(ZonedDateTime, Duration)
        VB: ZonedDateTime.Addition(ZonedDateTime, Duration)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Addition(NodaTime.ZonedDateTime, NodaTime.Duration)
        VB: NodaTime.ZonedDateTime.Addition(NodaTime.ZonedDateTime, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Addition
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 475
      summary: "\nReturns a new <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> with the time advanced by the given duration. Note that\ndue to daylight saving time changes this may not advance the local time by the same amount.\n"
      remarks: "\nThe returned value retains the calendar system and time zone of the <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTime operator +(ZonedDateTime zonedDateTime, Duration duration)
          VB: Public Shared Operator +(zonedDateTime As ZonedDateTime, duration As Duration) As ZonedDateTime
        parameters:
        - id: zonedDateTime
          type: NodaTime.ZonedDateTime
          description: The <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> to add the duration to.
        - id: duration
          type: NodaTime.Duration
          description: The duration to add.
        return:
          type: NodaTime.ZonedDateTime
          description: A new value with the time advanced by the given duration, in the same calendar system and time zone.
      overload: NodaTime.ZonedDateTime.op_Addition*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.Add(NodaTime.ZonedDateTime,NodaTime.Duration)
      commentId: M:NodaTime.ZonedDateTime.Add(NodaTime.ZonedDateTime,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Add(ZonedDateTime, Duration)
        VB: Add(ZonedDateTime, Duration)
      nameWithType:
        CSharp: ZonedDateTime.Add(ZonedDateTime, Duration)
        VB: ZonedDateTime.Add(ZonedDateTime, Duration)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Add(NodaTime.ZonedDateTime, NodaTime.Duration)
        VB: NodaTime.ZonedDateTime.Add(NodaTime.ZonedDateTime, NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Add
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 486
      summary: "\nAdds a duration to a zoned date and time. Friendly alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTime Add(ZonedDateTime zonedDateTime, Duration duration)
          VB: Public Shared Function Add(zonedDateTime As ZonedDateTime, duration As Duration) As ZonedDateTime
        parameters:
        - id: zonedDateTime
          type: NodaTime.ZonedDateTime
          description: The value to add the duration to.
        - id: duration
          type: NodaTime.Duration
          description: The duration to add
        return:
          type: NodaTime.ZonedDateTime
          description: A new value with the time advanced by the given duration, in the same calendar system and time zone.
      overload: NodaTime.ZonedDateTime.Add*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.ZonedDateTime.Plus(NodaTime.Duration)
      commentId: M:NodaTime.ZonedDateTime.Plus(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Plus(Duration)
        VB: Plus(Duration)
      nameWithType:
        CSharp: ZonedDateTime.Plus(Duration)
        VB: ZonedDateTime.Plus(Duration)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Plus(NodaTime.Duration)
        VB: NodaTime.ZonedDateTime.Plus(NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Plus
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 496
      summary: "\nReturns the result of adding a duration to this zoned date and time, for a fluent alternative to <code>operator+()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime Plus(Duration duration)
          VB: Public Function Plus(duration As Duration) As ZonedDateTime
        parameters:
        - id: duration
          type: NodaTime.Duration
          description: The duration to add
        return:
          type: NodaTime.ZonedDateTime
          description: A new <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> representing the result of the addition.
      overload: NodaTime.ZonedDateTime.Plus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.Subtract(NodaTime.ZonedDateTime,NodaTime.Duration)
      commentId: M:NodaTime.ZonedDateTime.Subtract(NodaTime.ZonedDateTime,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Subtract(ZonedDateTime, Duration)
        VB: Subtract(ZonedDateTime, Duration)
      nameWithType:
        CSharp: ZonedDateTime.Subtract(ZonedDateTime, Duration)
        VB: ZonedDateTime.Subtract(ZonedDateTime, Duration)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Subtract(NodaTime.ZonedDateTime, NodaTime.Duration)
        VB: NodaTime.ZonedDateTime.Subtract(NodaTime.ZonedDateTime, NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Subtract
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 508
      summary: "\nSubtracts a duration from a zoned date and time. Friendly alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTime Subtract(ZonedDateTime zonedDateTime, Duration duration)
          VB: Public Shared Function Subtract(zonedDateTime As ZonedDateTime, duration As Duration) As ZonedDateTime
        parameters:
        - id: zonedDateTime
          type: NodaTime.ZonedDateTime
          description: The value to subtract the duration from.
        - id: duration
          type: NodaTime.Duration
          description: The duration to subtract.
        return:
          type: NodaTime.ZonedDateTime
          description: A new value with the time "rewound" by the given duration, in the same calendar system and time zone.
      overload: NodaTime.ZonedDateTime.Subtract*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.ZonedDateTime.Minus(NodaTime.Duration)
      commentId: M:NodaTime.ZonedDateTime.Minus(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Minus(Duration)
        VB: Minus(Duration)
      nameWithType:
        CSharp: ZonedDateTime.Minus(Duration)
        VB: ZonedDateTime.Minus(Duration)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Minus(NodaTime.Duration)
        VB: NodaTime.ZonedDateTime.Minus(NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Minus
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 518
      summary: "\nReturns the result of subtracting a duration from this zoned date and time, for a fluent alternative to <code>operator-()</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime Minus(Duration duration)
          VB: Public Function Minus(duration As Duration) As ZonedDateTime
        parameters:
        - id: duration
          type: NodaTime.Duration
          description: The duration to subtract
        return:
          type: NodaTime.ZonedDateTime
          description: A new <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> representing the result of the subtraction.
      overload: NodaTime.ZonedDateTime.Minus*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.Duration)
      commentId: M:NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Subtraction(ZonedDateTime, Duration)
        VB: Subtraction(ZonedDateTime, Duration)
      nameWithType:
        CSharp: ZonedDateTime.Subtraction(ZonedDateTime, Duration)
        VB: ZonedDateTime.Subtraction(ZonedDateTime, Duration)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Subtraction(NodaTime.ZonedDateTime, NodaTime.Duration)
        VB: NodaTime.ZonedDateTime.Subtraction(NodaTime.ZonedDateTime, NodaTime.Duration)
      type: Operator
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: op_Subtraction
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 533
      summary: "\nReturns a new ZonedDateTime with the duration subtracted. Note that\ndue to daylight saving time changes this may not change the local time by the same amount.\n"
      remarks: "\nThe returned value retains the calendar system and time zone of the <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTime operator -(ZonedDateTime zonedDateTime, Duration duration)
          VB: Public Shared Operator -(zonedDateTime As ZonedDateTime, duration As Duration) As ZonedDateTime
        parameters:
        - id: zonedDateTime
          type: NodaTime.ZonedDateTime
          description: The value to subtract the duration from.
        - id: duration
          type: NodaTime.Duration
          description: The duration to subtract.
        return:
          type: NodaTime.ZonedDateTime
          description: A new value with the time "rewound" by the given duration, in the same calendar system and time zone.
      overload: NodaTime.ZonedDateTime.op_Subtraction*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.GetZoneInterval
      commentId: M:NodaTime.ZonedDateTime.GetZoneInterval
      language: CSharp
      name:
        CSharp: GetZoneInterval()
        VB: GetZoneInterval()
      nameWithType:
        CSharp: ZonedDateTime.GetZoneInterval()
        VB: ZonedDateTime.GetZoneInterval()
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.GetZoneInterval()
        VB: NodaTime.ZonedDateTime.GetZoneInterval()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetZoneInterval
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 549
      summary: "\nReturns the <xref href=\"NodaTime.TimeZones.ZoneInterval\" data-throw-if-not-resolved=\"false\"></xref> containing this value, in the time zone this\nvalue refers to.\n"
      remarks: "\nThis is simply a convenience method - it is logically equivalent to converting this\nvalue to an <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> and then asking the appropriate <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref>\nfor the <code>ZoneInterval</code> containing that instant.\n"
      example: []
      syntax:
        content:
          CSharp: public ZoneInterval GetZoneInterval()
          VB: Public Function GetZoneInterval As ZoneInterval
        return:
          type: NodaTime.TimeZones.ZoneInterval
          description: The <code>ZoneInterval</code> containing this value.
      overload: NodaTime.ZonedDateTime.GetZoneInterval*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.TimeZones.ZoneInterval: 
        NodaTime.Instant: 
        NodaTime.DateTimeZone: 
    - id: NodaTime.ZonedDateTime.ToString
      commentId: M:NodaTime.ZonedDateTime.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: ZonedDateTime.ToString()
        VB: ZonedDateTime.ToString()
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ToString()
        VB: NodaTime.ZonedDateTime.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 561
      summary: "\nReturns a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      overload: NodaTime.ZonedDateTime.ToString*
      overridden: System.ValueType.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.String: 
    - id: NodaTime.ZonedDateTime.ToString(System.String,System.IFormatProvider)
      commentId: M:NodaTime.ZonedDateTime.ToString(System.String,System.IFormatProvider)
      language: CSharp
      name:
        CSharp: ToString(String, IFormatProvider)
        VB: ToString(String, IFormatProvider)
      nameWithType:
        CSharp: ZonedDateTime.ToString(String, IFormatProvider)
        VB: ZonedDateTime.ToString(String, IFormatProvider)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ToString(System.String, System.IFormatProvider)
        VB: NodaTime.ZonedDateTime.ToString(System.String, System.IFormatProvider)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 581
      summary: "\nFormats the value of the current instance using the specified format.\n"
      example: []
      syntax:
        content:
          CSharp: public string ToString(string patternText, IFormatProvider formatProvider)
          VB: Public Function ToString(patternText As String, formatProvider As IFormatProvider) As String
        parameters:
        - id: patternText
          type: System.String
          description: "The <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> specifying the pattern to use.\n  -or- \n  null to use the default pattern defined for the type of the <xref href=\"System.IFormattable\" data-throw-if-not-resolved=\"false\"></xref> implementation. \n"
        - id: formatProvider
          type: System.IFormatProvider
          description: "The <xref href=\"System.IFormatProvider\" data-throw-if-not-resolved=\"false\"></xref> to use to format the value.\n  -or- \n  null to obtain the numeric format information from the current locale setting of the operating system. \n"
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> containing the value of the current instance in the specified format.\n"
      overload: NodaTime.ZonedDateTime.ToString*
      implements:
      - System.IFormattable.ToString(System.String,System.IFormatProvider)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.String: 
        System.IFormattable: 
        System.IFormatProvider: 
    - id: NodaTime.ZonedDateTime.ToDateTimeOffset
      commentId: M:NodaTime.ZonedDateTime.ToDateTimeOffset
      language: CSharp
      name:
        CSharp: ToDateTimeOffset()
        VB: ToDateTimeOffset()
      nameWithType:
        CSharp: ZonedDateTime.ToDateTimeOffset()
        VB: ZonedDateTime.ToDateTimeOffset()
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ToDateTimeOffset()
        VB: NodaTime.ZonedDateTime.ToDateTimeOffset()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToDateTimeOffset
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 597
      summary: "\nConstructs a <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> value with the same local time and offset from\nUTC as this value.\n"
      remarks: "\nAn offset does not convey as much information as a time zone; a <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref>\nrepresents an instant in time along with an associated local time, but it doesn't allow you\nto find out what the local time would be for another instant.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTimeOffset ToDateTimeOffset()
          VB: Public Function ToDateTimeOffset As DateTimeOffset
        return:
          type: System.DateTimeOffset
          description: A <xref href="System.DateTimeOffset" data-throw-if-not-resolved="false"></xref> representation of this value.
      overload: NodaTime.ZonedDateTime.ToDateTimeOffset*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.DateTimeOffset: 
    - id: NodaTime.ZonedDateTime.FromDateTimeOffset(System.DateTimeOffset)
      commentId: M:NodaTime.ZonedDateTime.FromDateTimeOffset(System.DateTimeOffset)
      language: CSharp
      name:
        CSharp: FromDateTimeOffset(DateTimeOffset)
        VB: FromDateTimeOffset(DateTimeOffset)
      nameWithType:
        CSharp: ZonedDateTime.FromDateTimeOffset(DateTimeOffset)
        VB: ZonedDateTime.FromDateTimeOffset(DateTimeOffset)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.FromDateTimeOffset(System.DateTimeOffset)
        VB: NodaTime.ZonedDateTime.FromDateTimeOffset(System.DateTimeOffset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromDateTimeOffset
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 609
      summary: "\nReturns a new <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> representing the same instant in time as the given\n<xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref>.\nThe time zone used will be a fixed time zone, which uses the same offset throughout time.\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTime FromDateTimeOffset(DateTimeOffset dateTimeOffset)
          VB: Public Shared Function FromDateTimeOffset(dateTimeOffset As DateTimeOffset) As ZonedDateTime
        parameters:
        - id: dateTimeOffset
          type: System.DateTimeOffset
          description: Date and time value with an offset.
        return:
          type: NodaTime.ZonedDateTime
          description: A <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> value representing the same instant in time as the given <xref href="System.DateTimeOffset" data-throw-if-not-resolved="false"></xref>.
      overload: NodaTime.ZonedDateTime.FromDateTimeOffset*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.ZonedDateTime: 
        System.DateTimeOffset: 
    - id: NodaTime.ZonedDateTime.ToDateTimeUtc
      commentId: M:NodaTime.ZonedDateTime.ToDateTimeUtc
      language: CSharp
      name:
        CSharp: ToDateTimeUtc()
        VB: ToDateTimeUtc()
      nameWithType:
        CSharp: ZonedDateTime.ToDateTimeUtc()
        VB: ZonedDateTime.ToDateTimeUtc()
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ToDateTimeUtc()
        VB: NodaTime.ZonedDateTime.ToDateTimeUtc()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToDateTimeUtc
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 622
      summary: "\nConstructs a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> from this <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> which has a\n<xref href=\"System.DateTime.Kind\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTimeKind.Utc\" data-throw-if-not-resolved=\"false\"></xref> and represents the same instant of time as\nthis value rather than the same local time.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTime ToDateTimeUtc()
          VB: Public Function ToDateTimeUtc As Date
        return:
          type: System.DateTime
          description: >-
            A <xref href="System.DateTime" data-throw-if-not-resolved="false"></xref> representation of this value with a "universal" kind, with the same

            instant of time as this value.
      overload: NodaTime.ZonedDateTime.ToDateTimeUtc*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.DateTime: 
        NodaTime.ZonedDateTime: 
        System.DateTime.Kind: 
        System.DateTimeKind.Utc: 
    - id: NodaTime.ZonedDateTime.ToDateTimeUnspecified
      commentId: M:NodaTime.ZonedDateTime.ToDateTimeUnspecified
      language: CSharp
      name:
        CSharp: ToDateTimeUnspecified()
        VB: ToDateTimeUnspecified()
      nameWithType:
        CSharp: ZonedDateTime.ToDateTimeUnspecified()
        VB: ZonedDateTime.ToDateTimeUnspecified()
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ToDateTimeUnspecified()
        VB: NodaTime.ZonedDateTime.ToDateTimeUnspecified()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToDateTimeUnspecified
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 639
      summary: "\nConstructs a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> from this <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> which has a\n<xref href=\"System.DateTime.Kind\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTimeKind.Unspecified\" data-throw-if-not-resolved=\"false\"></xref> and represents the same local time as\nthis value rather than the same instant in time.\n"
      remarks: "\n<xref href=\"System.DateTimeKind.Unspecified\" data-throw-if-not-resolved=\"false\"></xref> is slightly odd - it can be treated as UTC if you use <xref href=\"System.DateTime.ToLocalTime\" data-throw-if-not-resolved=\"false\"></xref>\nor as system local time if you use <xref href=\"System.DateTime.ToUniversalTime\" data-throw-if-not-resolved=\"false\"></xref>, but it's the only kind which allows\nyou to construct a <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> with an arbitrary offset.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTime ToDateTimeUnspecified()
          VB: Public Function ToDateTimeUnspecified As Date
        return:
          type: System.DateTime
          description: >-
            A <xref href="System.DateTime" data-throw-if-not-resolved="false"></xref> representation of this value with an "unspecified" kind, with the same

            local date and time as this value.
      overload: NodaTime.ZonedDateTime.ToDateTimeUnspecified*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.DateTime: 
        NodaTime.ZonedDateTime: 
        System.DateTime.Kind: 
        System.DateTimeKind.Unspecified: 
        System.DateTime.ToLocalTime: 
        System.DateTime.ToUniversalTime: 
        System.DateTimeOffset: 
    - id: NodaTime.ZonedDateTime.ToOffsetDateTime
      commentId: M:NodaTime.ZonedDateTime.ToOffsetDateTime
      language: CSharp
      name:
        CSharp: ToOffsetDateTime()
        VB: ToOffsetDateTime()
      nameWithType:
        CSharp: ZonedDateTime.ToOffsetDateTime()
        VB: ZonedDateTime.ToOffsetDateTime()
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.ToOffsetDateTime()
        VB: NodaTime.ZonedDateTime.ToOffsetDateTime()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToOffsetDateTime
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 649
      summary: "\nConstructs an <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> with the same local date and time, and the same offset\nas this zoned date and time, effectively just \"removing\" the time zone itself.\n"
      example: []
      syntax:
        content:
          CSharp: public OffsetDateTime ToOffsetDateTime()
          VB: Public Function ToOffsetDateTime As OffsetDateTime
        return:
          type: NodaTime.OffsetDateTime
          description: An OffsetDateTime with the same local date/time and offset as this value.
      overload: NodaTime.ZonedDateTime.ToOffsetDateTime*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.OffsetDateTime: 
    - isEii: true
      id: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema
      commentId: M:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema
      language: CSharp
      name:
        CSharp: IXmlSerializable.GetSchema()
        VB: System.Xml.Serialization.IXmlSerializable.GetSchema()
      nameWithType:
        CSharp: ZonedDateTime.IXmlSerializable.GetSchema()
        VB: ZonedDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
        VB: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.GetSchema
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 766
      example: []
      syntax:
        content:
          CSharp: XmlSchema IXmlSerializable.GetSchema()
          VB: Function System.Xml.Serialization.IXmlSerializable.GetSchema As XmlSchema Implements IXmlSerializable.GetSchema
        return:
          type: System.Xml.Schema.XmlSchema
      overload: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
      implements:
      - System.Xml.Serialization.IXmlSerializable.GetSchema
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      commentId: M:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
      language: CSharp
      name:
        CSharp: IXmlSerializable.ReadXml(XmlReader)
        VB: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      nameWithType:
        CSharp: ZonedDateTime.IXmlSerializable.ReadXml(XmlReader)
        VB: ZonedDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        VB: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.ReadXml
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 772
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.ReadXml(XmlReader reader)
          VB: Sub System.Xml.Serialization.IXmlSerializable.ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
        parameters:
        - id: reader
          type: System.Xml.XmlReader
      overload: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      commentId: M:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
      language: CSharp
      name:
        CSharp: IXmlSerializable.WriteXml(XmlWriter)
        VB: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      nameWithType:
        CSharp: ZonedDateTime.IXmlSerializable.WriteXml(XmlWriter)
        VB: ZonedDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        VB: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Xml.Serialization.IXmlSerializable.WriteXml
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 801
      example: []
      syntax:
        content:
          CSharp: void IXmlSerializable.WriteXml(XmlWriter writer)
          VB: Sub System.Xml.Serialization.IXmlSerializable.WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
        parameters:
        - id: writer
          type: System.Xml.XmlWriter
      overload: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
      implements:
      - System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
      modifiers:
        CSharp: []
        VB: []
    - isEii: true
      id: NodaTime.ZonedDateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:NodaTime.ZonedDateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: ZonedDateTime.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
        VB: ZonedDateTime.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: NodaTime.ZonedDateTime.System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: System.Runtime.Serialization.ISerializable.GetObjectData
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 839
      summary: "\nImplementation of <xref href=\"System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo%2cSystem.Runtime.Serialization.StreamingContext)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
          VB: Sub System.Runtime.Serialization.ISerializable.GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: The <xref href="System.Runtime.Serialization.SerializationInfo" data-throw-if-not-resolved="false"></xref> to populate with data.
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: The destination for this serialization.
      overload: NodaTime.ZonedDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*
      implements:
      - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      modifiers:
        CSharp: []
        VB: []
      references:
        ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        : 
        System.Runtime.Serialization.SerializationInfo: 
    references:
      NodaTime.LocalDateTime: 
      NodaTime.ZonedDateTime: 
      NodaTime.Instant: 
      NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime): 
      NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime): 
      NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime): 
      System.IComparable`1: 
  - id: NodaTime.ZonedDateTime.Comparer
    commentId: T:NodaTime.ZonedDateTime.Comparer
    language: CSharp
    name:
      CSharp: ZonedDateTime.Comparer
      VB: ZonedDateTime.Comparer
    nameWithType:
      CSharp: ZonedDateTime.Comparer
      VB: ZonedDateTime.Comparer
    qualifiedName:
      CSharp: NodaTime.ZonedDateTime.Comparer
      VB: NodaTime.ZonedDateTime.Comparer
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime
    source:
      remote:
        path: 1.2.x/src/NodaTime/ZonedDateTime.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: Comparer
      path: src/NodaTime/ZonedDateTime.cs
      startLine: 664
    summary: "\nBase class for <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> comparers.\n"
    remarks: "\n<p>Use the static properties of this class to obtain instances.</p>\n<p>For the curious: this class only exists so that in the future, it can expose more functionality - probably\nimplementing <xref href=\"System.Collections.Generic.IEqualityComparer%601\" data-throw-if-not-resolved=\"false\"></xref>. If we simply provided properties on ZonedDateTime of type\n<xref href=\"System.Collections.Generic.IComparer%601\" data-throw-if-not-resolved=\"false\"></xref> we'd have no backward-compatible way of adding to the set of implemented interfaces.</p>\n"
    example: []
    syntax:
      content:
        CSharp: 'public abstract class Comparer : IComparer<ZonedDateTime>'
        VB: >-
          Public MustInherit Class Comparer

              Implements IComparer(Of ZonedDateTime)
    inheritance:
    - System.Object
    implements:
    - System.Collections.Generic.IComparer{NodaTime.ZonedDateTime}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - abstract
      - class
      VB:
      - Public
      - MustInherit
      - Class
    items:
    - id: NodaTime.ZonedDateTime.Comparer.Local
      commentId: P:NodaTime.ZonedDateTime.Comparer.Local
      language: CSharp
      name:
        CSharp: Local
        VB: Local
      nameWithType:
        CSharp: ZonedDateTime.Comparer.Local
        VB: ZonedDateTime.Comparer.Local
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Comparer.Local
        VB: NodaTime.ZonedDateTime.Comparer.Local
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Local
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 675
      summary: "\nReturns a comparer which compares <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> values by their local date/time, without reference to\nthe time zone, offset or the calendar system.\n"
      remarks: "\n<p>For example, this comparer considers 2013-03-04T20:21:00 (Europe/London) to be later than\n2013-03-04T19:21:00 (America/Los_Angeles) even though the second value represents a later instant in time.</p>\n<p>This property will return a reference to the same instance every time it is called.</p>\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTime.Comparer Local { get; }
          VB: Public Shared ReadOnly Property Local As ZonedDateTime.Comparer
        parameters: []
        return:
          type: NodaTime.ZonedDateTime.Comparer
      overload: NodaTime.ZonedDateTime.Comparer.Local*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.ZonedDateTime: 
    - id: NodaTime.ZonedDateTime.Comparer.Instant
      commentId: P:NodaTime.ZonedDateTime.Comparer.Instant
      language: CSharp
      name:
        CSharp: Instant
        VB: Instant
      nameWithType:
        CSharp: ZonedDateTime.Comparer.Instant
        VB: ZonedDateTime.Comparer.Instant
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Comparer.Instant
        VB: NodaTime.ZonedDateTime.Comparer.Instant
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Instant
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 688
      summary: "\nReturns a comparer which compares <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> values by the instants obtained by applying the offset to\nthe local date/time, ignoring the calendar system.\n"
      remarks: "\n<p>For example, this comparer considers 2013-03-04T20:21:00 (Europe/London) to be earlier than\n2013-03-04T19:21:00 (America/Los_Angeles) even though the second value has a local time which is earlier; the time zones\nmean that the first value occurred earlier in the universal time line.</p>\n<p>This comparer behaves the same way as the <xref href=\"NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)\" data-throw-if-not-resolved=\"false\"></xref> method; it is provided for symmetry with <xref href=\"NodaTime.ZonedDateTime.Comparer.Local\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This property will return a reference to the same instance every time it is called.</p>\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTime.Comparer Instant { get; }
          VB: Public Shared ReadOnly Property Instant As ZonedDateTime.Comparer
        parameters: []
        return:
          type: NodaTime.ZonedDateTime.Comparer
      overload: NodaTime.ZonedDateTime.Comparer.Instant*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.ZonedDateTime: 
        NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime): 
        NodaTime.ZonedDateTime.Comparer.Local: 
    - id: NodaTime.ZonedDateTime.Comparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      commentId: M:NodaTime.ZonedDateTime.Comparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: Compare(ZonedDateTime, ZonedDateTime)
        VB: Compare(ZonedDateTime, ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTime.Comparer.Compare(ZonedDateTime, ZonedDateTime)
        VB: ZonedDateTime.Comparer.Compare(ZonedDateTime, ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.ZonedDateTime.Comparer.Compare(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
        VB: NodaTime.ZonedDateTime.Comparer.Compare(NodaTime.ZonedDateTime, NodaTime.ZonedDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime
      source:
        remote:
          path: 1.2.x/src/NodaTime/ZonedDateTime.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Compare
        path: src/NodaTime/ZonedDateTime.cs
        startLine: 724
      summary: "\nCompares two <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> values and returns a value indicating whether one is less than, equal to, or greater than the other.\n"
      example: []
      syntax:
        content:
          CSharp: public abstract int Compare(ZonedDateTime x, ZonedDateTime y)
          VB: Public MustOverride Function Compare(x As ZonedDateTime, y As ZonedDateTime) As Integer
        parameters:
        - id: x
          type: NodaTime.ZonedDateTime
          description: The first value to compare.
        - id: y
          type: NodaTime.ZonedDateTime
          description: The second value to compare.
        return:
          type: System.Int32
          description: >
            A signed integer that indicates the relative values of <span class="paramref">x</span> and <span class="paramref">y</span>, as shown in the following table.

            <table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>Less than zero</td><td><span class="paramref">x</span> is less than <span class="paramref">y</span>.</td></tr><tr><td>Zero</td><td><span class="paramref">x</span> is equals to <span class="paramref">y</span>.</td></tr><tr><td>Greater than zero</td><td><span class="paramref">x</span> is greater than <span class="paramref">y</span>.</td></tr></tbody></table>
      overload: NodaTime.ZonedDateTime.Comparer.Compare*
      implements:
      - System.Collections.Generic.IComparer{NodaTime.ZonedDateTime}.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
      modifiers:
        CSharp:
        - public
        - abstract
        VB:
        - Public
        - MustOverride
      references:
        NodaTime.ZonedDateTime: 
    references:
      NodaTime.ZonedDateTime: 
      System.Collections.Generic.IEqualityComparer`1: 
      System.Collections.Generic.IComparer`1: 
- id: NodaTime.Calendars
  commentId: N:NodaTime.Calendars
  language: CSharp
  name:
    CSharp: NodaTime.Calendars
    VB: NodaTime.Calendars
  nameWithType:
    CSharp: NodaTime.Calendars
    VB: NodaTime.Calendars
  qualifiedName:
    CSharp: NodaTime.Calendars
    VB: NodaTime.Calendars
  type: Namespace
  assemblies:
  - NodaTime
  modifiers: {}
  items:
  - id: NodaTime.Calendars.Era
    commentId: T:NodaTime.Calendars.Era
    language: CSharp
    name:
      CSharp: Era
      VB: Era
    nameWithType:
      CSharp: Era
      VB: Era
    qualifiedName:
      CSharp: NodaTime.Calendars.Era
      VB: NodaTime.Calendars.Era
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Calendars
    source:
      remote:
        path: 1.2.x/src/NodaTime/Calendars/Era.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: Era
      path: src/NodaTime/Calendars/Era.cs
      startLine: 15
    summary: "\nRepresents an era used in a calendar.\n"
    remarks: >-
      All the built-in calendars in Noda Time use the values specified by the static

      read-only fields in this class. These may be compared for reference equality to check for specific

      eras.
    example: []
    syntax:
      content:
        CSharp: public sealed class Era
        VB: Public NotInheritable Class Era
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Calendars.Era.Common
      commentId: F:NodaTime.Calendars.Era.Common
      language: CSharp
      name:
        CSharp: Common
        VB: Common
      nameWithType:
        CSharp: Era.Common
        VB: Era.Common
      qualifiedName:
        CSharp: NodaTime.Calendars.Era.Common
        VB: NodaTime.Calendars.Era.Common
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/Era.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Common
        path: src/NodaTime/Calendars/Era.cs
        startLine: 20
      summary: "\nThe \"Common\" era (CE), also known as Anno Domini (AD). This is used in the ISO, Gregorian and Julian calendars.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Era Common
          VB: Public Shared ReadOnly Common As Era
        return:
          type: NodaTime.Calendars.Era
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Calendars.Era.BeforeCommon
      commentId: F:NodaTime.Calendars.Era.BeforeCommon
      language: CSharp
      name:
        CSharp: BeforeCommon
        VB: BeforeCommon
      nameWithType:
        CSharp: Era.BeforeCommon
        VB: Era.BeforeCommon
      qualifiedName:
        CSharp: NodaTime.Calendars.Era.BeforeCommon
        VB: NodaTime.Calendars.Era.BeforeCommon
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/Era.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: BeforeCommon
        path: src/NodaTime/Calendars/Era.cs
        startLine: 25
      summary: "\nThe \"before common\" era (BCE), also known as Before Christ (BC). This is used in the ISO, Gregorian and Julian calendars.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Era BeforeCommon
          VB: Public Shared ReadOnly BeforeCommon As Era
        return:
          type: NodaTime.Calendars.Era
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Calendars.Era.AnnoMartyrum
      commentId: F:NodaTime.Calendars.Era.AnnoMartyrum
      language: CSharp
      name:
        CSharp: AnnoMartyrum
        VB: AnnoMartyrum
      nameWithType:
        CSharp: Era.AnnoMartyrum
        VB: Era.AnnoMartyrum
      qualifiedName:
        CSharp: NodaTime.Calendars.Era.AnnoMartyrum
        VB: NodaTime.Calendars.Era.AnnoMartyrum
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/Era.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: AnnoMartyrum
        path: src/NodaTime/Calendars/Era.cs
        startLine: 30
      summary: "\nThe \"Anno Martyrum\" or \"Era of the Martyrs\". This is the sole era used in the Coptic calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Era AnnoMartyrum
          VB: Public Shared ReadOnly AnnoMartyrum As Era
        return:
          type: NodaTime.Calendars.Era
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Calendars.Era.AnnoMartyrm
      commentId: F:NodaTime.Calendars.Era.AnnoMartyrm
      language: CSharp
      name:
        CSharp: AnnoMartyrm
        VB: AnnoMartyrm
      nameWithType:
        CSharp: Era.AnnoMartyrm
        VB: Era.AnnoMartyrm
      qualifiedName:
        CSharp: NodaTime.Calendars.Era.AnnoMartyrm
        VB: NodaTime.Calendars.Era.AnnoMartyrm
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/Era.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: AnnoMartyrm
        path: src/NodaTime/Calendars/Era.cs
        startLine: 36
      summary: "\nThe \"Anno Martyrum\" or \"Era of the Martyrs\". This is the sole era used in the Coptic calendar.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("Use AnnoMartyrum instead. This field's name was a typo, and it will be removed in a future release.")]

            public static readonly Era AnnoMartyrm
          VB: >-
            <Obsolete("Use AnnoMartyrum instead. This field's name was a typo, and it will be removed in a future release.")>

            Public Shared ReadOnly AnnoMartyrm As Era
        return:
          type: NodaTime.Calendars.Era
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: Use AnnoMartyrum instead. This field's name was a typo, and it will be removed in a future release.
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Calendars.Era.AnnoHegirae
      commentId: F:NodaTime.Calendars.Era.AnnoHegirae
      language: CSharp
      name:
        CSharp: AnnoHegirae
        VB: AnnoHegirae
      nameWithType:
        CSharp: Era.AnnoHegirae
        VB: Era.AnnoHegirae
      qualifiedName:
        CSharp: NodaTime.Calendars.Era.AnnoHegirae
        VB: NodaTime.Calendars.Era.AnnoHegirae
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/Era.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: AnnoHegirae
        path: src/NodaTime/Calendars/Era.cs
        startLine: 41
      summary: "\nThe \"Anno Hegira\" era. This is the sole era used in the Hijri (Islamic) calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly Era AnnoHegirae
          VB: Public Shared ReadOnly AnnoHegirae As Era
        return:
          type: NodaTime.Calendars.Era
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Calendars.Era.Name
      commentId: P:NodaTime.Calendars.Era.Name
      language: CSharp
      name:
        CSharp: Name
        VB: Name
      nameWithType:
        CSharp: Era.Name
        VB: Era.Name
      qualifiedName:
        CSharp: NodaTime.Calendars.Era.Name
        VB: NodaTime.Calendars.Era.Name
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/Era.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Name
        path: src/NodaTime/Calendars/Era.cs
        startLine: 57
      summary: "\nReturns the name of this era, e.g. \"CE\" or \"BCE\".\n"
      example: []
      syntax:
        content:
          CSharp: public string Name { get; }
          VB: Public ReadOnly Property Name As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.Calendars.Era.Name*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Calendars.Era.ToString
      commentId: M:NodaTime.Calendars.Era.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: Era.ToString()
        VB: Era.ToString()
      qualifiedName:
        CSharp: NodaTime.Calendars.Era.ToString()
        VB: NodaTime.Calendars.Era.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/Era.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/Calendars/Era.cs
        startLine: 63
      summary: "\nReturns the name of this era.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: The name of this era.
      overload: NodaTime.Calendars.Era.ToString*
      overridden: System.Object.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
  - id: NodaTime.Calendars.IslamicEpoch
    commentId: T:NodaTime.Calendars.IslamicEpoch
    language: CSharp
    name:
      CSharp: IslamicEpoch
      VB: IslamicEpoch
    nameWithType:
      CSharp: IslamicEpoch
      VB: IslamicEpoch
    qualifiedName:
      CSharp: NodaTime.Calendars.IslamicEpoch
      VB: NodaTime.Calendars.IslamicEpoch
    type: Enum
    assemblies:
    - NodaTime
    namespace: NodaTime.Calendars
    source:
      remote:
        path: 1.2.x/src/NodaTime/Calendars/IslamicEpoch.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: IslamicEpoch
      path: src/NodaTime/Calendars/IslamicEpoch.cs
      startLine: 15
    summary: "\nThe epoch to use when constructing an Islamic calendar.\n"
    remarks: "\nThe Islamic, or Hijri, calendar can either be constructed\nstarting on July 15th 622CE (in the Julian calendar) or on the following day.\nThe former is the \"astronomical\" or \"Thursday\" epoch; the latter is the \"civil\" or \"Friday\" epoch.\n"
    example: []
    syntax:
      content:
        CSharp: public enum IslamicEpoch
        VB: Public Enum IslamicEpoch
    seealso:
    - linkId: NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)
      commentId: M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: NodaTime.Calendars.IslamicEpoch.Astronomical
      commentId: F:NodaTime.Calendars.IslamicEpoch.Astronomical
      language: CSharp
      name:
        CSharp: Astronomical
        VB: Astronomical
      nameWithType:
        CSharp: IslamicEpoch.Astronomical
        VB: IslamicEpoch.Astronomical
      qualifiedName:
        CSharp: NodaTime.Calendars.IslamicEpoch.Astronomical
        VB: NodaTime.Calendars.IslamicEpoch.Astronomical
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/IslamicEpoch.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Astronomical
        path: src/NodaTime/Calendars/IslamicEpoch.cs
        startLine: 20
      summary: "\nEpoch beginning on July 15th 622CE (Julian), which is July 18th 622 CE in the Gregorian calendar.\n"
      example: []
      syntax:
        content:
          CSharp: Astronomical = 1
          VB: Astronomical = 1
        return:
          type: NodaTime.Calendars.IslamicEpoch
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.Calendars.IslamicEpoch.Civil
      commentId: F:NodaTime.Calendars.IslamicEpoch.Civil
      language: CSharp
      name:
        CSharp: Civil
        VB: Civil
      nameWithType:
        CSharp: IslamicEpoch.Civil
        VB: IslamicEpoch.Civil
      qualifiedName:
        CSharp: NodaTime.Calendars.IslamicEpoch.Civil
        VB: NodaTime.Calendars.IslamicEpoch.Civil
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/IslamicEpoch.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Civil
        path: src/NodaTime/Calendars/IslamicEpoch.cs
        startLine: 24
      summary: "\nEpoch beginning on July 16th 622CE (Julian), which is July 19th 622 CE in the Gregorian calendar.\n"
      example: []
      syntax:
        content:
          CSharp: Civil = 2
          VB: Civil = 2
        return:
          type: NodaTime.Calendars.IslamicEpoch
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    references:
      NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch): 
  - id: NodaTime.Calendars.IslamicLeapYearPattern
    commentId: T:NodaTime.Calendars.IslamicLeapYearPattern
    language: CSharp
    name:
      CSharp: IslamicLeapYearPattern
      VB: IslamicLeapYearPattern
    nameWithType:
      CSharp: IslamicLeapYearPattern
      VB: IslamicLeapYearPattern
    qualifiedName:
      CSharp: NodaTime.Calendars.IslamicLeapYearPattern
      VB: NodaTime.Calendars.IslamicLeapYearPattern
    type: Enum
    assemblies:
    - NodaTime
    namespace: NodaTime.Calendars
    source:
      remote:
        path: 1.2.x/src/NodaTime/Calendars/IslamicLeapYearPattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: IslamicLeapYearPattern
      path: src/NodaTime/Calendars/IslamicLeapYearPattern.cs
      startLine: 24
    summary: "\nThe pattern of leap years to use when constructing an Islamic calendar.\n"
    remarks: "\n<p>\nThe Islamic, or Hijri, calendar is a lunar calendar of 12 months, each of 29 or 30 days.\nThe calendar can be defined in either observational or tabular terms; \nNoda Time implements a tabular calendar, where a pattern of leap years (in which the last month has\nan extra day) repeats every 30 years, according to one of the patterns within this enum.\n</p>\n<p>\nWhile the patterns themselves are reasonably commonly documented (see e.g.\n<a href=\"http://en.wikipedia.org/wiki/Tabular_Islamic_calendar\">Wikipedia</a>)\nthere is little standardization in terms of naming the patterns. I hope the current names do not\ncause offence to anyone; suggestions for better names would be welcome.\n</p>\n<xref href=\"NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern%2cNodaTime.Calendars.IslamicEpoch)\" data-throw-if-not-resolved=\"false\"></xref>\n"
    example: []
    syntax:
      content:
        CSharp: public enum IslamicLeapYearPattern
        VB: Public Enum IslamicLeapYearPattern
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: NodaTime.Calendars.IslamicLeapYearPattern.Base15
      commentId: F:NodaTime.Calendars.IslamicLeapYearPattern.Base15
      language: CSharp
      name:
        CSharp: Base15
        VB: Base15
      nameWithType:
        CSharp: IslamicLeapYearPattern.Base15
        VB: IslamicLeapYearPattern.Base15
      qualifiedName:
        CSharp: NodaTime.Calendars.IslamicLeapYearPattern.Base15
        VB: NodaTime.Calendars.IslamicLeapYearPattern.Base15
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/IslamicLeapYearPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Base15
        path: src/NodaTime/Calendars/IslamicLeapYearPattern.cs
        startLine: 31
      summary: "\nA pattern of leap years in 2, 5, 7, 10, 13, 15, 18, 21, 24, 26 and 29.\nThis pattern and <xref href=\"NodaTime.Calendars.IslamicLeapYearPattern.Base16\" data-throw-if-not-resolved=\"false\"></xref> are the most commonly used ones,\nand only differ in whether the 15th or 16th year is deemed leap.\n"
      example: []
      syntax:
        content:
          CSharp: Base15 = 1
          VB: Base15 = 1
        return:
          type: NodaTime.Calendars.IslamicLeapYearPattern
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Calendars.IslamicLeapYearPattern.Base16: 
    - id: NodaTime.Calendars.IslamicLeapYearPattern.Base16
      commentId: F:NodaTime.Calendars.IslamicLeapYearPattern.Base16
      language: CSharp
      name:
        CSharp: Base16
        VB: Base16
      nameWithType:
        CSharp: IslamicLeapYearPattern.Base16
        VB: IslamicLeapYearPattern.Base16
      qualifiedName:
        CSharp: NodaTime.Calendars.IslamicLeapYearPattern.Base16
        VB: NodaTime.Calendars.IslamicLeapYearPattern.Base16
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/IslamicLeapYearPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Base16
        path: src/NodaTime/Calendars/IslamicLeapYearPattern.cs
        startLine: 37
      summary: "\nA pattern of leap years in 2, 5, 7, 10, 13, 16, 18, 21, 24, 26 and 29.\nThis pattern and <xref href=\"NodaTime.Calendars.IslamicLeapYearPattern.Base15\" data-throw-if-not-resolved=\"false\"></xref> are the most commonly used ones,\nand only differ in whether the 15th or 16th year is deemed leap.\n"
      example: []
      syntax:
        content:
          CSharp: Base16 = 2
          VB: Base16 = 2
        return:
          type: NodaTime.Calendars.IslamicLeapYearPattern
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.Calendars.IslamicLeapYearPattern.Base15: 
    - id: NodaTime.Calendars.IslamicLeapYearPattern.Indian
      commentId: F:NodaTime.Calendars.IslamicLeapYearPattern.Indian
      language: CSharp
      name:
        CSharp: Indian
        VB: Indian
      nameWithType:
        CSharp: IslamicLeapYearPattern.Indian
        VB: IslamicLeapYearPattern.Indian
      qualifiedName:
        CSharp: NodaTime.Calendars.IslamicLeapYearPattern.Indian
        VB: NodaTime.Calendars.IslamicLeapYearPattern.Indian
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/IslamicLeapYearPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Indian
        path: src/NodaTime/Calendars/IslamicLeapYearPattern.cs
        startLine: 41
      summary: "\nA pattern of leap years in 2, 5, 8, 10, 13, 16, 19, 21, 24, 27 and 29.\n"
      example: []
      syntax:
        content:
          CSharp: Indian = 3
          VB: Indian = 3
        return:
          type: NodaTime.Calendars.IslamicLeapYearPattern
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.Calendars.IslamicLeapYearPattern.HabashAlHasib
      commentId: F:NodaTime.Calendars.IslamicLeapYearPattern.HabashAlHasib
      language: CSharp
      name:
        CSharp: HabashAlHasib
        VB: HabashAlHasib
      nameWithType:
        CSharp: IslamicLeapYearPattern.HabashAlHasib
        VB: IslamicLeapYearPattern.HabashAlHasib
      qualifiedName:
        CSharp: NodaTime.Calendars.IslamicLeapYearPattern.HabashAlHasib
        VB: NodaTime.Calendars.IslamicLeapYearPattern.HabashAlHasib
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Calendars
      source:
        remote:
          path: 1.2.x/src/NodaTime/Calendars/IslamicLeapYearPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: HabashAlHasib
        path: src/NodaTime/Calendars/IslamicLeapYearPattern.cs
        startLine: 45
      summary: "\nA pattern of leap years in 2, 5, 8, 11, 13, 16, 19, 21, 24, 27 and 30.\n"
      example: []
      syntax:
        content:
          CSharp: HabashAlHasib = 4
          VB: HabashAlHasib = 4
        return:
          type: NodaTime.Calendars.IslamicLeapYearPattern
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    references:
      NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch): 
- id: NodaTime.Text
  commentId: N:NodaTime.Text
  language: CSharp
  name:
    CSharp: NodaTime.Text
    VB: NodaTime.Text
  nameWithType:
    CSharp: NodaTime.Text
    VB: NodaTime.Text
  qualifiedName:
    CSharp: NodaTime.Text
    VB: NodaTime.Text
  type: Namespace
  assemblies:
  - NodaTime
  modifiers: {}
  items:
  - id: NodaTime.Text.DurationPattern
    commentId: T:NodaTime.Text.DurationPattern
    language: CSharp
    name:
      CSharp: DurationPattern
      VB: DurationPattern
    nameWithType:
      CSharp: DurationPattern
      VB: DurationPattern
    qualifiedName:
      CSharp: NodaTime.Text.DurationPattern
      VB: NodaTime.Text.DurationPattern
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/DurationPattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: DurationPattern
      path: src/NodaTime/Text/DurationPattern.cs
      startLine: 19
    summary: "\nRepresents a pattern for parsing and formatting <xref href=\"NodaTime.Duration\" data-throw-if-not-resolved=\"false\"></xref> values.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class DurationPattern : IPattern<Duration>'
        VB: >-
          Public NotInheritable Class DurationPattern

              Implements IPattern(Of Duration)
    inheritance:
    - System.Object
    implements:
    - NodaTime.Text.IPattern{NodaTime.Duration}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.DurationPattern.RoundtripPattern
      commentId: P:NodaTime.Text.DurationPattern.RoundtripPattern
      language: CSharp
      name:
        CSharp: RoundtripPattern
        VB: RoundtripPattern
      nameWithType:
        CSharp: DurationPattern.RoundtripPattern
        VB: DurationPattern.RoundtripPattern
      qualifiedName:
        CSharp: NodaTime.Text.DurationPattern.RoundtripPattern
        VB: NodaTime.Text.DurationPattern.RoundtripPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/DurationPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: RoundtripPattern
        path: src/NodaTime/Text/DurationPattern.cs
        startLine: 25
      summary: "\nGeneral pattern for durations using the invariant culture, with a format string of \"-D:hh:mm:ss.FFFFFFF\".\nThis pattern round-trips.\n"
      example: []
      syntax:
        content:
          CSharp: public static DurationPattern RoundtripPattern { get; }
          VB: Public Shared ReadOnly Property RoundtripPattern As DurationPattern
        parameters: []
        return:
          type: NodaTime.Text.DurationPattern
      overload: NodaTime.Text.DurationPattern.RoundtripPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.DurationPattern.PatternText
      commentId: P:NodaTime.Text.DurationPattern.PatternText
      language: CSharp
      name:
        CSharp: PatternText
        VB: PatternText
      nameWithType:
        CSharp: DurationPattern.PatternText
        VB: DurationPattern.PatternText
      qualifiedName:
        CSharp: NodaTime.Text.DurationPattern.PatternText
        VB: NodaTime.Text.DurationPattern.PatternText
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/DurationPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PatternText
        path: src/NodaTime/Text/DurationPattern.cs
        startLine: 42
      summary: "\nReturns the pattern text for this pattern, as supplied on creation.\n"
      example: []
      syntax:
        content:
          CSharp: public string PatternText { get; }
          VB: Public ReadOnly Property PatternText As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.Text.DurationPattern.PatternText*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.DurationPattern.Parse(System.String)
      commentId: M:NodaTime.Text.DurationPattern.Parse(System.String)
      language: CSharp
      name:
        CSharp: Parse(String)
        VB: Parse(String)
      nameWithType:
        CSharp: DurationPattern.Parse(String)
        VB: DurationPattern.Parse(String)
      qualifiedName:
        CSharp: NodaTime.Text.DurationPattern.Parse(System.String)
        VB: NodaTime.Text.DurationPattern.Parse(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/DurationPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Parse
        path: src/NodaTime/Text/DurationPattern.cs
        startLine: 65
      summary: "\nParses the given text value according to the rules of this pattern.\n"
      remarks: "\nThis method never throws an exception (barring a bug in Noda Time itself). Even errors such as\nthe argument being null are wrapped in a parse result.\n"
      example: []
      syntax:
        content:
          CSharp: public ParseResult<Duration> Parse(string text)
          VB: Public Function Parse(text As String) As ParseResult(Of Duration)
        parameters:
        - id: text
          type: System.String
          description: The text value to parse.
        return:
          type: NodaTime.Text.ParseResult{NodaTime.Duration}
          description: The result of parsing, which may be successful or unsuccessful.
      overload: NodaTime.Text.DurationPattern.Parse*
      implements:
      - NodaTime.Text.IPattern{NodaTime.Duration}.Parse(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.DurationPattern.Format(NodaTime.Duration)
      commentId: M:NodaTime.Text.DurationPattern.Format(NodaTime.Duration)
      language: CSharp
      name:
        CSharp: Format(Duration)
        VB: Format(Duration)
      nameWithType:
        CSharp: DurationPattern.Format(Duration)
        VB: DurationPattern.Format(Duration)
      qualifiedName:
        CSharp: NodaTime.Text.DurationPattern.Format(NodaTime.Duration)
        VB: NodaTime.Text.DurationPattern.Format(NodaTime.Duration)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/DurationPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Format
        path: src/NodaTime/Text/DurationPattern.cs
        startLine: 75
      summary: "\nFormats the given duration as text according to the rules of this pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string Format(Duration value)
          VB: Public Function Format(value As Duration) As String
        parameters:
        - id: value
          type: NodaTime.Duration
          description: The duration to format.
        return:
          type: System.String
          description: The duration formatted according to this pattern.
      overload: NodaTime.Text.DurationPattern.Format*
      implements:
      - NodaTime.Text.IPattern{NodaTime.Duration}.Format(NodaTime.Duration)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.DurationPattern.Create(System.String,System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.DurationPattern.Create(System.String,System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo)
        VB: Create(String, CultureInfo)
      nameWithType:
        CSharp: DurationPattern.Create(String, CultureInfo)
        VB: DurationPattern.Create(String, CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.DurationPattern.Create(System.String, System.Globalization.CultureInfo)
        VB: NodaTime.Text.DurationPattern.Create(System.String, System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/DurationPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/DurationPattern.cs
        startLine: 105
      summary: "\nCreates a pattern for the given pattern text and culture.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static DurationPattern Create(string patternText, CultureInfo cultureInfo)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo) As DurationPattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        return:
          type: NodaTime.Text.DurationPattern
          description: A pattern for parsing and formatting offsets.
      overload: NodaTime.Text.DurationPattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.DurationPattern.CreateWithCurrentCulture(System.String)
      commentId: M:NodaTime.Text.DurationPattern.CreateWithCurrentCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithCurrentCulture(String)
        VB: CreateWithCurrentCulture(String)
      nameWithType:
        CSharp: DurationPattern.CreateWithCurrentCulture(String)
        VB: DurationPattern.CreateWithCurrentCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.DurationPattern.CreateWithCurrentCulture(System.String)
        VB: NodaTime.Text.DurationPattern.CreateWithCurrentCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/DurationPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithCurrentCulture
        path: src/NodaTime/Text/DurationPattern.cs
        startLine: 121
      summary: "\nCreates a pattern for the given pattern text in the current thread's current culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static DurationPattern CreateWithCurrentCulture(string patternText)
          VB: Public Shared Function CreateWithCurrentCulture(patternText As String) As DurationPattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.DurationPattern
          description: A pattern for parsing and formatting offsets.
      overload: NodaTime.Text.DurationPattern.CreateWithCurrentCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.DurationPattern.CreateWithInvariantCulture(System.String)
      commentId: M:NodaTime.Text.DurationPattern.CreateWithInvariantCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithInvariantCulture(String)
        VB: CreateWithInvariantCulture(String)
      nameWithType:
        CSharp: DurationPattern.CreateWithInvariantCulture(String)
        VB: DurationPattern.CreateWithInvariantCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.DurationPattern.CreateWithInvariantCulture(System.String)
        VB: NodaTime.Text.DurationPattern.CreateWithInvariantCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/DurationPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithInvariantCulture
        path: src/NodaTime/Text/DurationPattern.cs
        startLine: 137
      summary: "\nCreates a pattern for the given pattern text in the invariant culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static DurationPattern CreateWithInvariantCulture(string patternText)
          VB: Public Shared Function CreateWithInvariantCulture(patternText As String) As DurationPattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.DurationPattern
          description: A pattern for parsing and formatting offsets.
      overload: NodaTime.Text.DurationPattern.CreateWithInvariantCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.DurationPattern.WithCulture(System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.DurationPattern.WithCulture(System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: WithCulture(CultureInfo)
        VB: WithCulture(CultureInfo)
      nameWithType:
        CSharp: DurationPattern.WithCulture(CultureInfo)
        VB: DurationPattern.WithCulture(CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.DurationPattern.WithCulture(System.Globalization.CultureInfo)
        VB: NodaTime.Text.DurationPattern.WithCulture(System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/DurationPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCulture
        path: src/NodaTime/Text/DurationPattern.cs
        startLine: 148
      summary: "\nCreates a pattern for the same original pattern text as this pattern, but with the specified\nculture.\n"
      example: []
      syntax:
        content:
          CSharp: public DurationPattern WithCulture(CultureInfo cultureInfo)
          VB: Public Function WithCulture(cultureInfo As CultureInfo) As DurationPattern
        parameters:
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the new pattern.
        return:
          type: NodaTime.Text.DurationPattern
          description: A new pattern with the given culture.
      overload: NodaTime.Text.DurationPattern.WithCulture*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.Duration: 
      System.Globalization.CultureInfo: 
  - id: NodaTime.Text.OffsetDateTimePattern
    commentId: T:NodaTime.Text.OffsetDateTimePattern
    language: CSharp
    name:
      CSharp: OffsetDateTimePattern
      VB: OffsetDateTimePattern
    nameWithType:
      CSharp: OffsetDateTimePattern
      VB: OffsetDateTimePattern
    qualifiedName:
      CSharp: NodaTime.Text.OffsetDateTimePattern
      VB: NodaTime.Text.OffsetDateTimePattern
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: OffsetDateTimePattern
      path: src/NodaTime/Text/OffsetDateTimePattern.cs
      startLine: 19
    summary: "\nRepresents a pattern for parsing and formatting <xref href=\"NodaTime.OffsetDateTime\" data-throw-if-not-resolved=\"false\"></xref> values.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class OffsetDateTimePattern : IPattern<OffsetDateTime>'
        VB: >-
          Public NotInheritable Class OffsetDateTimePattern

              Implements IPattern(Of OffsetDateTime)
    inheritance:
    - System.Object
    implements:
    - NodaTime.Text.IPattern{NodaTime.OffsetDateTime}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern
      commentId: P:NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern
      language: CSharp
      name:
        CSharp: GeneralIsoPattern
        VB: GeneralIsoPattern
      nameWithType:
        CSharp: OffsetDateTimePattern.GeneralIsoPattern
        VB: OffsetDateTimePattern.GeneralIsoPattern
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern
        VB: NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GeneralIsoPattern
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 29
      summary: "\nReturns an invariant offset date/time pattern based on ISO-8601 (down to the second), including offset from UTC.\nThe calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of\n\"yyyy'-'MM'-'dd'T'HH':'mm':'sso&lt;G&gt;\". This pattern is available as the \"G\"\nstandard pattern (even though it is invariant).\n"
      example: []
      syntax:
        content:
          CSharp: public static OffsetDateTimePattern GeneralIsoPattern { get; }
          VB: Public Shared ReadOnly Property GeneralIsoPattern As OffsetDateTimePattern
        parameters: []
        return:
          type: NodaTime.Text.OffsetDateTimePattern
      overload: NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern
      commentId: P:NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern
      language: CSharp
      name:
        CSharp: ExtendedIsoPattern
        VB: ExtendedIsoPattern
      nameWithType:
        CSharp: OffsetDateTimePattern.ExtendedIsoPattern
        VB: OffsetDateTimePattern.ExtendedIsoPattern
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern
        VB: NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ExtendedIsoPattern
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 37
      summary: "\nReturns an invariant offset date/time pattern based on ISO-8601 (down to the tick), including offset from UTC.\nThe calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of\n\"yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFo&lt;G&gt;\". This will round-trip any values\nin the ISO calendar, and is available as the \"o\" standard pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public static OffsetDateTimePattern ExtendedIsoPattern { get; }
          VB: Public Shared ReadOnly Property ExtendedIsoPattern As OffsetDateTimePattern
        parameters: []
        return:
          type: NodaTime.Text.OffsetDateTimePattern
      overload: NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern
      commentId: P:NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern
      language: CSharp
      name:
        CSharp: FullRoundtripPattern
        VB: FullRoundtripPattern
      nameWithType:
        CSharp: OffsetDateTimePattern.FullRoundtripPattern
        VB: OffsetDateTimePattern.FullRoundtripPattern
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern
        VB: NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FullRoundtripPattern
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 45
      summary: "\nReturns an invariant offset date/time pattern based on ISO-8601 (down to the tick)\nincluding offset from UTC and calendar ID. It corresponds to a custom pattern of\n\"yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFo&lt;G&gt; '('c')'\". This will round-trip any value in any calendar,\nand is available as the \"r\" standard pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public static OffsetDateTimePattern FullRoundtripPattern { get; }
          VB: Public Shared ReadOnly Property FullRoundtripPattern As OffsetDateTimePattern
        parameters: []
        return:
          type: NodaTime.Text.OffsetDateTimePattern
      overload: NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.OffsetDateTimePattern.PatternText
      commentId: P:NodaTime.Text.OffsetDateTimePattern.PatternText
      language: CSharp
      name:
        CSharp: PatternText
        VB: PatternText
      nameWithType:
        CSharp: OffsetDateTimePattern.PatternText
        VB: OffsetDateTimePattern.PatternText
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.PatternText
        VB: NodaTime.Text.OffsetDateTimePattern.PatternText
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PatternText
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 67
      summary: "\nReturns the pattern text for this pattern, as supplied on creation.\n"
      example: []
      syntax:
        content:
          CSharp: public string PatternText { get; }
          VB: Public ReadOnly Property PatternText As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.Text.OffsetDateTimePattern.PatternText*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.OffsetDateTimePattern.TemplateValue
      commentId: P:NodaTime.Text.OffsetDateTimePattern.TemplateValue
      language: CSharp
      name:
        CSharp: TemplateValue
        VB: TemplateValue
      nameWithType:
        CSharp: OffsetDateTimePattern.TemplateValue
        VB: OffsetDateTimePattern.TemplateValue
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.TemplateValue
        VB: NodaTime.Text.OffsetDateTimePattern.TemplateValue
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TemplateValue
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 78
      summary: "\nReturns the value used as a template for parsing: any field values unspecified\nin the pattern are taken from the template.\n"
      example: []
      syntax:
        content:
          CSharp: public OffsetDateTime TemplateValue { get; }
          VB: Public ReadOnly Property TemplateValue As OffsetDateTime
        parameters: []
        return:
          type: NodaTime.OffsetDateTime
      overload: NodaTime.Text.OffsetDateTimePattern.TemplateValue*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.OffsetDateTimePattern.Parse(System.String)
      commentId: M:NodaTime.Text.OffsetDateTimePattern.Parse(System.String)
      language: CSharp
      name:
        CSharp: Parse(String)
        VB: Parse(String)
      nameWithType:
        CSharp: OffsetDateTimePattern.Parse(String)
        VB: OffsetDateTimePattern.Parse(String)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.Parse(System.String)
        VB: NodaTime.Text.OffsetDateTimePattern.Parse(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Parse
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 98
      summary: "\nParses the given text value according to the rules of this pattern.\n"
      remarks: "\nThis method never throws an exception (barring a bug in Noda Time itself). Even errors such as\nthe argument being null are wrapped in a parse result.\n"
      example: []
      syntax:
        content:
          CSharp: public ParseResult<OffsetDateTime> Parse(string text)
          VB: Public Function Parse(text As String) As ParseResult(Of OffsetDateTime)
        parameters:
        - id: text
          type: System.String
          description: The text value to parse.
        return:
          type: NodaTime.Text.ParseResult{NodaTime.OffsetDateTime}
          description: The result of parsing, which may be successful or unsuccessful.
      overload: NodaTime.Text.OffsetDateTimePattern.Parse*
      implements:
      - NodaTime.Text.IPattern{NodaTime.OffsetDateTime}.Parse(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.OffsetDateTimePattern.Format(NodaTime.OffsetDateTime)
      commentId: M:NodaTime.Text.OffsetDateTimePattern.Format(NodaTime.OffsetDateTime)
      language: CSharp
      name:
        CSharp: Format(OffsetDateTime)
        VB: Format(OffsetDateTime)
      nameWithType:
        CSharp: OffsetDateTimePattern.Format(OffsetDateTime)
        VB: OffsetDateTimePattern.Format(OffsetDateTime)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.Format(NodaTime.OffsetDateTime)
        VB: NodaTime.Text.OffsetDateTimePattern.Format(NodaTime.OffsetDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Format
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 108
      summary: "\nFormats the given zoned date/time as text according to the rules of this pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string Format(OffsetDateTime value)
          VB: Public Function Format(value As OffsetDateTime) As String
        parameters:
        - id: value
          type: NodaTime.OffsetDateTime
          description: The zoned date/time to format.
        return:
          type: System.String
          description: The zoned date/time formatted according to this pattern.
      overload: NodaTime.Text.OffsetDateTimePattern.Format*
      implements:
      - NodaTime.Text.IPattern{NodaTime.OffsetDateTime}.Format(NodaTime.OffsetDateTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.OffsetDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.OffsetDateTime)
      commentId: M:NodaTime.Text.OffsetDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.OffsetDateTime)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo, OffsetDateTime)
        VB: Create(String, CultureInfo, OffsetDateTime)
      nameWithType:
        CSharp: OffsetDateTimePattern.Create(String, CultureInfo, OffsetDateTime)
        VB: OffsetDateTimePattern.Create(String, CultureInfo, OffsetDateTime)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.Create(System.String, System.Globalization.CultureInfo, NodaTime.OffsetDateTime)
        VB: NodaTime.Text.OffsetDateTimePattern.Create(System.String, System.Globalization.CultureInfo, NodaTime.OffsetDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 140
      summary: "\nCreates a pattern for the given pattern text, culture, and template value.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static OffsetDateTimePattern Create(string patternText, CultureInfo cultureInfo, OffsetDateTime templateValue)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo, templateValue As OffsetDateTime) As OffsetDateTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        - id: templateValue
          type: NodaTime.OffsetDateTime
          description: Template value to use for unspecified fields
        return:
          type: NodaTime.Text.OffsetDateTimePattern
          description: A pattern for parsing and formatting local date/times.
      overload: NodaTime.Text.OffsetDateTimePattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.OffsetDateTimePattern.WithPatternText(System.String)
      commentId: M:NodaTime.Text.OffsetDateTimePattern.WithPatternText(System.String)
      language: CSharp
      name:
        CSharp: WithPatternText(String)
        VB: WithPatternText(String)
      nameWithType:
        CSharp: OffsetDateTimePattern.WithPatternText(String)
        VB: OffsetDateTimePattern.WithPatternText(String)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.WithPatternText(System.String)
        VB: NodaTime.Text.OffsetDateTimePattern.WithPatternText(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithPatternText
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 151
      summary: "\nCreates a pattern for the same original localization information as this pattern, but with the specified\npattern text.\n"
      example: []
      syntax:
        content:
          CSharp: public OffsetDateTimePattern WithPatternText(string newPatternText)
          VB: Public Function WithPatternText(newPatternText As String) As OffsetDateTimePattern
        parameters:
        - id: newPatternText
          type: System.String
          description: The pattern text to use in the new pattern.
        return:
          type: NodaTime.Text.OffsetDateTimePattern
          description: A new pattern with the given pattern text.
      overload: NodaTime.Text.OffsetDateTimePattern.WithPatternText*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.OffsetDateTimePattern.WithCulture(System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.OffsetDateTimePattern.WithCulture(System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: WithCulture(CultureInfo)
        VB: WithCulture(CultureInfo)
      nameWithType:
        CSharp: OffsetDateTimePattern.WithCulture(CultureInfo)
        VB: OffsetDateTimePattern.WithCulture(CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.WithCulture(System.Globalization.CultureInfo)
        VB: NodaTime.Text.OffsetDateTimePattern.WithCulture(System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCulture
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 173
      summary: "\nCreates a pattern for the same original pattern text as this pattern, but with the specified\nculture.\n"
      example: []
      syntax:
        content:
          CSharp: public OffsetDateTimePattern WithCulture(CultureInfo cultureInfo)
          VB: Public Function WithCulture(cultureInfo As CultureInfo) As OffsetDateTimePattern
        parameters:
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the new pattern.
        return:
          type: NodaTime.Text.OffsetDateTimePattern
          description: A new pattern with the given culture.
      overload: NodaTime.Text.OffsetDateTimePattern.WithCulture*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.OffsetDateTimePattern.WithTemplateValue(NodaTime.OffsetDateTime)
      commentId: M:NodaTime.Text.OffsetDateTimePattern.WithTemplateValue(NodaTime.OffsetDateTime)
      language: CSharp
      name:
        CSharp: WithTemplateValue(OffsetDateTime)
        VB: WithTemplateValue(OffsetDateTime)
      nameWithType:
        CSharp: OffsetDateTimePattern.WithTemplateValue(OffsetDateTime)
        VB: OffsetDateTimePattern.WithTemplateValue(OffsetDateTime)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetDateTimePattern.WithTemplateValue(NodaTime.OffsetDateTime)
        VB: NodaTime.Text.OffsetDateTimePattern.WithTemplateValue(NodaTime.OffsetDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithTemplateValue
        path: src/NodaTime/Text/OffsetDateTimePattern.cs
        startLine: 184
      summary: "\nCreates a pattern for the same original pattern text and culture as this pattern, but with\nthe specified template value.\n"
      example: []
      syntax:
        content:
          CSharp: public OffsetDateTimePattern WithTemplateValue(OffsetDateTime newTemplateValue)
          VB: Public Function WithTemplateValue(newTemplateValue As OffsetDateTime) As OffsetDateTimePattern
        parameters:
        - id: newTemplateValue
          type: NodaTime.OffsetDateTime
          description: The template value to use in the new pattern.
        return:
          type: NodaTime.Text.OffsetDateTimePattern
          description: A new pattern with the given template value.
      overload: NodaTime.Text.OffsetDateTimePattern.WithTemplateValue*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.OffsetDateTime: 
      System.Globalization.CultureInfo: 
  - id: NodaTime.Text.ZonedDateTimePattern
    commentId: T:NodaTime.Text.ZonedDateTimePattern
    language: CSharp
    name:
      CSharp: ZonedDateTimePattern
      VB: ZonedDateTimePattern
    nameWithType:
      CSharp: ZonedDateTimePattern
      VB: ZonedDateTimePattern
    qualifiedName:
      CSharp: NodaTime.Text.ZonedDateTimePattern
      VB: NodaTime.Text.ZonedDateTimePattern
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: ZonedDateTimePattern
      path: src/NodaTime/Text/ZonedDateTimePattern.cs
      startLine: 20
    summary: "\nRepresents a pattern for parsing and formatting <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> values.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class ZonedDateTimePattern : IPattern<ZonedDateTime>'
        VB: >-
          Public NotInheritable Class ZonedDateTimePattern

              Implements IPattern(Of ZonedDateTime)
    inheritance:
    - System.Object
    implements:
    - NodaTime.Text.IPattern{NodaTime.ZonedDateTime}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
      commentId: P:NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
      language: CSharp
      name:
        CSharp: GeneralFormatOnlyIsoPattern
        VB: GeneralFormatOnlyIsoPattern
      nameWithType:
        CSharp: ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
        VB: ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
        VB: NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GeneralFormatOnlyIsoPattern
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 30
      summary: "\nReturns an zoned local date/time pattern based on ISO-8601 (down to the second) including offset from UTC and zone ID.\nThe calendar system is not formatted as part of this pattern, and it cannot be used for parsing.\nIt corresponds to a custom pattern of \"yyyy'-'MM'-'dd'T'HH':'mm':'ss z '('o&lt;g&gt;')'\" and is available\nas the 'G' standard pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTimePattern GeneralFormatOnlyIsoPattern { get; }
          VB: Public Shared ReadOnly Property GeneralFormatOnlyIsoPattern As ZonedDateTimePattern
        parameters: []
        return:
          type: NodaTime.Text.ZonedDateTimePattern
      overload: NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
      commentId: P:NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
      language: CSharp
      name:
        CSharp: ExtendedFormatOnlyIsoPattern
        VB: ExtendedFormatOnlyIsoPattern
      nameWithType:
        CSharp: ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
        VB: ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
        VB: NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ExtendedFormatOnlyIsoPattern
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 38
      summary: "\nReturns an invariant zoned date/time pattern based on ISO-8601 (down to the tick) including offset from UTC and zone ID.\nThe calendar system is not formatted as part of this pattern, and it cannot be used for parsing.\nIt corresponds to a custom pattern of \"yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF z '('o&lt;g&gt;')'\" and is available\nas the 'F' standard pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTimePattern ExtendedFormatOnlyIsoPattern { get; }
          VB: Public Shared ReadOnly Property ExtendedFormatOnlyIsoPattern As ZonedDateTimePattern
        parameters: []
        return:
          type: NodaTime.Text.ZonedDateTimePattern
      overload: NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.ZonedDateTimePattern.PatternText
      commentId: P:NodaTime.Text.ZonedDateTimePattern.PatternText
      language: CSharp
      name:
        CSharp: PatternText
        VB: PatternText
      nameWithType:
        CSharp: ZonedDateTimePattern.PatternText
        VB: ZonedDateTimePattern.PatternText
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.PatternText
        VB: NodaTime.Text.ZonedDateTimePattern.PatternText
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PatternText
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 61
      summary: "\nReturns the pattern text for this pattern, as supplied on creation.\n"
      example: []
      syntax:
        content:
          CSharp: public string PatternText { get; }
          VB: Public ReadOnly Property PatternText As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.Text.ZonedDateTimePattern.PatternText*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.ZonedDateTimePattern.TemplateValue
      commentId: P:NodaTime.Text.ZonedDateTimePattern.TemplateValue
      language: CSharp
      name:
        CSharp: TemplateValue
        VB: TemplateValue
      nameWithType:
        CSharp: ZonedDateTimePattern.TemplateValue
        VB: ZonedDateTimePattern.TemplateValue
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.TemplateValue
        VB: NodaTime.Text.ZonedDateTimePattern.TemplateValue
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TemplateValue
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 72
      summary: "\nReturns the value used as a template for parsing: any field values unspecified\nin the pattern are taken from the template.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime TemplateValue { get; }
          VB: Public ReadOnly Property TemplateValue As ZonedDateTime
        parameters: []
        return:
          type: NodaTime.ZonedDateTime
      overload: NodaTime.Text.ZonedDateTimePattern.TemplateValue*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.ZonedDateTimePattern.Resolver
      commentId: P:NodaTime.Text.ZonedDateTimePattern.Resolver
      language: CSharp
      name:
        CSharp: Resolver
        VB: Resolver
      nameWithType:
        CSharp: ZonedDateTimePattern.Resolver
        VB: ZonedDateTimePattern.Resolver
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.Resolver
        VB: NodaTime.Text.ZonedDateTimePattern.Resolver
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Resolver
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 78
      summary: "\nReturns the resolver which is used to map local date/times to zoned date/times,\nhandling skipped and ambiguous times appropriately (where the offset isn't specified in the pattern).\n"
      example: []
      syntax:
        content:
          CSharp: public ZoneLocalMappingResolver Resolver { get; }
          VB: Public ReadOnly Property Resolver As ZoneLocalMappingResolver
        parameters: []
        return:
          type: NodaTime.TimeZones.ZoneLocalMappingResolver
      overload: NodaTime.Text.ZonedDateTimePattern.Resolver*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.ZonedDateTimePattern.ZoneProvider
      commentId: P:NodaTime.Text.ZonedDateTimePattern.ZoneProvider
      language: CSharp
      name:
        CSharp: ZoneProvider
        VB: ZoneProvider
      nameWithType:
        CSharp: ZonedDateTimePattern.ZoneProvider
        VB: ZonedDateTimePattern.ZoneProvider
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.ZoneProvider
        VB: NodaTime.Text.ZonedDateTimePattern.ZoneProvider
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ZoneProvider
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 85
      summary: "\nReturns the provider which is used to look up time zones when parsing a pattern\nwhich contains a time zone identifier. This may be null, in which case the pattern can\nonly be used for formatting (not parsing).\n"
      example: []
      syntax:
        content:
          CSharp: public IDateTimeZoneProvider ZoneProvider { get; }
          VB: Public ReadOnly Property ZoneProvider As IDateTimeZoneProvider
        parameters: []
        return:
          type: NodaTime.IDateTimeZoneProvider
      overload: NodaTime.Text.ZonedDateTimePattern.ZoneProvider*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.ZonedDateTimePattern.Parse(System.String)
      commentId: M:NodaTime.Text.ZonedDateTimePattern.Parse(System.String)
      language: CSharp
      name:
        CSharp: Parse(String)
        VB: Parse(String)
      nameWithType:
        CSharp: ZonedDateTimePattern.Parse(String)
        VB: ZonedDateTimePattern.Parse(String)
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.Parse(System.String)
        VB: NodaTime.Text.ZonedDateTimePattern.Parse(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Parse
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 107
      summary: "\nParses the given text value according to the rules of this pattern.\n"
      remarks: "\nThis method never throws an exception (barring a bug in Noda Time itself). Even errors such as\nthe argument being null are wrapped in a parse result.\n"
      example: []
      syntax:
        content:
          CSharp: public ParseResult<ZonedDateTime> Parse(string text)
          VB: Public Function Parse(text As String) As ParseResult(Of ZonedDateTime)
        parameters:
        - id: text
          type: System.String
          description: The text value to parse.
        return:
          type: NodaTime.Text.ParseResult{NodaTime.ZonedDateTime}
          description: The result of parsing, which may be successful or unsuccessful.
      overload: NodaTime.Text.ZonedDateTimePattern.Parse*
      implements:
      - NodaTime.Text.IPattern{NodaTime.ZonedDateTime}.Parse(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.ZonedDateTimePattern.Format(NodaTime.ZonedDateTime)
      commentId: M:NodaTime.Text.ZonedDateTimePattern.Format(NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: Format(ZonedDateTime)
        VB: Format(ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTimePattern.Format(ZonedDateTime)
        VB: ZonedDateTimePattern.Format(ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.Format(NodaTime.ZonedDateTime)
        VB: NodaTime.Text.ZonedDateTimePattern.Format(NodaTime.ZonedDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Format
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 117
      summary: "\nFormats the given zoned date/time as text according to the rules of this pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string Format(ZonedDateTime value)
          VB: Public Function Format(value As ZonedDateTime) As String
        parameters:
        - id: value
          type: NodaTime.ZonedDateTime
          description: The zoned date/time to format.
        return:
          type: System.String
          description: The zoned date/time formatted according to this pattern.
      overload: NodaTime.Text.ZonedDateTimePattern.Format*
      implements:
      - NodaTime.Text.IPattern{NodaTime.ZonedDateTime}.Format(NodaTime.ZonedDateTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.ZonedDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.TimeZones.ZoneLocalMappingResolver,NodaTime.IDateTimeZoneProvider,NodaTime.ZonedDateTime)
      commentId: M:NodaTime.Text.ZonedDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.TimeZones.ZoneLocalMappingResolver,NodaTime.IDateTimeZoneProvider,NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo, ZoneLocalMappingResolver, IDateTimeZoneProvider, ZonedDateTime)
        VB: Create(String, CultureInfo, ZoneLocalMappingResolver, IDateTimeZoneProvider, ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTimePattern.Create(String, CultureInfo, ZoneLocalMappingResolver, IDateTimeZoneProvider, ZonedDateTime)
        VB: ZonedDateTimePattern.Create(String, CultureInfo, ZoneLocalMappingResolver, IDateTimeZoneProvider, ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.Create(System.String, System.Globalization.CultureInfo, NodaTime.TimeZones.ZoneLocalMappingResolver, NodaTime.IDateTimeZoneProvider, NodaTime.ZonedDateTime)
        VB: NodaTime.Text.ZonedDateTimePattern.Create(System.String, System.Globalization.CultureInfo, NodaTime.TimeZones.ZoneLocalMappingResolver, NodaTime.IDateTimeZoneProvider, NodaTime.ZonedDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 157
      summary: "\nCreates a pattern for the given pattern text, culture, resolver, time zone provider, and template value.\n"
      remarks: "\nSee the user guide for the available pattern text options.\nIf <span class=\"paramref\">zoneProvider</span> is null, the resulting pattern can be used for formatting\nbut not parsing.\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTimePattern Create(string patternText, CultureInfo cultureInfo, ZoneLocalMappingResolver resolver, IDateTimeZoneProvider zoneProvider, ZonedDateTime templateValue)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo, resolver As ZoneLocalMappingResolver, zoneProvider As IDateTimeZoneProvider, templateValue As ZonedDateTime) As ZonedDateTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        - id: resolver
          type: NodaTime.TimeZones.ZoneLocalMappingResolver
          description: Resolver to apply when mapping local date/time values into the zone.
        - id: zoneProvider
          type: NodaTime.IDateTimeZoneProvider
          description: Time zone provider, used when parsing text which contains a time zone identifier.
        - id: templateValue
          type: NodaTime.ZonedDateTime
          description: Template value to use for unspecified fields
        return:
          type: NodaTime.Text.ZonedDateTimePattern
          description: A pattern for parsing and formatting zoned date/times.
      overload: NodaTime.Text.ZonedDateTimePattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture(System.String,NodaTime.IDateTimeZoneProvider)
      commentId: M:NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture(System.String,NodaTime.IDateTimeZoneProvider)
      language: CSharp
      name:
        CSharp: CreateWithInvariantCulture(String, IDateTimeZoneProvider)
        VB: CreateWithInvariantCulture(String, IDateTimeZoneProvider)
      nameWithType:
        CSharp: ZonedDateTimePattern.CreateWithInvariantCulture(String, IDateTimeZoneProvider)
        VB: ZonedDateTimePattern.CreateWithInvariantCulture(String, IDateTimeZoneProvider)
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture(System.String, NodaTime.IDateTimeZoneProvider)
        VB: NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture(System.String, NodaTime.IDateTimeZoneProvider)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithInvariantCulture
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 175
      summary: "\nCreates a pattern for the given pattern text and time zone provider, using a strict resolver, the invariant\nculture, and a default template value of midnight January 1st 2000 UTC.\n"
      remarks: "\nThe resolver is only used if the pattern text doesn't include an offset.\nIf <span class=\"paramref\">zoneProvider</span> is null, the resulting pattern can be used for formatting\nbut not parsing.\n"
      example: []
      syntax:
        content:
          CSharp: public static ZonedDateTimePattern CreateWithInvariantCulture(string patternText, IDateTimeZoneProvider zoneProvider)
          VB: Public Shared Function CreateWithInvariantCulture(patternText As String, zoneProvider As IDateTimeZoneProvider) As ZonedDateTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: zoneProvider
          type: NodaTime.IDateTimeZoneProvider
          description: Time zone provider, used when parsing text which contains a time zone identifier.
        return:
          type: NodaTime.Text.ZonedDateTimePattern
          description: A pattern for parsing and formatting zoned date/times.
      overload: NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.ZonedDateTimePattern.WithPatternText(System.String)
      commentId: M:NodaTime.Text.ZonedDateTimePattern.WithPatternText(System.String)
      language: CSharp
      name:
        CSharp: WithPatternText(String)
        VB: WithPatternText(String)
      nameWithType:
        CSharp: ZonedDateTimePattern.WithPatternText(String)
        VB: ZonedDateTimePattern.WithPatternText(String)
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.WithPatternText(System.String)
        VB: NodaTime.Text.ZonedDateTimePattern.WithPatternText(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithPatternText
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 186
      summary: "\nCreates a pattern for the same original localization information as this pattern, but with the specified\npattern text.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTimePattern WithPatternText(string newPatternText)
          VB: Public Function WithPatternText(newPatternText As String) As ZonedDateTimePattern
        parameters:
        - id: newPatternText
          type: System.String
          description: The pattern text to use in the new pattern.
        return:
          type: NodaTime.Text.ZonedDateTimePattern
          description: A new pattern with the given pattern text.
      overload: NodaTime.Text.ZonedDateTimePattern.WithPatternText*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.ZonedDateTimePattern.WithCulture(System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.ZonedDateTimePattern.WithCulture(System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: WithCulture(CultureInfo)
        VB: WithCulture(CultureInfo)
      nameWithType:
        CSharp: ZonedDateTimePattern.WithCulture(CultureInfo)
        VB: ZonedDateTimePattern.WithCulture(CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.WithCulture(System.Globalization.CultureInfo)
        VB: NodaTime.Text.ZonedDateTimePattern.WithCulture(System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCulture
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 208
      summary: "\nCreates a pattern for the same original pattern text as this pattern, but with the specified\nculture.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTimePattern WithCulture(CultureInfo cultureInfo)
          VB: Public Function WithCulture(cultureInfo As CultureInfo) As ZonedDateTimePattern
        parameters:
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the new pattern.
        return:
          type: NodaTime.Text.ZonedDateTimePattern
          description: A new pattern with the given culture.
      overload: NodaTime.Text.ZonedDateTimePattern.WithCulture*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.ZonedDateTimePattern.WithResolver(NodaTime.TimeZones.ZoneLocalMappingResolver)
      commentId: M:NodaTime.Text.ZonedDateTimePattern.WithResolver(NodaTime.TimeZones.ZoneLocalMappingResolver)
      language: CSharp
      name:
        CSharp: WithResolver(ZoneLocalMappingResolver)
        VB: WithResolver(ZoneLocalMappingResolver)
      nameWithType:
        CSharp: ZonedDateTimePattern.WithResolver(ZoneLocalMappingResolver)
        VB: ZonedDateTimePattern.WithResolver(ZoneLocalMappingResolver)
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.WithResolver(NodaTime.TimeZones.ZoneLocalMappingResolver)
        VB: NodaTime.Text.ZonedDateTimePattern.WithResolver(NodaTime.TimeZones.ZoneLocalMappingResolver)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithResolver
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 219
      summary: "\nCreates a pattern for the same original pattern text as this pattern, but with the specified\nresolver.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTimePattern WithResolver(ZoneLocalMappingResolver newResolver)
          VB: Public Function WithResolver(newResolver As ZoneLocalMappingResolver) As ZonedDateTimePattern
        parameters:
        - id: newResolver
          type: NodaTime.TimeZones.ZoneLocalMappingResolver
          description: The new local mapping resolver to use.
        return:
          type: NodaTime.Text.ZonedDateTimePattern
          description: A new pattern with the given resolver.
      overload: NodaTime.Text.ZonedDateTimePattern.WithResolver*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)
      commentId: M:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)
      language: CSharp
      name:
        CSharp: WithZoneProvider(IDateTimeZoneProvider)
        VB: WithZoneProvider(IDateTimeZoneProvider)
      nameWithType:
        CSharp: ZonedDateTimePattern.WithZoneProvider(IDateTimeZoneProvider)
        VB: ZonedDateTimePattern.WithZoneProvider(IDateTimeZoneProvider)
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)
        VB: NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithZoneProvider
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 234
      summary: "\nCreates a pattern for the same original pattern text as this pattern, but with the specified\ntime zone provider.\n"
      remarks: "\nIf <span class=\"paramref\">newZoneProvider</span> is null, the resulting pattern can be used for formatting\nbut not parsing.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTimePattern WithZoneProvider(IDateTimeZoneProvider newZoneProvider)
          VB: Public Function WithZoneProvider(newZoneProvider As IDateTimeZoneProvider) As ZonedDateTimePattern
        parameters:
        - id: newZoneProvider
          type: NodaTime.IDateTimeZoneProvider
          description: The new time zone provider to use.
        return:
          type: NodaTime.Text.ZonedDateTimePattern
          description: A new pattern with the given time zone provider.
      overload: NodaTime.Text.ZonedDateTimePattern.WithZoneProvider*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.ZonedDateTimePattern.WithTemplateValue(NodaTime.ZonedDateTime)
      commentId: M:NodaTime.Text.ZonedDateTimePattern.WithTemplateValue(NodaTime.ZonedDateTime)
      language: CSharp
      name:
        CSharp: WithTemplateValue(ZonedDateTime)
        VB: WithTemplateValue(ZonedDateTime)
      nameWithType:
        CSharp: ZonedDateTimePattern.WithTemplateValue(ZonedDateTime)
        VB: ZonedDateTimePattern.WithTemplateValue(ZonedDateTime)
      qualifiedName:
        CSharp: NodaTime.Text.ZonedDateTimePattern.WithTemplateValue(NodaTime.ZonedDateTime)
        VB: NodaTime.Text.ZonedDateTimePattern.WithTemplateValue(NodaTime.ZonedDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ZonedDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithTemplateValue
        path: src/NodaTime/Text/ZonedDateTimePattern.cs
        startLine: 244
      summary: "\nCreates a pattern like this one, but with the specified template value.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTimePattern WithTemplateValue(ZonedDateTime newTemplateValue)
          VB: Public Function WithTemplateValue(newTemplateValue As ZonedDateTime) As ZonedDateTimePattern
        parameters:
        - id: newTemplateValue
          type: NodaTime.ZonedDateTime
          description: The template value for the new pattern, used to fill in unspecified fields.
        return:
          type: NodaTime.Text.ZonedDateTimePattern
          description: A new pattern with the given template value.
      overload: NodaTime.Text.ZonedDateTimePattern.WithTemplateValue*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.ZonedDateTime: 
      System.Globalization.CultureInfo: 
  - id: NodaTime.Text.InstantPattern
    commentId: T:NodaTime.Text.InstantPattern
    language: CSharp
    name:
      CSharp: InstantPattern
      VB: InstantPattern
    nameWithType:
      CSharp: InstantPattern
      VB: InstantPattern
    qualifiedName:
      CSharp: NodaTime.Text.InstantPattern
      VB: NodaTime.Text.InstantPattern
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: InstantPattern
      path: src/NodaTime/Text/InstantPattern.cs
      startLine: 20
    summary: "\nRepresents a pattern for parsing and formatting <xref href=\"NodaTime.Instant\" data-throw-if-not-resolved=\"false\"></xref> values.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class InstantPattern : IPattern<Instant>'
        VB: >-
          Public NotInheritable Class InstantPattern

              Implements IPattern(Of Instant)
    inheritance:
    - System.Object
    implements:
    - NodaTime.Text.IPattern{NodaTime.Instant}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.InstantPattern.GeneralPattern
      commentId: P:NodaTime.Text.InstantPattern.GeneralPattern
      language: CSharp
      name:
        CSharp: GeneralPattern
        VB: GeneralPattern
      nameWithType:
        CSharp: InstantPattern.GeneralPattern
        VB: InstantPattern.GeneralPattern
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.GeneralPattern
        VB: NodaTime.Text.InstantPattern.GeneralPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GeneralPattern
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 41
      summary: "\nReturns the general pattern, which always uses an invariant culture. The general pattern represents\nan instant as a UTC date/time in ISO-8601 style \"yyyy-MM-ddTHH:mm:ss'Z'\".\n"
      example: []
      syntax:
        content:
          CSharp: public static InstantPattern GeneralPattern { get; }
          VB: Public Shared ReadOnly Property GeneralPattern As InstantPattern
        parameters: []
        return:
          type: NodaTime.Text.InstantPattern
      overload: NodaTime.Text.InstantPattern.GeneralPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.InstantPattern.ExtendedIsoPattern
      commentId: P:NodaTime.Text.InstantPattern.ExtendedIsoPattern
      language: CSharp
      name:
        CSharp: ExtendedIsoPattern
        VB: ExtendedIsoPattern
      nameWithType:
        CSharp: InstantPattern.ExtendedIsoPattern
        VB: InstantPattern.ExtendedIsoPattern
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.ExtendedIsoPattern
        VB: NodaTime.Text.InstantPattern.ExtendedIsoPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ExtendedIsoPattern
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 48
      summary: "\nReturns an invariant instant pattern which is ISO-8601 compatible, providing up to 7 decimal places\nof sub-second accuracy. (These digits are omitted when unnecessary.)\nThis corresponds to the text pattern \"yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF'Z'\".\n"
      example: []
      syntax:
        content:
          CSharp: public static InstantPattern ExtendedIsoPattern { get; }
          VB: Public Shared ReadOnly Property ExtendedIsoPattern As InstantPattern
        parameters: []
        return:
          type: NodaTime.Text.InstantPattern
      overload: NodaTime.Text.InstantPattern.ExtendedIsoPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.InstantPattern.PatternText
      commentId: P:NodaTime.Text.InstantPattern.PatternText
      language: CSharp
      name:
        CSharp: PatternText
        VB: PatternText
      nameWithType:
        CSharp: InstantPattern.PatternText
        VB: InstantPattern.PatternText
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.PatternText
        VB: NodaTime.Text.InstantPattern.PatternText
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PatternText
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 73
      summary: "\nReturns the pattern text for this pattern, as supplied on creation.\n"
      example: []
      syntax:
        content:
          CSharp: public string PatternText { get; }
          VB: Public ReadOnly Property PatternText As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.Text.InstantPattern.PatternText*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.InstantPattern.Parse(System.String)
      commentId: M:NodaTime.Text.InstantPattern.Parse(System.String)
      language: CSharp
      name:
        CSharp: Parse(String)
        VB: Parse(String)
      nameWithType:
        CSharp: InstantPattern.Parse(String)
        VB: InstantPattern.Parse(String)
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.Parse(System.String)
        VB: NodaTime.Text.InstantPattern.Parse(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Parse
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 99
      summary: "\nParses the given text value according to the rules of this pattern.\n"
      remarks: "\nThis method never throws an exception (barring a bug in Noda Time itself). Even errors such as\nthe argument being null are wrapped in a parse result.\n"
      example: []
      syntax:
        content:
          CSharp: public ParseResult<Instant> Parse(string text)
          VB: Public Function Parse(text As String) As ParseResult(Of Instant)
        parameters:
        - id: text
          type: System.String
          description: The text value to parse.
        return:
          type: NodaTime.Text.ParseResult{NodaTime.Instant}
          description: The result of parsing, which may be successful or unsuccessful.
      overload: NodaTime.Text.InstantPattern.Parse*
      implements:
      - NodaTime.Text.IPattern{NodaTime.Instant}.Parse(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.InstantPattern.Format(NodaTime.Instant)
      commentId: M:NodaTime.Text.InstantPattern.Format(NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Format(Instant)
        VB: Format(Instant)
      nameWithType:
        CSharp: InstantPattern.Format(Instant)
        VB: InstantPattern.Format(Instant)
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.Format(NodaTime.Instant)
        VB: NodaTime.Text.InstantPattern.Format(NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Format
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 109
      summary: "\nFormats the given instant as text according to the rules of this pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string Format(Instant value)
          VB: Public Function Format(value As Instant) As String
        parameters:
        - id: value
          type: NodaTime.Instant
          description: The instant to format.
        return:
          type: System.String
          description: The instant formatted according to this pattern.
      overload: NodaTime.Text.InstantPattern.Format*
      implements:
      - NodaTime.Text.IPattern{NodaTime.Instant}.Format(NodaTime.Instant)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.InstantPattern.Create(System.String,System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.InstantPattern.Create(System.String,System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo)
        VB: Create(String, CultureInfo)
      nameWithType:
        CSharp: InstantPattern.Create(String, CultureInfo)
        VB: InstantPattern.Create(String, CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.Create(System.String, System.Globalization.CultureInfo)
        VB: NodaTime.Text.InstantPattern.Create(System.String, System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 162
      summary: "\nCreates a pattern for the given pattern text and culture.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static InstantPattern Create(string patternText, CultureInfo cultureInfo)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo) As InstantPattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        return:
          type: NodaTime.Text.InstantPattern
          description: A pattern for parsing and formatting instants.
      overload: NodaTime.Text.InstantPattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.InstantPattern.CreateWithCurrentCulture(System.String)
      commentId: M:NodaTime.Text.InstantPattern.CreateWithCurrentCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithCurrentCulture(String)
        VB: CreateWithCurrentCulture(String)
      nameWithType:
        CSharp: InstantPattern.CreateWithCurrentCulture(String)
        VB: InstantPattern.CreateWithCurrentCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.CreateWithCurrentCulture(System.String)
        VB: NodaTime.Text.InstantPattern.CreateWithCurrentCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithCurrentCulture
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 178
      summary: "\nCreates a pattern for the given pattern text in the current thread's current culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static InstantPattern CreateWithCurrentCulture(string patternText)
          VB: Public Shared Function CreateWithCurrentCulture(patternText As String) As InstantPattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.InstantPattern
          description: A pattern for parsing and formatting instants.
      overload: NodaTime.Text.InstantPattern.CreateWithCurrentCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.InstantPattern.CreateWithInvariantCulture(System.String)
      commentId: M:NodaTime.Text.InstantPattern.CreateWithInvariantCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithInvariantCulture(String)
        VB: CreateWithInvariantCulture(String)
      nameWithType:
        CSharp: InstantPattern.CreateWithInvariantCulture(String)
        VB: InstantPattern.CreateWithInvariantCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.CreateWithInvariantCulture(System.String)
        VB: NodaTime.Text.InstantPattern.CreateWithInvariantCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithInvariantCulture
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 193
      summary: "\nCreates a pattern for the given pattern text in the invariant culture, using the default\nmin/max labels.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static InstantPattern CreateWithInvariantCulture(string patternText)
          VB: Public Shared Function CreateWithInvariantCulture(patternText As String) As InstantPattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.InstantPattern
          description: A pattern for parsing and formatting instants.
      overload: NodaTime.Text.InstantPattern.CreateWithInvariantCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.InstantPattern.CreateNumericPattern(System.Globalization.CultureInfo,System.Boolean)
      commentId: M:NodaTime.Text.InstantPattern.CreateNumericPattern(System.Globalization.CultureInfo,System.Boolean)
      language: CSharp
      name:
        CSharp: CreateNumericPattern(CultureInfo, Boolean)
        VB: CreateNumericPattern(CultureInfo, Boolean)
      nameWithType:
        CSharp: InstantPattern.CreateNumericPattern(CultureInfo, Boolean)
        VB: InstantPattern.CreateNumericPattern(CultureInfo, Boolean)
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.CreateNumericPattern(System.Globalization.CultureInfo, System.Boolean)
        VB: NodaTime.Text.InstantPattern.CreateNumericPattern(System.Globalization.CultureInfo, System.Boolean)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateNumericPattern
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 205
      summary: "\nCreates a \"numeric\" pattern for the given culture. The numeric format gives the\nnumber of ticks in decimal format, with or without thousands separators.\n"
      example: []
      syntax:
        content:
          CSharp: public static InstantPattern CreateNumericPattern(CultureInfo cultureInfo, bool includeThousandsSeparators)
          VB: Public Shared Function CreateNumericPattern(cultureInfo As CultureInfo, includeThousandsSeparators As Boolean) As InstantPattern
        parameters:
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        - id: includeThousandsSeparators
          type: System.Boolean
          description: True to include thousands separators when parsing or formatting; false to omit them.
        return:
          type: NodaTime.Text.InstantPattern
          description: A numeric pattern for the configuration
      overload: NodaTime.Text.InstantPattern.CreateNumericPattern*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.InstantPattern.WithCulture(System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.InstantPattern.WithCulture(System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: WithCulture(CultureInfo)
        VB: WithCulture(CultureInfo)
      nameWithType:
        CSharp: InstantPattern.WithCulture(CultureInfo)
        VB: InstantPattern.WithCulture(CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.WithCulture(System.Globalization.CultureInfo)
        VB: NodaTime.Text.InstantPattern.WithCulture(System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCulture
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 227
      summary: "\nCreates a pattern for the same original pattern text as this pattern, but with the specified\nculture.\n"
      example: []
      syntax:
        content:
          CSharp: public InstantPattern WithCulture(CultureInfo cultureInfo)
          VB: Public Function WithCulture(cultureInfo As CultureInfo) As InstantPattern
        parameters:
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the new pattern.
        return:
          type: NodaTime.Text.InstantPattern
          description: A new pattern with the given culture.
      overload: NodaTime.Text.InstantPattern.WithCulture*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.InstantPattern.WithMinMaxLabels(System.String,System.String)
      commentId: M:NodaTime.Text.InstantPattern.WithMinMaxLabels(System.String,System.String)
      language: CSharp
      name:
        CSharp: WithMinMaxLabels(String, String)
        VB: WithMinMaxLabels(String, String)
      nameWithType:
        CSharp: InstantPattern.WithMinMaxLabels(String, String)
        VB: InstantPattern.WithMinMaxLabels(String, String)
      qualifiedName:
        CSharp: NodaTime.Text.InstantPattern.WithMinMaxLabels(System.String, System.String)
        VB: NodaTime.Text.InstantPattern.WithMinMaxLabels(System.String, System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InstantPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithMinMaxLabels
        path: src/NodaTime/Text/InstantPattern.cs
        startLine: 240
      summary: "\nCreates a new pattern for the same original pattern text and culture as this pattern, but\nwith the given min/max labels.\n"
      example: []
      syntax:
        content:
          CSharp: public InstantPattern WithMinMaxLabels(string minLabel, string maxLabel)
          VB: Public Function WithMinMaxLabels(minLabel As String, maxLabel As String) As InstantPattern
        parameters:
        - id: minLabel
          type: System.String
          description: Text to use for <xref href="NodaTime.Instant.MinValue" data-throw-if-not-resolved="false"></xref>. Must be non-empty, and not the same as <span class="paramref">maxLabel</span>.
        - id: maxLabel
          type: System.String
          description: Text to use for <xref href="NodaTime.Instant.MaxValue" data-throw-if-not-resolved="false"></xref>. Must be non-empty, and not the same as <span class="paramref">minLabel</span>
        return:
          type: NodaTime.Text.InstantPattern
          description: A new pattern with the given min/max labels.
      overload: NodaTime.Text.InstantPattern.WithMinMaxLabels*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Instant.MinValue: 
        NodaTime.Instant.MaxValue: 
    references:
      NodaTime.Instant: 
      System.Globalization.CultureInfo: 
  - id: NodaTime.Text.InvalidPatternException
    commentId: T:NodaTime.Text.InvalidPatternException
    language: CSharp
    name:
      CSharp: InvalidPatternException
      VB: InvalidPatternException
    nameWithType:
      CSharp: InvalidPatternException
      VB: InvalidPatternException
    qualifiedName:
      CSharp: NodaTime.Text.InvalidPatternException
      VB: NodaTime.Text.InvalidPatternException
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/InvalidPatternException.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: InvalidPatternException
      path: src/NodaTime/Text/InvalidPatternException.cs
      startLine: 20
    summary: "\nException thrown to indicate that the format pattern provided for either formatting or parsing is invalid.\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public sealed class InvalidPatternException : FormatException, ISerializable, _Exception
        VB: >-
          <Serializable>

          Public NotInheritable Class InvalidPatternException

              Inherits FormatException

              Implements ISerializable, _Exception
    inheritance:
    - System.Object
    - System.Exception
    - System.SystemException
    - System.FormatException
    implements:
    - System.Runtime.Serialization.ISerializable
    - System.Runtime.InteropServices._Exception
    inheritedMembers:
    - System.Exception.GetBaseException
    - System.Exception.ToString
    - System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    - System.Exception.GetType
    - System.Exception.Message
    - System.Exception.Data
    - System.Exception.InnerException
    - System.Exception.TargetSite
    - System.Exception.StackTrace
    - System.Exception.HelpLink
    - System.Exception.Source
    - System.Exception.HResult
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.MemberwiseClone
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.InvalidPatternException.#ctor
      commentId: M:NodaTime.Text.InvalidPatternException.#ctor
      language: CSharp
      name:
        CSharp: InvalidPatternException()
        VB: InvalidPatternException()
      nameWithType:
        CSharp: InvalidPatternException.InvalidPatternException()
        VB: InvalidPatternException.InvalidPatternException()
      qualifiedName:
        CSharp: NodaTime.Text.InvalidPatternException.InvalidPatternException()
        VB: NodaTime.Text.InvalidPatternException.InvalidPatternException()
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InvalidPatternException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/Text/InvalidPatternException.cs
        startLine: 27
      summary: "\nCreates a new InvalidPatternException with no message.\n"
      example: []
      syntax:
        content:
          CSharp: public InvalidPatternException()
          VB: Public Sub New
      overload: NodaTime.Text.InvalidPatternException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.InvalidPatternException.#ctor(System.String)
      commentId: M:NodaTime.Text.InvalidPatternException.#ctor(System.String)
      language: CSharp
      name:
        CSharp: InvalidPatternException(String)
        VB: InvalidPatternException(String)
      nameWithType:
        CSharp: InvalidPatternException.InvalidPatternException(String)
        VB: InvalidPatternException.InvalidPatternException(String)
      qualifiedName:
        CSharp: NodaTime.Text.InvalidPatternException.InvalidPatternException(System.String)
        VB: NodaTime.Text.InvalidPatternException.InvalidPatternException(System.String)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/InvalidPatternException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/Text/InvalidPatternException.cs
        startLine: 35
      summary: "\nCreates a new InvalidPatternException with the given message.\n"
      example: []
      syntax:
        content:
          CSharp: public InvalidPatternException(string message)
          VB: Public Sub New(message As String)
        parameters:
        - id: message
          type: System.String
          description: A message describing the nature of the failure
      overload: NodaTime.Text.InvalidPatternException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
  - id: NodaTime.Text.IPattern`1
    commentId: T:NodaTime.Text.IPattern`1
    language: CSharp
    name:
      CSharp: IPattern<T>
      VB: IPattern(Of T)
    nameWithType:
      CSharp: IPattern<T>
      VB: IPattern(Of T)
    qualifiedName:
      CSharp: NodaTime.Text.IPattern<T>
      VB: NodaTime.Text.IPattern(Of T)
    type: Interface
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/IPattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: IPattern
      path: src/NodaTime/Text/IPattern.cs
      startLine: 18
    summary: "\nGeneric interface supporting parsing and formatting. Parsing always results in a \n<xref href=\"NodaTime.Text.ParseResult%601\" data-throw-if-not-resolved=\"false\"></xref> which can represent success or failure.\n"
    remarks: "\nIdiomatic text handling in Noda Time involves creating a pattern once and reusing it multiple\ntimes, rather than specifying the pattern text repeatedly. All patterns are immutable and thread-safe,\nand include the culture used for localization purposes.\n"
    example: []
    syntax:
      content:
        CSharp: public interface IPattern<T>
        VB: Public Interface IPattern(Of T)
      typeParameters:
      - id: T
        description: Type of value to parse or format.
    modifiers:
      CSharp:
      - public
      - interface
      VB:
      - Public
      - Interface
    items:
    - id: NodaTime.Text.IPattern`1.Parse(System.String)
      commentId: M:NodaTime.Text.IPattern`1.Parse(System.String)
      language: CSharp
      name:
        CSharp: Parse(String)
        VB: Parse(String)
      nameWithType:
        CSharp: IPattern<T>.Parse(String)
        VB: IPattern(Of T).Parse(String)
      qualifiedName:
        CSharp: NodaTime.Text.IPattern<T>.Parse(System.String)
        VB: NodaTime.Text.IPattern(Of T).Parse(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/IPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Parse
        path: src/NodaTime/Text/IPattern.cs
        startLine: 29
      summary: "\nParses the given text value according to the rules of this pattern.\n"
      remarks: "\nThis method never throws an exception (barring a bug in Noda Time itself). Even errors such as\nthe argument being null are wrapped in a parse result.\n"
      example: []
      syntax:
        content:
          CSharp: ParseResult<T> Parse(string text)
          VB: Function Parse(text As String) As ParseResult(Of T)
        parameters:
        - id: text
          type: System.String
          description: The text value to parse.
        return:
          type: NodaTime.Text.ParseResult{{T}}
          description: The result of parsing, which may be successful or unsuccessful.
      overload: NodaTime.Text.IPattern`1.Parse*
      modifiers:
        CSharp: []
        VB: []
    - id: NodaTime.Text.IPattern`1.Format(`0)
      commentId: M:NodaTime.Text.IPattern`1.Format(`0)
      language: CSharp
      name:
        CSharp: Format(T)
        VB: Format(T)
      nameWithType:
        CSharp: IPattern<T>.Format(T)
        VB: IPattern(Of T).Format(T)
      qualifiedName:
        CSharp: NodaTime.Text.IPattern<T>.Format(T)
        VB: NodaTime.Text.IPattern(Of T).Format(T)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/IPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Format
        path: src/NodaTime/Text/IPattern.cs
        startLine: 36
      summary: "\nFormats the given value as text according to the rules of this pattern.\n"
      example: []
      syntax:
        content:
          CSharp: string Format(T value)
          VB: Function Format(value As T) As String
        parameters:
        - id: value
          type: '{T}'
          description: The value to format.
        return:
          type: System.String
          description: The value formatted according to this pattern.
      overload: NodaTime.Text.IPattern`1.Format*
      modifiers:
        CSharp: []
        VB: []
    references:
      NodaTime.Text.ParseResult`1: 
  - id: NodaTime.Text.LocalDatePattern
    commentId: T:NodaTime.Text.LocalDatePattern
    language: CSharp
    name:
      CSharp: LocalDatePattern
      VB: LocalDatePattern
    nameWithType:
      CSharp: LocalDatePattern
      VB: LocalDatePattern
    qualifiedName:
      CSharp: NodaTime.Text.LocalDatePattern
      VB: NodaTime.Text.LocalDatePattern
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: LocalDatePattern
      path: src/NodaTime/Text/LocalDatePattern.cs
      startLine: 20
    summary: "\nRepresents a pattern for parsing and formatting <xref href=\"NodaTime.LocalDate\" data-throw-if-not-resolved=\"false\"></xref> values.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class LocalDatePattern : IPattern<LocalDate>'
        VB: >-
          Public NotInheritable Class LocalDatePattern

              Implements IPattern(Of LocalDate)
    inheritance:
    - System.Object
    implements:
    - NodaTime.Text.IPattern{NodaTime.LocalDate}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.LocalDatePattern.IsoPattern
      commentId: P:NodaTime.Text.LocalDatePattern.IsoPattern
      language: CSharp
      name:
        CSharp: IsoPattern
        VB: IsoPattern
      nameWithType:
        CSharp: LocalDatePattern.IsoPattern
        VB: LocalDatePattern.IsoPattern
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.IsoPattern
        VB: NodaTime.Text.LocalDatePattern.IsoPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: IsoPattern
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 33
      summary: "\nReturns an invariant local date pattern which is ISO-8601 compatible.\nThis corresponds to the text pattern \"yyyy'-'MM'-'dd\".\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDatePattern IsoPattern { get; }
          VB: Public Shared ReadOnly Property IsoPattern As LocalDatePattern
        parameters: []
        return:
          type: NodaTime.Text.LocalDatePattern
      overload: NodaTime.Text.LocalDatePattern.IsoPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.LocalDatePattern.PatternText
      commentId: P:NodaTime.Text.LocalDatePattern.PatternText
      language: CSharp
      name:
        CSharp: PatternText
        VB: PatternText
      nameWithType:
        CSharp: LocalDatePattern.PatternText
        VB: LocalDatePattern.PatternText
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.PatternText
        VB: NodaTime.Text.LocalDatePattern.PatternText
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PatternText
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 52
      summary: "\nReturns the pattern text for this pattern, as supplied on creation.\n"
      example: []
      syntax:
        content:
          CSharp: public string PatternText { get; }
          VB: Public ReadOnly Property PatternText As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.Text.LocalDatePattern.PatternText*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.LocalDatePattern.TemplateValue
      commentId: P:NodaTime.Text.LocalDatePattern.TemplateValue
      language: CSharp
      name:
        CSharp: TemplateValue
        VB: TemplateValue
      nameWithType:
        CSharp: LocalDatePattern.TemplateValue
        VB: LocalDatePattern.TemplateValue
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.TemplateValue
        VB: NodaTime.Text.LocalDatePattern.TemplateValue
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TemplateValue
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 63
      summary: "\nReturns the value used as a template for parsing: any field values unspecified\nin the pattern are taken from the template.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDate TemplateValue { get; }
          VB: Public ReadOnly Property TemplateValue As LocalDate
        parameters: []
        return:
          type: NodaTime.LocalDate
      overload: NodaTime.Text.LocalDatePattern.TemplateValue*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.LocalDatePattern.Parse(System.String)
      commentId: M:NodaTime.Text.LocalDatePattern.Parse(System.String)
      language: CSharp
      name:
        CSharp: Parse(String)
        VB: Parse(String)
      nameWithType:
        CSharp: LocalDatePattern.Parse(String)
        VB: LocalDatePattern.Parse(String)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.Parse(System.String)
        VB: NodaTime.Text.LocalDatePattern.Parse(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Parse
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 83
      summary: "\nParses the given text value according to the rules of this pattern.\n"
      remarks: "\nThis method never throws an exception (barring a bug in Noda Time itself). Even errors such as\nthe argument being null are wrapped in a parse result.\n"
      example: []
      syntax:
        content:
          CSharp: public ParseResult<LocalDate> Parse(string text)
          VB: Public Function Parse(text As String) As ParseResult(Of LocalDate)
        parameters:
        - id: text
          type: System.String
          description: The text value to parse.
        return:
          type: NodaTime.Text.ParseResult{NodaTime.LocalDate}
          description: The result of parsing, which may be successful or unsuccessful.
      overload: NodaTime.Text.LocalDatePattern.Parse*
      implements:
      - NodaTime.Text.IPattern{NodaTime.LocalDate}.Parse(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.LocalDatePattern.Format(NodaTime.LocalDate)
      commentId: M:NodaTime.Text.LocalDatePattern.Format(NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: Format(LocalDate)
        VB: Format(LocalDate)
      nameWithType:
        CSharp: LocalDatePattern.Format(LocalDate)
        VB: LocalDatePattern.Format(LocalDate)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.Format(NodaTime.LocalDate)
        VB: NodaTime.Text.LocalDatePattern.Format(NodaTime.LocalDate)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Format
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 93
      summary: "\nFormats the given local date as text according to the rules of this pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string Format(LocalDate value)
          VB: Public Function Format(value As LocalDate) As String
        parameters:
        - id: value
          type: NodaTime.LocalDate
          description: The local date to format.
        return:
          type: System.String
          description: The local date formatted according to this pattern.
      overload: NodaTime.Text.LocalDatePattern.Format*
      implements:
      - NodaTime.Text.IPattern{NodaTime.LocalDate}.Format(NodaTime.LocalDate)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.LocalDatePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalDate)
      commentId: M:NodaTime.Text.LocalDatePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo, LocalDate)
        VB: Create(String, CultureInfo, LocalDate)
      nameWithType:
        CSharp: LocalDatePattern.Create(String, CultureInfo, LocalDate)
        VB: LocalDatePattern.Create(String, CultureInfo, LocalDate)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.Create(System.String, System.Globalization.CultureInfo, NodaTime.LocalDate)
        VB: NodaTime.Text.LocalDatePattern.Create(System.String, System.Globalization.CultureInfo, NodaTime.LocalDate)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 128
      summary: "\nCreates a pattern for the given pattern text, culture, and template value.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDatePattern Create(string patternText, CultureInfo cultureInfo, LocalDate templateValue)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo, templateValue As LocalDate) As LocalDatePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        - id: templateValue
          type: NodaTime.LocalDate
          description: Template value to use for unspecified fields
        return:
          type: NodaTime.Text.LocalDatePattern
          description: A pattern for parsing and formatting local dates.
      overload: NodaTime.Text.LocalDatePattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalDatePattern.Create(System.String,System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.LocalDatePattern.Create(System.String,System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo)
        VB: Create(String, CultureInfo)
      nameWithType:
        CSharp: LocalDatePattern.Create(String, CultureInfo)
        VB: LocalDatePattern.Create(String, CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.Create(System.String, System.Globalization.CultureInfo)
        VB: NodaTime.Text.LocalDatePattern.Create(System.String, System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 143
      summary: "\nCreates a pattern for the given pattern text and culture, with a template value of 2000-01-01.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDatePattern Create(string patternText, CultureInfo cultureInfo)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo) As LocalDatePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        return:
          type: NodaTime.Text.LocalDatePattern
          description: A pattern for parsing and formatting local dates.
      overload: NodaTime.Text.LocalDatePattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture(System.String)
      commentId: M:NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithCurrentCulture(String)
        VB: CreateWithCurrentCulture(String)
      nameWithType:
        CSharp: LocalDatePattern.CreateWithCurrentCulture(String)
        VB: LocalDatePattern.CreateWithCurrentCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture(System.String)
        VB: NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithCurrentCulture
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 159
      summary: "\nCreates a pattern for the given pattern text in the current thread's current culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDatePattern CreateWithCurrentCulture(string patternText)
          VB: Public Shared Function CreateWithCurrentCulture(patternText As String) As LocalDatePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.LocalDatePattern
          description: A pattern for parsing and formatting local dates.
      overload: NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture(System.String)
      commentId: M:NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithInvariantCulture(String)
        VB: CreateWithInvariantCulture(String)
      nameWithType:
        CSharp: LocalDatePattern.CreateWithInvariantCulture(String)
        VB: LocalDatePattern.CreateWithInvariantCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture(System.String)
        VB: NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithInvariantCulture
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 175
      summary: "\nCreates a pattern for the given pattern text in the invariant culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDatePattern CreateWithInvariantCulture(string patternText)
          VB: Public Shared Function CreateWithInvariantCulture(patternText As String) As LocalDatePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.LocalDatePattern
          description: A pattern for parsing and formatting local dates.
      overload: NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalDatePattern.WithCulture(System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.LocalDatePattern.WithCulture(System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: WithCulture(CultureInfo)
        VB: WithCulture(CultureInfo)
      nameWithType:
        CSharp: LocalDatePattern.WithCulture(CultureInfo)
        VB: LocalDatePattern.WithCulture(CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.WithCulture(System.Globalization.CultureInfo)
        VB: NodaTime.Text.LocalDatePattern.WithCulture(System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCulture
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 197
      summary: "\nCreates a pattern for the same original pattern text as this pattern, but with the specified\nculture.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDatePattern WithCulture(CultureInfo cultureInfo)
          VB: Public Function WithCulture(cultureInfo As CultureInfo) As LocalDatePattern
        parameters:
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the new pattern.
        return:
          type: NodaTime.Text.LocalDatePattern
          description: A new pattern with the given culture.
      overload: NodaTime.Text.LocalDatePattern.WithCulture*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.LocalDatePattern.WithTemplateValue(NodaTime.LocalDate)
      commentId: M:NodaTime.Text.LocalDatePattern.WithTemplateValue(NodaTime.LocalDate)
      language: CSharp
      name:
        CSharp: WithTemplateValue(LocalDate)
        VB: WithTemplateValue(LocalDate)
      nameWithType:
        CSharp: LocalDatePattern.WithTemplateValue(LocalDate)
        VB: LocalDatePattern.WithTemplateValue(LocalDate)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDatePattern.WithTemplateValue(NodaTime.LocalDate)
        VB: NodaTime.Text.LocalDatePattern.WithTemplateValue(NodaTime.LocalDate)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDatePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithTemplateValue
        path: src/NodaTime/Text/LocalDatePattern.cs
        startLine: 207
      summary: "\nCreates a pattern like this one, but with the specified template value.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDatePattern WithTemplateValue(LocalDate newTemplateValue)
          VB: Public Function WithTemplateValue(newTemplateValue As LocalDate) As LocalDatePattern
        parameters:
        - id: newTemplateValue
          type: NodaTime.LocalDate
          description: The template value for the new pattern, used to fill in unspecified fields.
        return:
          type: NodaTime.Text.LocalDatePattern
          description: A new pattern with the given template value.
      overload: NodaTime.Text.LocalDatePattern.WithTemplateValue*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.LocalDate: 
      System.Globalization.CultureInfo: 
  - id: NodaTime.Text.LocalDateTimePattern
    commentId: T:NodaTime.Text.LocalDateTimePattern
    language: CSharp
    name:
      CSharp: LocalDateTimePattern
      VB: LocalDateTimePattern
    nameWithType:
      CSharp: LocalDateTimePattern
      VB: LocalDateTimePattern
    qualifiedName:
      CSharp: NodaTime.Text.LocalDateTimePattern
      VB: NodaTime.Text.LocalDateTimePattern
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: LocalDateTimePattern
      path: src/NodaTime/Text/LocalDateTimePattern.cs
      startLine: 20
    summary: "\nRepresents a pattern for parsing and formatting <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> values.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class LocalDateTimePattern : IPattern<LocalDateTime>'
        VB: >-
          Public NotInheritable Class LocalDateTimePattern

              Implements IPattern(Of LocalDateTime)
    inheritance:
    - System.Object
    implements:
    - NodaTime.Text.IPattern{NodaTime.LocalDateTime}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern
      commentId: P:NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern
      language: CSharp
      name:
        CSharp: GeneralIsoPattern
        VB: GeneralIsoPattern
      nameWithType:
        CSharp: LocalDateTimePattern.GeneralIsoPattern
        VB: LocalDateTimePattern.GeneralIsoPattern
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern
        VB: NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GeneralIsoPattern
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 34
      summary: "\nReturns an invariant local date/time pattern which is ISO-8601 compatible, down to the second.\nThis corresponds to the text pattern \"yyyy'-'MM'-'dd'T'HH':'mm':'ss\", and is also used as the \"sortable\"\nstandard pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTimePattern GeneralIsoPattern { get; }
          VB: Public Shared ReadOnly Property GeneralIsoPattern As LocalDateTimePattern
        parameters: []
        return:
          type: NodaTime.Text.LocalDateTimePattern
      overload: NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern
      commentId: P:NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern
      language: CSharp
      name:
        CSharp: ExtendedIsoPattern
        VB: ExtendedIsoPattern
      nameWithType:
        CSharp: LocalDateTimePattern.ExtendedIsoPattern
        VB: LocalDateTimePattern.ExtendedIsoPattern
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern
        VB: NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ExtendedIsoPattern
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 41
      summary: "\nReturns an invariant local date/time pattern which is ISO-8601 compatible, providing up to 7 decimal places\nof sub-second accuracy. (These digits are omitted when unnecessary.)\nThis corresponds to the text pattern \"yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF\".\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTimePattern ExtendedIsoPattern { get; }
          VB: Public Shared ReadOnly Property ExtendedIsoPattern As LocalDateTimePattern
        parameters: []
        return:
          type: NodaTime.Text.LocalDateTimePattern
      overload: NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern
      commentId: P:NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern
      language: CSharp
      name:
        CSharp: BclRoundtripPattern
        VB: BclRoundtripPattern
      nameWithType:
        CSharp: LocalDateTimePattern.BclRoundtripPattern
        VB: LocalDateTimePattern.BclRoundtripPattern
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern
        VB: NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: BclRoundtripPattern
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 49
      summary: "\nReturns an invariant local date/time pattern which is ISO-8601 compatible, providing up to 7 decimal places\nof sub-second accuracy which are always present (including trailing zeroes). This is compatible with the\nBCL round-trip formatting of <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> values with a kind of \"unspecified\".\nThis corresponds to the text pattern \"yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffff\".\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTimePattern BclRoundtripPattern { get; }
          VB: Public Shared ReadOnly Property BclRoundtripPattern As LocalDateTimePattern
        parameters: []
        return:
          type: NodaTime.Text.LocalDateTimePattern
      overload: NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        System.DateTime: 
    - id: NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern
      commentId: P:NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern
      language: CSharp
      name:
        CSharp: FullRoundtripPattern
        VB: FullRoundtripPattern
      nameWithType:
        CSharp: LocalDateTimePattern.FullRoundtripPattern
        VB: LocalDateTimePattern.FullRoundtripPattern
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern
        VB: NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FullRoundtripPattern
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 55
      summary: "\nReturns an invariant local date/time pattern which round trips values including the calendar system.\nThis corresponds to the text pattern \"yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffff '('c')'\".\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTimePattern FullRoundtripPattern { get; }
          VB: Public Shared ReadOnly Property FullRoundtripPattern As LocalDateTimePattern
        parameters: []
        return:
          type: NodaTime.Text.LocalDateTimePattern
      overload: NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.LocalDateTimePattern.PatternText
      commentId: P:NodaTime.Text.LocalDateTimePattern.PatternText
      language: CSharp
      name:
        CSharp: PatternText
        VB: PatternText
      nameWithType:
        CSharp: LocalDateTimePattern.PatternText
        VB: LocalDateTimePattern.PatternText
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.PatternText
        VB: NodaTime.Text.LocalDateTimePattern.PatternText
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PatternText
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 77
      summary: "\nReturns the pattern text for this pattern, as supplied on creation.\n"
      example: []
      syntax:
        content:
          CSharp: public string PatternText { get; }
          VB: Public ReadOnly Property PatternText As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.Text.LocalDateTimePattern.PatternText*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.LocalDateTimePattern.TemplateValue
      commentId: P:NodaTime.Text.LocalDateTimePattern.TemplateValue
      language: CSharp
      name:
        CSharp: TemplateValue
        VB: TemplateValue
      nameWithType:
        CSharp: LocalDateTimePattern.TemplateValue
        VB: LocalDateTimePattern.TemplateValue
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.TemplateValue
        VB: NodaTime.Text.LocalDateTimePattern.TemplateValue
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TemplateValue
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 88
      summary: "\nReturns the value used as a template for parsing: any field values unspecified\nin the pattern are taken from the template.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime TemplateValue { get; }
          VB: Public ReadOnly Property TemplateValue As LocalDateTime
        parameters: []
        return:
          type: NodaTime.LocalDateTime
      overload: NodaTime.Text.LocalDateTimePattern.TemplateValue*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.LocalDateTimePattern.Parse(System.String)
      commentId: M:NodaTime.Text.LocalDateTimePattern.Parse(System.String)
      language: CSharp
      name:
        CSharp: Parse(String)
        VB: Parse(String)
      nameWithType:
        CSharp: LocalDateTimePattern.Parse(String)
        VB: LocalDateTimePattern.Parse(String)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.Parse(System.String)
        VB: NodaTime.Text.LocalDateTimePattern.Parse(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Parse
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 108
      summary: "\nParses the given text value according to the rules of this pattern.\n"
      remarks: "\nThis method never throws an exception (barring a bug in Noda Time itself). Even errors such as\nthe argument being null are wrapped in a parse result.\n"
      example: []
      syntax:
        content:
          CSharp: public ParseResult<LocalDateTime> Parse(string text)
          VB: Public Function Parse(text As String) As ParseResult(Of LocalDateTime)
        parameters:
        - id: text
          type: System.String
          description: The text value to parse.
        return:
          type: NodaTime.Text.ParseResult{NodaTime.LocalDateTime}
          description: The result of parsing, which may be successful or unsuccessful.
      overload: NodaTime.Text.LocalDateTimePattern.Parse*
      implements:
      - NodaTime.Text.IPattern{NodaTime.LocalDateTime}.Parse(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.LocalDateTimePattern.Format(NodaTime.LocalDateTime)
      commentId: M:NodaTime.Text.LocalDateTimePattern.Format(NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: Format(LocalDateTime)
        VB: Format(LocalDateTime)
      nameWithType:
        CSharp: LocalDateTimePattern.Format(LocalDateTime)
        VB: LocalDateTimePattern.Format(LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.Format(NodaTime.LocalDateTime)
        VB: NodaTime.Text.LocalDateTimePattern.Format(NodaTime.LocalDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Format
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 118
      summary: "\nFormats the given local date/time as text according to the rules of this pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string Format(LocalDateTime value)
          VB: Public Function Format(value As LocalDateTime) As String
        parameters:
        - id: value
          type: NodaTime.LocalDateTime
          description: The local date/time to format.
        return:
          type: System.String
          description: The local date/time formatted according to this pattern.
      overload: NodaTime.Text.LocalDateTimePattern.Format*
      implements:
      - NodaTime.Text.IPattern{NodaTime.LocalDateTime}.Format(NodaTime.LocalDateTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.LocalDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalDateTime)
      commentId: M:NodaTime.Text.LocalDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo, LocalDateTime)
        VB: Create(String, CultureInfo, LocalDateTime)
      nameWithType:
        CSharp: LocalDateTimePattern.Create(String, CultureInfo, LocalDateTime)
        VB: LocalDateTimePattern.Create(String, CultureInfo, LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.Create(System.String, System.Globalization.CultureInfo, NodaTime.LocalDateTime)
        VB: NodaTime.Text.LocalDateTimePattern.Create(System.String, System.Globalization.CultureInfo, NodaTime.LocalDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 153
      summary: "\nCreates a pattern for the given pattern text, culture, and template value.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTimePattern Create(string patternText, CultureInfo cultureInfo, LocalDateTime templateValue)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo, templateValue As LocalDateTime) As LocalDateTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        - id: templateValue
          type: NodaTime.LocalDateTime
          description: Template value to use for unspecified fields
        return:
          type: NodaTime.Text.LocalDateTimePattern
          description: A pattern for parsing and formatting local date/times.
      overload: NodaTime.Text.LocalDateTimePattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalDateTimePattern.Create(System.String,System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.LocalDateTimePattern.Create(System.String,System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo)
        VB: Create(String, CultureInfo)
      nameWithType:
        CSharp: LocalDateTimePattern.Create(String, CultureInfo)
        VB: LocalDateTimePattern.Create(String, CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.Create(System.String, System.Globalization.CultureInfo)
        VB: NodaTime.Text.LocalDateTimePattern.Create(System.String, System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 168
      summary: "\nCreates a pattern for the given pattern text and culture, with a template value of midnight on 2000-01-01.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTimePattern Create(string patternText, CultureInfo cultureInfo)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo) As LocalDateTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        return:
          type: NodaTime.Text.LocalDateTimePattern
          description: A pattern for parsing and formatting local date/times.
      overload: NodaTime.Text.LocalDateTimePattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture(System.String)
      commentId: M:NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithCurrentCulture(String)
        VB: CreateWithCurrentCulture(String)
      nameWithType:
        CSharp: LocalDateTimePattern.CreateWithCurrentCulture(String)
        VB: LocalDateTimePattern.CreateWithCurrentCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture(System.String)
        VB: NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithCurrentCulture
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 184
      summary: "\nCreates a pattern for the given pattern text in the current thread's current culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTimePattern CreateWithCurrentCulture(string patternText)
          VB: Public Shared Function CreateWithCurrentCulture(patternText As String) As LocalDateTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.LocalDateTimePattern
          description: A pattern for parsing and formatting local date/times.
      overload: NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture(System.String)
      commentId: M:NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithInvariantCulture(String)
        VB: CreateWithInvariantCulture(String)
      nameWithType:
        CSharp: LocalDateTimePattern.CreateWithInvariantCulture(String)
        VB: LocalDateTimePattern.CreateWithInvariantCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture(System.String)
        VB: NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithInvariantCulture
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 200
      summary: "\nCreates a pattern for the given pattern text in the invariant culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalDateTimePattern CreateWithInvariantCulture(string patternText)
          VB: Public Shared Function CreateWithInvariantCulture(patternText As String) As LocalDateTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.LocalDateTimePattern
          description: A pattern for parsing and formatting local date/times.
      overload: NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalDateTimePattern.WithCulture(System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.LocalDateTimePattern.WithCulture(System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: WithCulture(CultureInfo)
        VB: WithCulture(CultureInfo)
      nameWithType:
        CSharp: LocalDateTimePattern.WithCulture(CultureInfo)
        VB: LocalDateTimePattern.WithCulture(CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.WithCulture(System.Globalization.CultureInfo)
        VB: NodaTime.Text.LocalDateTimePattern.WithCulture(System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCulture
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 222
      summary: "\nCreates a pattern for the same original pattern text as this pattern, but with the specified\nculture.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTimePattern WithCulture(CultureInfo cultureInfo)
          VB: Public Function WithCulture(cultureInfo As CultureInfo) As LocalDateTimePattern
        parameters:
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the new pattern.
        return:
          type: NodaTime.Text.LocalDateTimePattern
          description: A new pattern with the given culture.
      overload: NodaTime.Text.LocalDateTimePattern.WithCulture*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.LocalDateTimePattern.WithTemplateValue(NodaTime.LocalDateTime)
      commentId: M:NodaTime.Text.LocalDateTimePattern.WithTemplateValue(NodaTime.LocalDateTime)
      language: CSharp
      name:
        CSharp: WithTemplateValue(LocalDateTime)
        VB: WithTemplateValue(LocalDateTime)
      nameWithType:
        CSharp: LocalDateTimePattern.WithTemplateValue(LocalDateTime)
        VB: LocalDateTimePattern.WithTemplateValue(LocalDateTime)
      qualifiedName:
        CSharp: NodaTime.Text.LocalDateTimePattern.WithTemplateValue(NodaTime.LocalDateTime)
        VB: NodaTime.Text.LocalDateTimePattern.WithTemplateValue(NodaTime.LocalDateTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalDateTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithTemplateValue
        path: src/NodaTime/Text/LocalDateTimePattern.cs
        startLine: 232
      summary: "\nCreates a pattern like this one, but with the specified template value.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTimePattern WithTemplateValue(LocalDateTime newTemplateValue)
          VB: Public Function WithTemplateValue(newTemplateValue As LocalDateTime) As LocalDateTimePattern
        parameters:
        - id: newTemplateValue
          type: NodaTime.LocalDateTime
          description: The template value for the new pattern, used to fill in unspecified fields.
        return:
          type: NodaTime.Text.LocalDateTimePattern
          description: A new pattern with the given template value.
      overload: NodaTime.Text.LocalDateTimePattern.WithTemplateValue*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.LocalDateTime: 
      System.Globalization.CultureInfo: 
  - id: NodaTime.Text.LocalTimePattern
    commentId: T:NodaTime.Text.LocalTimePattern
    language: CSharp
    name:
      CSharp: LocalTimePattern
      VB: LocalTimePattern
    nameWithType:
      CSharp: LocalTimePattern
      VB: LocalTimePattern
    qualifiedName:
      CSharp: NodaTime.Text.LocalTimePattern
      VB: NodaTime.Text.LocalTimePattern
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: LocalTimePattern
      path: src/NodaTime/Text/LocalTimePattern.cs
      startLine: 20
    summary: "\nRepresents a pattern for parsing and formatting <xref href=\"NodaTime.LocalTime\" data-throw-if-not-resolved=\"false\"></xref> values.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class LocalTimePattern : IPattern<LocalTime>'
        VB: >-
          Public NotInheritable Class LocalTimePattern

              Implements IPattern(Of LocalTime)
    inheritance:
    - System.Object
    implements:
    - NodaTime.Text.IPattern{NodaTime.LocalTime}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.LocalTimePattern.ExtendedIsoPattern
      commentId: P:NodaTime.Text.LocalTimePattern.ExtendedIsoPattern
      language: CSharp
      name:
        CSharp: ExtendedIsoPattern
        VB: ExtendedIsoPattern
      nameWithType:
        CSharp: LocalTimePattern.ExtendedIsoPattern
        VB: LocalTimePattern.ExtendedIsoPattern
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.ExtendedIsoPattern
        VB: NodaTime.Text.LocalTimePattern.ExtendedIsoPattern
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ExtendedIsoPattern
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 27
      summary: "\nReturns an invariant local time pattern which is ISO-8601 compatible, providing up to 7 decimal places.\n(These digits are omitted when unnecessary.)\nThis corresponds to the text pattern \"HH':'mm':'ss;FFFFFFF\".\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTimePattern ExtendedIsoPattern { get; }
          VB: Public Shared ReadOnly Property ExtendedIsoPattern As LocalTimePattern
        parameters: []
        return:
          type: NodaTime.Text.LocalTimePattern
      overload: NodaTime.Text.LocalTimePattern.ExtendedIsoPattern*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.LocalTimePattern.PatternText
      commentId: P:NodaTime.Text.LocalTimePattern.PatternText
      language: CSharp
      name:
        CSharp: PatternText
        VB: PatternText
      nameWithType:
        CSharp: LocalTimePattern.PatternText
        VB: LocalTimePattern.PatternText
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.PatternText
        VB: NodaTime.Text.LocalTimePattern.PatternText
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PatternText
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 51
      summary: "\nReturns the pattern text for this pattern, as supplied on creation.\n"
      example: []
      syntax:
        content:
          CSharp: public string PatternText { get; }
          VB: Public ReadOnly Property PatternText As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.Text.LocalTimePattern.PatternText*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.LocalTimePattern.TemplateValue
      commentId: P:NodaTime.Text.LocalTimePattern.TemplateValue
      language: CSharp
      name:
        CSharp: TemplateValue
        VB: TemplateValue
      nameWithType:
        CSharp: LocalTimePattern.TemplateValue
        VB: LocalTimePattern.TemplateValue
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.TemplateValue
        VB: NodaTime.Text.LocalTimePattern.TemplateValue
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TemplateValue
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 62
      summary: "\nReturns the value used as a template for parsing: any field values unspecified\nin the pattern are taken from the template.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTime TemplateValue { get; }
          VB: Public ReadOnly Property TemplateValue As LocalTime
        parameters: []
        return:
          type: NodaTime.LocalTime
      overload: NodaTime.Text.LocalTimePattern.TemplateValue*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.LocalTimePattern.Parse(System.String)
      commentId: M:NodaTime.Text.LocalTimePattern.Parse(System.String)
      language: CSharp
      name:
        CSharp: Parse(String)
        VB: Parse(String)
      nameWithType:
        CSharp: LocalTimePattern.Parse(String)
        VB: LocalTimePattern.Parse(String)
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.Parse(System.String)
        VB: NodaTime.Text.LocalTimePattern.Parse(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Parse
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 81
      summary: "\nParses the given text value according to the rules of this pattern.\n"
      remarks: "\nThis method never throws an exception (barring a bug in Noda Time itself). Even errors such as\nthe argument being null are wrapped in a parse result.\n"
      example: []
      syntax:
        content:
          CSharp: public ParseResult<LocalTime> Parse(string text)
          VB: Public Function Parse(text As String) As ParseResult(Of LocalTime)
        parameters:
        - id: text
          type: System.String
          description: The text value to parse.
        return:
          type: NodaTime.Text.ParseResult{NodaTime.LocalTime}
          description: The result of parsing, which may be successful or unsuccessful.
      overload: NodaTime.Text.LocalTimePattern.Parse*
      implements:
      - NodaTime.Text.IPattern{NodaTime.LocalTime}.Parse(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.LocalTimePattern.Format(NodaTime.LocalTime)
      commentId: M:NodaTime.Text.LocalTimePattern.Format(NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: Format(LocalTime)
        VB: Format(LocalTime)
      nameWithType:
        CSharp: LocalTimePattern.Format(LocalTime)
        VB: LocalTimePattern.Format(LocalTime)
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.Format(NodaTime.LocalTime)
        VB: NodaTime.Text.LocalTimePattern.Format(NodaTime.LocalTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Format
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 91
      summary: "\nFormats the given local time as text according to the rules of this pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string Format(LocalTime value)
          VB: Public Function Format(value As LocalTime) As String
        parameters:
        - id: value
          type: NodaTime.LocalTime
          description: The local time to format.
        return:
          type: System.String
          description: The local time formatted according to this pattern.
      overload: NodaTime.Text.LocalTimePattern.Format*
      implements:
      - NodaTime.Text.IPattern{NodaTime.LocalTime}.Format(NodaTime.LocalTime)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.LocalTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalTime)
      commentId: M:NodaTime.Text.LocalTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo, LocalTime)
        VB: Create(String, CultureInfo, LocalTime)
      nameWithType:
        CSharp: LocalTimePattern.Create(String, CultureInfo, LocalTime)
        VB: LocalTimePattern.Create(String, CultureInfo, LocalTime)
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.Create(System.String, System.Globalization.CultureInfo, NodaTime.LocalTime)
        VB: NodaTime.Text.LocalTimePattern.Create(System.String, System.Globalization.CultureInfo, NodaTime.LocalTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 126
      summary: "\nCreates a pattern for the given pattern text, culture, and template value.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTimePattern Create(string patternText, CultureInfo cultureInfo, LocalTime templateValue)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo, templateValue As LocalTime) As LocalTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        - id: templateValue
          type: NodaTime.LocalTime
          description: Template value to use for unspecified fields
        return:
          type: NodaTime.Text.LocalTimePattern
          description: A pattern for parsing and formatting local times.
      overload: NodaTime.Text.LocalTimePattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalTimePattern.Create(System.String,System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.LocalTimePattern.Create(System.String,System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo)
        VB: Create(String, CultureInfo)
      nameWithType:
        CSharp: LocalTimePattern.Create(String, CultureInfo)
        VB: LocalTimePattern.Create(String, CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.Create(System.String, System.Globalization.CultureInfo)
        VB: NodaTime.Text.LocalTimePattern.Create(System.String, System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 141
      summary: "\nCreates a pattern for the given pattern text and culture, with a template value of midnight.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTimePattern Create(string patternText, CultureInfo cultureInfo)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo) As LocalTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        return:
          type: NodaTime.Text.LocalTimePattern
          description: A pattern for parsing and formatting local times.
      overload: NodaTime.Text.LocalTimePattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture(System.String)
      commentId: M:NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithCurrentCulture(String)
        VB: CreateWithCurrentCulture(String)
      nameWithType:
        CSharp: LocalTimePattern.CreateWithCurrentCulture(String)
        VB: LocalTimePattern.CreateWithCurrentCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture(System.String)
        VB: NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithCurrentCulture
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 157
      summary: "\nCreates a pattern for the given pattern text in the current thread's current culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTimePattern CreateWithCurrentCulture(string patternText)
          VB: Public Shared Function CreateWithCurrentCulture(patternText As String) As LocalTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.LocalTimePattern
          description: A pattern for parsing and formatting local times.
      overload: NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture(System.String)
      commentId: M:NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithInvariantCulture(String)
        VB: CreateWithInvariantCulture(String)
      nameWithType:
        CSharp: LocalTimePattern.CreateWithInvariantCulture(String)
        VB: LocalTimePattern.CreateWithInvariantCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture(System.String)
        VB: NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithInvariantCulture
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 173
      summary: "\nCreates a pattern for the given pattern text in the invariant culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static LocalTimePattern CreateWithInvariantCulture(string patternText)
          VB: Public Shared Function CreateWithInvariantCulture(patternText As String) As LocalTimePattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.LocalTimePattern
          description: A pattern for parsing and formatting local times.
      overload: NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.LocalTimePattern.WithCulture(System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.LocalTimePattern.WithCulture(System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: WithCulture(CultureInfo)
        VB: WithCulture(CultureInfo)
      nameWithType:
        CSharp: LocalTimePattern.WithCulture(CultureInfo)
        VB: LocalTimePattern.WithCulture(CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.WithCulture(System.Globalization.CultureInfo)
        VB: NodaTime.Text.LocalTimePattern.WithCulture(System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCulture
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 195
      summary: "\nCreates a pattern for the same original pattern text as this pattern, but with the specified\nculture.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTimePattern WithCulture(CultureInfo cultureInfo)
          VB: Public Function WithCulture(cultureInfo As CultureInfo) As LocalTimePattern
        parameters:
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the new pattern.
        return:
          type: NodaTime.Text.LocalTimePattern
          description: A new pattern with the given culture.
      overload: NodaTime.Text.LocalTimePattern.WithCulture*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.LocalTimePattern.WithTemplateValue(NodaTime.LocalTime)
      commentId: M:NodaTime.Text.LocalTimePattern.WithTemplateValue(NodaTime.LocalTime)
      language: CSharp
      name:
        CSharp: WithTemplateValue(LocalTime)
        VB: WithTemplateValue(LocalTime)
      nameWithType:
        CSharp: LocalTimePattern.WithTemplateValue(LocalTime)
        VB: LocalTimePattern.WithTemplateValue(LocalTime)
      qualifiedName:
        CSharp: NodaTime.Text.LocalTimePattern.WithTemplateValue(NodaTime.LocalTime)
        VB: NodaTime.Text.LocalTimePattern.WithTemplateValue(NodaTime.LocalTime)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/LocalTimePattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithTemplateValue
        path: src/NodaTime/Text/LocalTimePattern.cs
        startLine: 205
      summary: "\nCreates a pattern like this one, but with the specified template value.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalTimePattern WithTemplateValue(LocalTime newTemplateValue)
          VB: Public Function WithTemplateValue(newTemplateValue As LocalTime) As LocalTimePattern
        parameters:
        - id: newTemplateValue
          type: NodaTime.LocalTime
          description: The template value for the new pattern, used to fill in unspecified fields.
        return:
          type: NodaTime.Text.LocalTimePattern
          description: A new pattern with the given template value.
      overload: NodaTime.Text.LocalTimePattern.WithTemplateValue*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.LocalTime: 
      System.Globalization.CultureInfo: 
  - id: NodaTime.Text.OffsetPattern
    commentId: T:NodaTime.Text.OffsetPattern
    language: CSharp
    name:
      CSharp: OffsetPattern
      VB: OffsetPattern
    nameWithType:
      CSharp: OffsetPattern
      VB: OffsetPattern
    qualifiedName:
      CSharp: NodaTime.Text.OffsetPattern
      VB: NodaTime.Text.OffsetPattern
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/OffsetPattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: OffsetPattern
      path: src/NodaTime/Text/OffsetPattern.cs
      startLine: 19
    summary: "\nRepresents a pattern for parsing and formatting <xref href=\"NodaTime.Offset\" data-throw-if-not-resolved=\"false\"></xref> values.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class OffsetPattern : IPattern<Offset>'
        VB: >-
          Public NotInheritable Class OffsetPattern

              Implements IPattern(Of Offset)
    inheritance:
    - System.Object
    implements:
    - NodaTime.Text.IPattern{NodaTime.Offset}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.OffsetPattern.GeneralInvariantPattern
      commentId: F:NodaTime.Text.OffsetPattern.GeneralInvariantPattern
      language: CSharp
      name:
        CSharp: GeneralInvariantPattern
        VB: GeneralInvariantPattern
      nameWithType:
        CSharp: OffsetPattern.GeneralInvariantPattern
        VB: OffsetPattern.GeneralInvariantPattern
      qualifiedName:
        CSharp: NodaTime.Text.OffsetPattern.GeneralInvariantPattern
        VB: NodaTime.Text.OffsetPattern.GeneralInvariantPattern
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GeneralInvariantPattern
        path: src/NodaTime/Text/OffsetPattern.cs
        startLine: 24
      summary: "\nThe \"general\" offset pattern (e.g. +HH, +HH:mm, +HH:mm:ss, +HH:mm:ss.fff) for the invariant culture.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly OffsetPattern GeneralInvariantPattern
          VB: Public Shared ReadOnly GeneralInvariantPattern As OffsetPattern
        return:
          type: NodaTime.Text.OffsetPattern
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.OffsetPattern.GeneralInvariantPatternWithZ
      commentId: F:NodaTime.Text.OffsetPattern.GeneralInvariantPatternWithZ
      language: CSharp
      name:
        CSharp: GeneralInvariantPatternWithZ
        VB: GeneralInvariantPatternWithZ
      nameWithType:
        CSharp: OffsetPattern.GeneralInvariantPatternWithZ
        VB: OffsetPattern.GeneralInvariantPatternWithZ
      qualifiedName:
        CSharp: NodaTime.Text.OffsetPattern.GeneralInvariantPatternWithZ
        VB: NodaTime.Text.OffsetPattern.GeneralInvariantPatternWithZ
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GeneralInvariantPatternWithZ
        path: src/NodaTime/Text/OffsetPattern.cs
        startLine: 29
      summary: "\nThe \"general\" offset pattern (e.g. +HH, +HH:mm, +HH:mm:ss, +HH:mm:ss.fff) for the invariant culture,\nbut producing (and allowing) Z as a value for a zero offset.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly OffsetPattern GeneralInvariantPatternWithZ
          VB: Public Shared ReadOnly GeneralInvariantPatternWithZ As OffsetPattern
        return:
          type: NodaTime.Text.OffsetPattern
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.OffsetPattern.PatternText
      commentId: P:NodaTime.Text.OffsetPattern.PatternText
      language: CSharp
      name:
        CSharp: PatternText
        VB: PatternText
      nameWithType:
        CSharp: OffsetPattern.PatternText
        VB: OffsetPattern.PatternText
      qualifiedName:
        CSharp: NodaTime.Text.OffsetPattern.PatternText
        VB: NodaTime.Text.OffsetPattern.PatternText
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PatternText
        path: src/NodaTime/Text/OffsetPattern.cs
        startLine: 42
      summary: "\nReturns the pattern text for this pattern, as supplied on creation.\n"
      example: []
      syntax:
        content:
          CSharp: public string PatternText { get; }
          VB: Public ReadOnly Property PatternText As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.Text.OffsetPattern.PatternText*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.OffsetPattern.Parse(System.String)
      commentId: M:NodaTime.Text.OffsetPattern.Parse(System.String)
      language: CSharp
      name:
        CSharp: Parse(String)
        VB: Parse(String)
      nameWithType:
        CSharp: OffsetPattern.Parse(String)
        VB: OffsetPattern.Parse(String)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetPattern.Parse(System.String)
        VB: NodaTime.Text.OffsetPattern.Parse(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Parse
        path: src/NodaTime/Text/OffsetPattern.cs
        startLine: 71
      summary: "\nParses the given text value according to the rules of this pattern.\n"
      remarks: "\nThis method never throws an exception (barring a bug in Noda Time itself). Even errors such as\nthe argument being null are wrapped in a parse result.\n"
      example: []
      syntax:
        content:
          CSharp: public ParseResult<Offset> Parse(string text)
          VB: Public Function Parse(text As String) As ParseResult(Of Offset)
        parameters:
        - id: text
          type: System.String
          description: The text value to parse.
        return:
          type: NodaTime.Text.ParseResult{NodaTime.Offset}
          description: The result of parsing, which may be successful or unsuccessful.
      overload: NodaTime.Text.OffsetPattern.Parse*
      implements:
      - NodaTime.Text.IPattern{NodaTime.Offset}.Parse(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.OffsetPattern.Format(NodaTime.Offset)
      commentId: M:NodaTime.Text.OffsetPattern.Format(NodaTime.Offset)
      language: CSharp
      name:
        CSharp: Format(Offset)
        VB: Format(Offset)
      nameWithType:
        CSharp: OffsetPattern.Format(Offset)
        VB: OffsetPattern.Format(Offset)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetPattern.Format(NodaTime.Offset)
        VB: NodaTime.Text.OffsetPattern.Format(NodaTime.Offset)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Format
        path: src/NodaTime/Text/OffsetPattern.cs
        startLine: 81
      summary: "\nFormats the given offset as text according to the rules of this pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string Format(Offset value)
          VB: Public Function Format(value As Offset) As String
        parameters:
        - id: value
          type: NodaTime.Offset
          description: The offset to format.
        return:
          type: System.String
          description: The offset formatted according to this pattern.
      overload: NodaTime.Text.OffsetPattern.Format*
      implements:
      - NodaTime.Text.IPattern{NodaTime.Offset}.Format(NodaTime.Offset)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.OffsetPattern.Create(System.String,System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.OffsetPattern.Create(System.String,System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: Create(String, CultureInfo)
        VB: Create(String, CultureInfo)
      nameWithType:
        CSharp: OffsetPattern.Create(String, CultureInfo)
        VB: OffsetPattern.Create(String, CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetPattern.Create(System.String, System.Globalization.CultureInfo)
        VB: NodaTime.Text.OffsetPattern.Create(System.String, System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Create
        path: src/NodaTime/Text/OffsetPattern.cs
        startLine: 111
      summary: "\nCreates a pattern for the given pattern text and culture.\n"
      remarks: "\nSee the user guide for the available pattern text options.\n"
      example: []
      syntax:
        content:
          CSharp: public static OffsetPattern Create(string patternText, CultureInfo cultureInfo)
          VB: Public Shared Function Create(patternText As String, cultureInfo As CultureInfo) As OffsetPattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the pattern
        return:
          type: NodaTime.Text.OffsetPattern
          description: A pattern for parsing and formatting offsets.
      overload: NodaTime.Text.OffsetPattern.Create*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.OffsetPattern.CreateWithCurrentCulture(System.String)
      commentId: M:NodaTime.Text.OffsetPattern.CreateWithCurrentCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithCurrentCulture(String)
        VB: CreateWithCurrentCulture(String)
      nameWithType:
        CSharp: OffsetPattern.CreateWithCurrentCulture(String)
        VB: OffsetPattern.CreateWithCurrentCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetPattern.CreateWithCurrentCulture(System.String)
        VB: NodaTime.Text.OffsetPattern.CreateWithCurrentCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithCurrentCulture
        path: src/NodaTime/Text/OffsetPattern.cs
        startLine: 127
      summary: "\nCreates a pattern for the given pattern text in the current thread's current culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static OffsetPattern CreateWithCurrentCulture(string patternText)
          VB: Public Shared Function CreateWithCurrentCulture(patternText As String) As OffsetPattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.OffsetPattern
          description: A pattern for parsing and formatting offsets.
      overload: NodaTime.Text.OffsetPattern.CreateWithCurrentCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.OffsetPattern.CreateWithInvariantCulture(System.String)
      commentId: M:NodaTime.Text.OffsetPattern.CreateWithInvariantCulture(System.String)
      language: CSharp
      name:
        CSharp: CreateWithInvariantCulture(String)
        VB: CreateWithInvariantCulture(String)
      nameWithType:
        CSharp: OffsetPattern.CreateWithInvariantCulture(String)
        VB: OffsetPattern.CreateWithInvariantCulture(String)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetPattern.CreateWithInvariantCulture(System.String)
        VB: NodaTime.Text.OffsetPattern.CreateWithInvariantCulture(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateWithInvariantCulture
        path: src/NodaTime/Text/OffsetPattern.cs
        startLine: 143
      summary: "\nCreates a pattern for the given pattern text in the invariant culture.\n"
      remarks: "\nSee the user guide for the available pattern text options. Note that the current culture\nis captured at the time this method is called - it is not captured at the point of parsing\nor formatting values.\n"
      example: []
      syntax:
        content:
          CSharp: public static OffsetPattern CreateWithInvariantCulture(string patternText)
          VB: Public Shared Function CreateWithInvariantCulture(patternText As String) As OffsetPattern
        parameters:
        - id: patternText
          type: System.String
          description: Pattern text to create the pattern for
        return:
          type: NodaTime.Text.OffsetPattern
          description: A pattern for parsing and formatting offsets.
      overload: NodaTime.Text.OffsetPattern.CreateWithInvariantCulture*
      exceptions:
      - type: NodaTime.Text.InvalidPatternException
        commentId: T:NodaTime.Text.InvalidPatternException
        description: The pattern text was invalid.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.Text.OffsetPattern.WithCulture(System.Globalization.CultureInfo)
      commentId: M:NodaTime.Text.OffsetPattern.WithCulture(System.Globalization.CultureInfo)
      language: CSharp
      name:
        CSharp: WithCulture(CultureInfo)
        VB: WithCulture(CultureInfo)
      nameWithType:
        CSharp: OffsetPattern.WithCulture(CultureInfo)
        VB: OffsetPattern.WithCulture(CultureInfo)
      qualifiedName:
        CSharp: NodaTime.Text.OffsetPattern.WithCulture(System.Globalization.CultureInfo)
        VB: NodaTime.Text.OffsetPattern.WithCulture(System.Globalization.CultureInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/OffsetPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithCulture
        path: src/NodaTime/Text/OffsetPattern.cs
        startLine: 154
      summary: "\nCreates a pattern for the same original pattern text as this pattern, but with the specified\nculture.\n"
      example: []
      syntax:
        content:
          CSharp: public OffsetPattern WithCulture(CultureInfo cultureInfo)
          VB: Public Function WithCulture(cultureInfo As CultureInfo) As OffsetPattern
        parameters:
        - id: cultureInfo
          type: System.Globalization.CultureInfo
          description: The culture to use in the new pattern.
        return:
          type: NodaTime.Text.OffsetPattern
          description: A new pattern with the given culture.
      overload: NodaTime.Text.OffsetPattern.WithCulture*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.Offset: 
      System.Globalization.CultureInfo: 
  - id: NodaTime.Text.PeriodPattern
    commentId: T:NodaTime.Text.PeriodPattern
    language: CSharp
    name:
      CSharp: PeriodPattern
      VB: PeriodPattern
    nameWithType:
      CSharp: PeriodPattern
      VB: PeriodPattern
    qualifiedName:
      CSharp: NodaTime.Text.PeriodPattern
      VB: NodaTime.Text.PeriodPattern
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/PeriodPattern.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: PeriodPattern
      path: src/NodaTime/Text/PeriodPattern.cs
      startLine: 15
    summary: "\nRepresents a pattern for parsing and formatting <xref href=\"NodaTime.Period\" data-throw-if-not-resolved=\"false\"></xref> values.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class PeriodPattern : IPattern<Period>'
        VB: >-
          Public NotInheritable Class PeriodPattern

              Implements IPattern(Of Period)
    inheritance:
    - System.Object
    implements:
    - NodaTime.Text.IPattern{NodaTime.Period}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.PeriodPattern.RoundtripPattern
      commentId: F:NodaTime.Text.PeriodPattern.RoundtripPattern
      language: CSharp
      name:
        CSharp: RoundtripPattern
        VB: RoundtripPattern
      nameWithType:
        CSharp: PeriodPattern.RoundtripPattern
        VB: PeriodPattern.RoundtripPattern
      qualifiedName:
        CSharp: NodaTime.Text.PeriodPattern.RoundtripPattern
        VB: NodaTime.Text.PeriodPattern.RoundtripPattern
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/PeriodPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: RoundtripPattern
        path: src/NodaTime/Text/PeriodPattern.cs
        startLine: 24
      summary: "\nPattern which uses the normal ISO format for all the supported ISO\nfields, but extends the time part with \"s\" for milliseconds and \"t\" for ticks.\nNo normalization is carried out, and a period may contain weeks as well as years, months and days.\nEach element may also be negative, independently of other elements. This pattern round-trips its\nvalues: a parse/format cycle will produce an identical period, including units.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly PeriodPattern RoundtripPattern
          VB: Public Shared ReadOnly RoundtripPattern As PeriodPattern
        return:
          type: NodaTime.Text.PeriodPattern
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: NodaTime.Text.PeriodPattern.NormalizingIsoPattern
      commentId: F:NodaTime.Text.PeriodPattern.NormalizingIsoPattern
      language: CSharp
      name:
        CSharp: NormalizingIsoPattern
        VB: NormalizingIsoPattern
      nameWithType:
        CSharp: PeriodPattern.NormalizingIsoPattern
        VB: PeriodPattern.NormalizingIsoPattern
      qualifiedName:
        CSharp: NodaTime.Text.PeriodPattern.NormalizingIsoPattern
        VB: NodaTime.Text.PeriodPattern.NormalizingIsoPattern
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/PeriodPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: NormalizingIsoPattern
        path: src/NodaTime/Text/PeriodPattern.cs
        startLine: 38
      summary: "\nA \"normalizing\" pattern which abides by the ISO-8601 duration format as far as possible.\nWeeks are added to the number of days (after multiplying by 7). Time units are normalized\n(extending into days where necessary), and fractions of seconds are represented within the\nseconds part. Unlike ISO-8601, which pattern allows for negative values within a period.\n"
      remarks: "\nNote that normalizing the period when formatting will cause an <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref>\nif the period contains more than <xref href=\"System.Int64.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> ticks when the\ncombined weeks/days/time portions are considered. Such a period could never\nbe useful anyway, however.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly PeriodPattern NormalizingIsoPattern
          VB: Public Shared ReadOnly NormalizingIsoPattern As PeriodPattern
        return:
          type: NodaTime.Text.PeriodPattern
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        System.OverflowException: 
        System.Int64.MaxValue: 
    - id: NodaTime.Text.PeriodPattern.Parse(System.String)
      commentId: M:NodaTime.Text.PeriodPattern.Parse(System.String)
      language: CSharp
      name:
        CSharp: Parse(String)
        VB: Parse(String)
      nameWithType:
        CSharp: PeriodPattern.Parse(String)
        VB: PeriodPattern.Parse(String)
      qualifiedName:
        CSharp: NodaTime.Text.PeriodPattern.Parse(System.String)
        VB: NodaTime.Text.PeriodPattern.Parse(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/PeriodPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Parse
        path: src/NodaTime/Text/PeriodPattern.cs
        startLine: 56
      summary: "\nParses the given text value according to the rules of this pattern.\n"
      remarks: "\nThis method never throws an exception (barring a bug in Noda Time itself). Even errors such as\nthe argument being null are wrapped in a parse result.\n"
      example: []
      syntax:
        content:
          CSharp: public ParseResult<Period> Parse(string text)
          VB: Public Function Parse(text As String) As ParseResult(Of Period)
        parameters:
        - id: text
          type: System.String
          description: The text value to parse.
        return:
          type: NodaTime.Text.ParseResult{NodaTime.Period}
          description: The result of parsing, which may be successful or unsuccessful.
      overload: NodaTime.Text.PeriodPattern.Parse*
      implements:
      - NodaTime.Text.IPattern{NodaTime.Period}.Parse(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.PeriodPattern.Format(NodaTime.Period)
      commentId: M:NodaTime.Text.PeriodPattern.Format(NodaTime.Period)
      language: CSharp
      name:
        CSharp: Format(Period)
        VB: Format(Period)
      nameWithType:
        CSharp: PeriodPattern.Format(Period)
        VB: PeriodPattern.Format(Period)
      qualifiedName:
        CSharp: NodaTime.Text.PeriodPattern.Format(NodaTime.Period)
        VB: NodaTime.Text.PeriodPattern.Format(NodaTime.Period)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/PeriodPattern.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Format
        path: src/NodaTime/Text/PeriodPattern.cs
        startLine: 66
      summary: "\nFormats the given period as text according to the rules of this pattern.\n"
      example: []
      syntax:
        content:
          CSharp: public string Format(Period value)
          VB: Public Function Format(value As Period) As String
        parameters:
        - id: value
          type: NodaTime.Period
          description: The period to format.
        return:
          type: System.String
          description: The period formatted according to this pattern.
      overload: NodaTime.Text.PeriodPattern.Format*
      implements:
      - NodaTime.Text.IPattern{NodaTime.Period}.Format(NodaTime.Period)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.Period: 
  - id: NodaTime.Text.ParseResult`1
    commentId: T:NodaTime.Text.ParseResult`1
    language: CSharp
    name:
      CSharp: ParseResult<T>
      VB: ParseResult(Of T)
    nameWithType:
      CSharp: ParseResult<T>
      VB: ParseResult(Of T)
    qualifiedName:
      CSharp: NodaTime.Text.ParseResult<T>
      VB: NodaTime.Text.ParseResult(Of T)
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/ParseResult.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: ParseResult
      path: src/NodaTime/Text/ParseResult.cs
      startLine: 15
    summary: "\nThe result of a parse operation.\n"
    example: []
    syntax:
      content:
        CSharp: public sealed class ParseResult<T>
        VB: Public NotInheritable Class ParseResult(Of T)
      typeParameters:
      - id: T
        description: The type which was parsed, such as a <xref href="NodaTime.LocalDateTime" data-throw-if-not-resolved="false"></xref>.
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.ParseResult`1.Value
      commentId: P:NodaTime.Text.ParseResult`1.Value
      language: CSharp
      name:
        CSharp: Value
        VB: Value
      nameWithType:
        CSharp: ParseResult<T>.Value
        VB: ParseResult(Of T).Value
      qualifiedName:
        CSharp: NodaTime.Text.ParseResult<T>.Value
        VB: NodaTime.Text.ParseResult(Of T).Value
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ParseResult.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Value
        path: src/NodaTime/Text/ParseResult.cs
        startLine: 41
      summary: "\nReturns the value from the parse operation if it was successful, or throws an exception indicating the parse failure\notherwise.\n"
      remarks: "\nThis method is exactly equivalent to calling the <xref href=\"NodaTime.Text.ParseResult%601.GetValueOrThrow\" data-throw-if-not-resolved=\"false\"></xref> method, but is terser if the code is\nalready clear that it will throw if the parse failed.\n"
      example: []
      syntax:
        content:
          CSharp: public T Value { get; }
          VB: Public ReadOnly Property Value As T
        parameters: []
        return:
          type: '{T}'
          description: The result of the parsing operation if it was successful.
      overload: NodaTime.Text.ParseResult`1.Value*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.Text.ParseResult`1.GetValueOrThrow: 
    - id: NodaTime.Text.ParseResult`1.Exception
      commentId: P:NodaTime.Text.ParseResult`1.Exception
      language: CSharp
      name:
        CSharp: Exception
        VB: Exception
      nameWithType:
        CSharp: ParseResult<T>.Exception
        VB: ParseResult(Of T).Exception
      qualifiedName:
        CSharp: NodaTime.Text.ParseResult<T>.Exception
        VB: NodaTime.Text.ParseResult(Of T).Exception
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ParseResult.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Exception
        path: src/NodaTime/Text/ParseResult.cs
        startLine: 49
      summary: "\nReturns an exception indicating the cause of the parse failure.\n"
      remarks: This property is typically used to wrap parse failures in higher level exceptions.
      example: []
      syntax:
        content:
          CSharp: public Exception Exception { get; }
          VB: Public ReadOnly Property Exception As Exception
        parameters: []
        return:
          type: System.Exception
          description: The exception indicating the cause of the parse failure.
      overload: NodaTime.Text.ParseResult`1.Exception*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The parse operation succeeded.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.Text.ParseResult`1.GetValueOrThrow
      commentId: M:NodaTime.Text.ParseResult`1.GetValueOrThrow
      language: CSharp
      name:
        CSharp: GetValueOrThrow()
        VB: GetValueOrThrow()
      nameWithType:
        CSharp: ParseResult<T>.GetValueOrThrow()
        VB: ParseResult(Of T).GetValueOrThrow()
      qualifiedName:
        CSharp: NodaTime.Text.ParseResult<T>.GetValueOrThrow()
        VB: NodaTime.Text.ParseResult(Of T).GetValueOrThrow()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ParseResult.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetValueOrThrow
        path: src/NodaTime/Text/ParseResult.cs
        startLine: 70
      summary: "\nReturns the value from the parse operation if it was successful, or throws an exception indicating the parse failure\notherwise.\n"
      remarks: "\nThis method is exactly equivalent to fetching the <xref href=\"NodaTime.Text.ParseResult%601.Value\" data-throw-if-not-resolved=\"false\"></xref> property, but more explicit in terms of throwing\nan exception on failure.\n"
      example: []
      syntax:
        content:
          CSharp: public T GetValueOrThrow()
          VB: Public Function GetValueOrThrow As T
        return:
          type: '{T}'
          description: The result of the parsing operation if it was successful.
      overload: NodaTime.Text.ParseResult`1.GetValueOrThrow*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.Text.ParseResult`1.Value: 
    - id: NodaTime.Text.ParseResult`1.TryGetValue(`0,`0@)
      commentId: M:NodaTime.Text.ParseResult`1.TryGetValue(`0,`0@)
      language: CSharp
      name:
        CSharp: TryGetValue(T, out T)
        VB: TryGetValue(T, ByRef T)
      nameWithType:
        CSharp: ParseResult<T>.TryGetValue(T, out T)
        VB: ParseResult(Of T).TryGetValue(T, ByRef T)
      qualifiedName:
        CSharp: NodaTime.Text.ParseResult<T>.TryGetValue(T, out T)
        VB: NodaTime.Text.ParseResult(Of T).TryGetValue(T, ByRef T)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ParseResult.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TryGetValue
        path: src/NodaTime/Text/ParseResult.cs
        startLine: 86
      summary: "\nReturns the success value, and sets the out parameter to either\nthe specified failure value of T or the successful parse result value.\n"
      example: []
      syntax:
        content:
          CSharp: public bool TryGetValue(T failureValue, out T result)
          VB: Public Function TryGetValue(failureValue As T, ByRef result As T) As Boolean
        parameters:
        - id: failureValue
          type: '{T}'
          description: The "default" value to set in <span class="paramref">result</span> if parsing failed.
        - id: result
          type: '{T}'
          description: The parameter to store the parsed value in on success.
        return:
          type: System.Boolean
          description: True if this parse result was successful, or false otherwise.
      overload: NodaTime.Text.ParseResult`1.TryGetValue*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.ParseResult`1.Success
      commentId: P:NodaTime.Text.ParseResult`1.Success
      language: CSharp
      name:
        CSharp: Success
        VB: Success
      nameWithType:
        CSharp: ParseResult<T>.Success
        VB: ParseResult(Of T).Success
      qualifiedName:
        CSharp: NodaTime.Text.ParseResult<T>.Success
        VB: NodaTime.Text.ParseResult(Of T).Success
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/ParseResult.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Success
        path: src/NodaTime/Text/ParseResult.cs
        startLine: 99
      summary: "\nIndicates whether the parse operation was successful.\n"
      remarks: "\nThis returns True if and only if fetching the value with the <xref href=\"NodaTime.Text.ParseResult%601.Value\" data-throw-if-not-resolved=\"false\"></xref> property will return with no exception.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Success { get; }
          VB: Public ReadOnly Property Success As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: NodaTime.Text.ParseResult`1.Success*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.Text.ParseResult`1.Value: 
    references:
      NodaTime.LocalDateTime: 
  - id: NodaTime.Text.UnparsableValueException
    commentId: T:NodaTime.Text.UnparsableValueException
    language: CSharp
    name:
      CSharp: UnparsableValueException
      VB: UnparsableValueException
    nameWithType:
      CSharp: UnparsableValueException
      VB: UnparsableValueException
    qualifiedName:
      CSharp: NodaTime.Text.UnparsableValueException
      VB: NodaTime.Text.UnparsableValueException
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Text
    source:
      remote:
        path: 1.2.x/src/NodaTime/Text/UnparsableValueException.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: UnparsableValueException
      path: src/NodaTime/Text/UnparsableValueException.cs
      startLine: 18
    summary: "\nException thrown to indicate that the specified value could not be parsed.\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public sealed class UnparsableValueException : FormatException, ISerializable, _Exception
        VB: >-
          <Serializable>

          Public NotInheritable Class UnparsableValueException

              Inherits FormatException

              Implements ISerializable, _Exception
    inheritance:
    - System.Object
    - System.Exception
    - System.SystemException
    - System.FormatException
    implements:
    - System.Runtime.Serialization.ISerializable
    - System.Runtime.InteropServices._Exception
    inheritedMembers:
    - System.Exception.GetBaseException
    - System.Exception.ToString
    - System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    - System.Exception.GetType
    - System.Exception.Message
    - System.Exception.Data
    - System.Exception.InnerException
    - System.Exception.TargetSite
    - System.Exception.StackTrace
    - System.Exception.HelpLink
    - System.Exception.Source
    - System.Exception.HResult
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.MemberwiseClone
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Text.UnparsableValueException.#ctor
      commentId: M:NodaTime.Text.UnparsableValueException.#ctor
      language: CSharp
      name:
        CSharp: UnparsableValueException()
        VB: UnparsableValueException()
      nameWithType:
        CSharp: UnparsableValueException.UnparsableValueException()
        VB: UnparsableValueException.UnparsableValueException()
      qualifiedName:
        CSharp: NodaTime.Text.UnparsableValueException.UnparsableValueException()
        VB: NodaTime.Text.UnparsableValueException.UnparsableValueException()
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/UnparsableValueException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/Text/UnparsableValueException.cs
        startLine: 25
      summary: "\nCreates a new UnparsableValueException with no message.\n"
      example: []
      syntax:
        content:
          CSharp: public UnparsableValueException()
          VB: Public Sub New
      overload: NodaTime.Text.UnparsableValueException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Text.UnparsableValueException.#ctor(System.String)
      commentId: M:NodaTime.Text.UnparsableValueException.#ctor(System.String)
      language: CSharp
      name:
        CSharp: UnparsableValueException(String)
        VB: UnparsableValueException(String)
      nameWithType:
        CSharp: UnparsableValueException.UnparsableValueException(String)
        VB: UnparsableValueException.UnparsableValueException(String)
      qualifiedName:
        CSharp: NodaTime.Text.UnparsableValueException.UnparsableValueException(System.String)
        VB: NodaTime.Text.UnparsableValueException.UnparsableValueException(System.String)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.Text
      source:
        remote:
          path: 1.2.x/src/NodaTime/Text/UnparsableValueException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/Text/UnparsableValueException.cs
        startLine: 33
      summary: "\nCreates a new UnparsableValueException with the given message.\n"
      example: []
      syntax:
        content:
          CSharp: public UnparsableValueException(string message)
          VB: Public Sub New(message As String)
        parameters:
        - id: message
          type: System.String
          description: The failure message
      overload: NodaTime.Text.UnparsableValueException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
- id: NodaTime.TimeZones
  commentId: N:NodaTime.TimeZones
  language: CSharp
  name:
    CSharp: NodaTime.TimeZones
    VB: NodaTime.TimeZones
  nameWithType:
    CSharp: NodaTime.TimeZones
    VB: NodaTime.TimeZones
  qualifiedName:
    CSharp: NodaTime.TimeZones
    VB: NodaTime.TimeZones
  type: Namespace
  assemblies:
  - NodaTime
  modifiers: {}
  items:
  - id: NodaTime.TimeZones.BclDateTimeZone
    commentId: T:NodaTime.TimeZones.BclDateTimeZone
    language: CSharp
    name:
      CSharp: BclDateTimeZone
      VB: BclDateTimeZone
    nameWithType:
      CSharp: BclDateTimeZone
      VB: BclDateTimeZone
    qualifiedName:
      CSharp: NodaTime.TimeZones.BclDateTimeZone
      VB: NodaTime.TimeZones.BclDateTimeZone
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZone.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: BclDateTimeZone
      path: src/NodaTime/TimeZones/BclDateTimeZone.cs
      startLine: 20
    summary: "\nRepresentation of a time zone converted from a <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref> from the Base Class Library.\n"
    remarks: "\nNote that although this class implements <xref href=\"System.IEquatable%601\" data-throw-if-not-resolved=\"false\"></xref> by virtue of extending\n<xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref>, the implementation here will always throw <code>NotImplementedException</code> when asked\nto compare two different <code>BclDateTimeZone</code> instances.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class BclDateTimeZone : DateTimeZone, IEquatable<DateTimeZone>, IZoneIntervalMap'
        VB: >-
          Public NotInheritable Class BclDateTimeZone

              Inherits DateTimeZone

              Implements IEquatable(Of DateTimeZone), IZoneIntervalMap
    inheritance:
    - System.Object
    - NodaTime.DateTimeZone
    implements:
    - System.IEquatable{NodaTime.DateTimeZone}
    inheritedMembers:
    - NodaTime.DateTimeZone.Utc
    - NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)
    - NodaTime.DateTimeZone.Id
    - NodaTime.DateTimeZone.MinOffset
    - NodaTime.DateTimeZone.MaxOffset
    - NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)
    - NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)
    - NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)
    - NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)
    - NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)
    - NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)
    - NodaTime.DateTimeZone.ToString
    - NodaTime.DateTimeZone.Equals(System.Object)
    - NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)
    - NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant,NodaTime.Instant)
    - NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.BclDateTimeZone.OriginalZone
      commentId: P:NodaTime.TimeZones.BclDateTimeZone.OriginalZone
      language: CSharp
      name:
        CSharp: OriginalZone
        VB: OriginalZone
      nameWithType:
        CSharp: BclDateTimeZone.OriginalZone
        VB: BclDateTimeZone.OriginalZone
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZone.OriginalZone
        VB: NodaTime.TimeZones.BclDateTimeZone.OriginalZone
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: OriginalZone
        path: src/NodaTime/TimeZones/BclDateTimeZone.cs
        startLine: 41
      summary: "\nReturns the original <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref> from which this was created.\n"
      example: []
      syntax:
        content:
          CSharp: public TimeZoneInfo OriginalZone { get; }
          VB: Public ReadOnly Property OriginalZone As TimeZoneInfo
        parameters: []
        return:
          type: System.TimeZoneInfo
      overload: NodaTime.TimeZones.BclDateTimeZone.OriginalZone*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        System.TimeZoneInfo: 
    - id: NodaTime.TimeZones.BclDateTimeZone.DisplayName
      commentId: P:NodaTime.TimeZones.BclDateTimeZone.DisplayName
      language: CSharp
      name:
        CSharp: DisplayName
        VB: DisplayName
      nameWithType:
        CSharp: BclDateTimeZone.DisplayName
        VB: BclDateTimeZone.DisplayName
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZone.DisplayName
        VB: NodaTime.TimeZones.BclDateTimeZone.DisplayName
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: DisplayName
        path: src/NodaTime/TimeZones/BclDateTimeZone.cs
        startLine: 46
      summary: "\nReturns the display name associated with the time zone, as provided by the Base Class Library.\n"
      example: []
      syntax:
        content:
          CSharp: public string DisplayName { get; }
          VB: Public ReadOnly Property DisplayName As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.BclDateTimeZone.DisplayName*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval(NodaTime.Instant)
      commentId: M:NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval(NodaTime.Instant)
      language: CSharp
      name:
        CSharp: GetZoneInterval(Instant)
        VB: GetZoneInterval(Instant)
      nameWithType:
        CSharp: BclDateTimeZone.GetZoneInterval(Instant)
        VB: BclDateTimeZone.GetZoneInterval(Instant)
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval(NodaTime.Instant)
        VB: NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval(NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetZoneInterval
        path: src/NodaTime/TimeZones/BclDateTimeZone.cs
        startLine: 56
      example: []
      syntax:
        content:
          CSharp: public override ZoneInterval GetZoneInterval(Instant instant)
          VB: Public Overrides Function GetZoneInterval(instant As Instant) As ZoneInterval
        parameters:
        - id: instant
          type: NodaTime.Instant
        return:
          type: NodaTime.TimeZones.ZoneInterval
      overload: NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval*
      overridden: NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo(System.TimeZoneInfo)
      commentId: M:NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo(System.TimeZoneInfo)
      language: CSharp
      name:
        CSharp: FromTimeZoneInfo(TimeZoneInfo)
        VB: FromTimeZoneInfo(TimeZoneInfo)
      nameWithType:
        CSharp: BclDateTimeZone.FromTimeZoneInfo(TimeZoneInfo)
        VB: BclDateTimeZone.FromTimeZoneInfo(TimeZoneInfo)
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo(System.TimeZoneInfo)
        VB: NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo(System.TimeZoneInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromTimeZoneInfo
        path: src/NodaTime/TimeZones/BclDateTimeZone.cs
        startLine: 67
      summary: "\nCreates a new <xref href=\"NodaTime.TimeZones.BclDateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> from a <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref> from the Base Class Library.\n"
      example: []
      syntax:
        content:
          CSharp: public static BclDateTimeZone FromTimeZoneInfo(TimeZoneInfo bclZone)
          VB: Public Shared Function FromTimeZoneInfo(bclZone As TimeZoneInfo) As BclDateTimeZone
        parameters:
        - id: bclZone
          type: System.TimeZoneInfo
          description: The original time zone to take information from.
        return:
          type: NodaTime.TimeZones.BclDateTimeZone
          description: A <xref href="NodaTime.TimeZones.BclDateTimeZone" data-throw-if-not-resolved="false"></xref> wrapping the given <code>TimeZoneInfo</code>.
      overload: NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">bclZone</span> is null.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.TimeZones.BclDateTimeZone: 
        System.TimeZoneInfo: 
    - id: NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault
      commentId: M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault
      language: CSharp
      name:
        CSharp: ForSystemDefault()
        VB: ForSystemDefault()
      nameWithType:
        CSharp: BclDateTimeZone.ForSystemDefault()
        VB: BclDateTimeZone.ForSystemDefault()
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault()
        VB: NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ForSystemDefault
        path: src/NodaTime/TimeZones/BclDateTimeZone.cs
        startLine: 387
      summary: "\nReturns a time zone converted from the BCL representation of the system local time zone.\n"
      remarks: "\n<p>\nThis method is approximately equivalent to calling <xref href=\"NodaTime.IDateTimeZoneProvider.GetSystemDefault\" data-throw-if-not-resolved=\"false\"></xref> with\nan implementation that wraps <xref href=\"NodaTime.TimeZones.BclDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> (e.g.\n<xref href=\"NodaTime.DateTimeZoneProviders.Bcl\" data-throw-if-not-resolved=\"false\"></xref>), with the exception that it will succeed even if the current local\ntime zone was not one of the set of system time zones captured when the source was created (which, while\nhighly unlikely, might occur either because the local time zone is not a system time zone, or because the\nsystem time zones have themselves changed).\n</p>\n<p>\nThis method will retain a reference to the returned <code>BclDateTimeZone</code>, and will attempt to return it if\ncalled repeatedly (assuming that the local time zone has not changed) rather than creating a new instance,\nthough this behaviour is not guaranteed.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public static BclDateTimeZone ForSystemDefault()
          VB: Public Shared Function ForSystemDefault As BclDateTimeZone
        return:
          type: NodaTime.TimeZones.BclDateTimeZone
          description: >-
            A <xref href="NodaTime.TimeZones.BclDateTimeZone" data-throw-if-not-resolved="false"></xref> wrapping the "local" (system) time zone as returned by

            <xref href="System.TimeZoneInfo.Local" data-throw-if-not-resolved="false"></xref>.
      overload: NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.IDateTimeZoneProvider.GetSystemDefault: 
        NodaTime.TimeZones.BclDateTimeZoneSource: 
        NodaTime.DateTimeZoneProviders.Bcl: 
        NodaTime.TimeZones.BclDateTimeZone: 
        System.TimeZoneInfo.Local: 
    - id: NodaTime.TimeZones.BclDateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
      commentId: M:NodaTime.TimeZones.BclDateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: EqualsImpl(DateTimeZone)
        VB: EqualsImpl(DateTimeZone)
      nameWithType:
        CSharp: BclDateTimeZone.EqualsImpl(DateTimeZone)
        VB: BclDateTimeZone.EqualsImpl(DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
        VB: NodaTime.TimeZones.BclDateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: EqualsImpl
        path: src/NodaTime/TimeZones/BclDateTimeZone.cs
        startLine: 407
      remarks: "\nThis implementation always throws <code>NotImplementedException</code>.\n"
      example: []
      syntax:
        content:
          CSharp: protected override bool EqualsImpl(DateTimeZone zone)
          VB: Protected Overrides Function EqualsImpl(zone As DateTimeZone) As Boolean
        parameters:
        - id: zone
          type: NodaTime.DateTimeZone
        return:
          type: System.Boolean
      overload: NodaTime.TimeZones.BclDateTimeZone.EqualsImpl*
      overridden: NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
      exceptions:
      - type: System.NotImplementedException
        commentId: T:System.NotImplementedException
        description: Always.
      modifiers:
        CSharp:
        - protected
        - override
        VB:
        - Protected
        - Overrides
    - id: NodaTime.TimeZones.BclDateTimeZone.GetHashCode
      commentId: M:NodaTime.TimeZones.BclDateTimeZone.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: BclDateTimeZone.GetHashCode()
        VB: BclDateTimeZone.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZone.GetHashCode()
        VB: NodaTime.TimeZones.BclDateTimeZone.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/TimeZones/BclDateTimeZone.cs
        startLine: 413
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
      overload: NodaTime.TimeZones.BclDateTimeZone.GetHashCode*
      overridden: NodaTime.DateTimeZone.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    references:
      System.TimeZoneInfo: 
      System.IEquatable`1: 
      NodaTime.DateTimeZone: 
  - id: NodaTime.TimeZones.BclDateTimeZoneSource
    commentId: T:NodaTime.TimeZones.BclDateTimeZoneSource
    language: CSharp
    name:
      CSharp: BclDateTimeZoneSource
      VB: BclDateTimeZoneSource
    nameWithType:
      CSharp: BclDateTimeZoneSource
      VB: BclDateTimeZoneSource
    qualifiedName:
      CSharp: NodaTime.TimeZones.BclDateTimeZoneSource
      VB: NodaTime.TimeZones.BclDateTimeZoneSource
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: BclDateTimeZoneSource
      path: src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
      startLine: 25
    summary: "\nProvides an implementation of <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> that loads data from the BCL\n<xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref> class.\n"
    remarks: "\n<p>\nAll calls to <xref href=\"NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)\" data-throw-if-not-resolved=\"false\"></xref> return instances of <xref href=\"NodaTime.TimeZones.BclDateTimeZone\" data-throw-if-not-resolved=\"false\"></xref>, including for fixed-offset IDs\n(i.e. \"UTC\" and \"UTC+/-Offset\").\n</p>\n<p>\nThis class is not available in the PCL version.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class BclDateTimeZoneSource : IDateTimeZoneSource'
        VB: >-
          Public NotInheritable Class BclDateTimeZoneSource

              Implements IDateTimeZoneSource
    inheritance:
    - System.Object
    implements:
    - NodaTime.TimeZones.IDateTimeZoneSource
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.BclDateTimeZoneSource.GetIds
      commentId: M:NodaTime.TimeZones.BclDateTimeZoneSource.GetIds
      language: CSharp
      name:
        CSharp: GetIds()
        VB: GetIds()
      nameWithType:
        CSharp: BclDateTimeZoneSource.GetIds()
        VB: BclDateTimeZoneSource.GetIds()
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZoneSource.GetIds()
        VB: NodaTime.TimeZones.BclDateTimeZoneSource.GetIds()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetIds
        path: src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
        startLine: 31
      summary: "\nReturns the IDs of all system time zones.\n"
      example: []
      syntax:
        content:
          CSharp: public IEnumerable<string> GetIds()
          VB: Public Function GetIds As IEnumerable(Of String)
        return:
          type: System.Collections.Generic.IEnumerable{System.String}
          description: The IDs available from this source.
      overload: NodaTime.TimeZones.BclDateTimeZoneSource.GetIds*
      implements:
      - NodaTime.TimeZones.IDateTimeZoneSource.GetIds
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.TimeZones.BclDateTimeZoneSource.VersionId
      commentId: P:NodaTime.TimeZones.BclDateTimeZoneSource.VersionId
      language: CSharp
      name:
        CSharp: VersionId
        VB: VersionId
      nameWithType:
        CSharp: BclDateTimeZoneSource.VersionId
        VB: BclDateTimeZoneSource.VersionId
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZoneSource.VersionId
        VB: NodaTime.TimeZones.BclDateTimeZoneSource.VersionId
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: VersionId
        path: src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
        startLine: 75
      remarks: "\nThis source returns a string such as \"TimeZoneInfo: 3.5.0.0\" corresponding to the version of the assembly\ncontaining <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public string VersionId { get; }
          VB: Public ReadOnly Property VersionId As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.BclDateTimeZoneSource.VersionId*
      implements:
      - NodaTime.TimeZones.IDateTimeZoneSource.VersionId
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        System.TimeZoneInfo: 
    - isEii: true
      id: NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime#TimeZones#IDateTimeZoneSource#ForId(System.String)
      commentId: M:NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime#TimeZones#IDateTimeZoneSource#ForId(System.String)
      language: CSharp
      name:
        CSharp: IDateTimeZoneSource.ForId(String)
        VB: NodaTime.TimeZones.IDateTimeZoneSource.ForId(String)
      nameWithType:
        CSharp: BclDateTimeZoneSource.IDateTimeZoneSource.ForId(String)
        VB: BclDateTimeZoneSource.NodaTime.TimeZones.IDateTimeZoneSource.ForId(String)
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
        VB: NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: NodaTime.TimeZones.IDateTimeZoneSource.ForId
        path: src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
        startLine: 90
      summary: "\nCreates a new instance of <xref href=\"NodaTime.TimeZones.BclDateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> from the <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref> with the given\nID. The ID must be a known system time zone ID.\n"
      remarks: "\nThis method explicitly implements <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)\" data-throw-if-not-resolved=\"false\"></xref> by delegating to the\n<xref href=\"NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method which has a return type of <xref href=\"NodaTime.TimeZones.BclDateTimeZone\" data-throw-if-not-resolved=\"false\"></xref>, ensuring that all\nzones returned by this implementation are instances of <xref href=\"NodaTime.TimeZones.BclDateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> (rather than the built-in\nfixed offset zones).\n"
      example: []
      syntax:
        content:
          CSharp: DateTimeZone IDateTimeZoneSource.ForId(string id)
          VB: Function NodaTime.TimeZones.IDateTimeZoneSource.ForId(id As String) As DateTimeZone Implements IDateTimeZoneSource.ForId
        parameters:
        - id: id
          type: System.String
        return:
          type: NodaTime.DateTimeZone
      overload: NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime#TimeZones#IDateTimeZoneSource#ForId*
      implements:
      - NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
      modifiers:
        CSharp: []
        VB: []
      references:
        NodaTime.TimeZones.BclDateTimeZone: 
        System.TimeZoneInfo: 
        NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String): 
        NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String): 
    - id: NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)
      commentId: M:NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)
      language: CSharp
      name:
        CSharp: ForId(String)
        VB: ForId(String)
      nameWithType:
        CSharp: BclDateTimeZoneSource.ForId(String)
        VB: BclDateTimeZoneSource.ForId(String)
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)
        VB: NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ForId
        path: src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
        startLine: 102
      summary: "\nCreates a new instance of <xref href=\"NodaTime.TimeZones.BclDateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> from the <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref> with the given\nID. The ID must be a known system time zone ID.\n"
      example: []
      syntax:
        content:
          CSharp: public BclDateTimeZone ForId(string id)
          VB: Public Function ForId(id As String) As BclDateTimeZone
        parameters:
        - id: id
          type: System.String
          description: The ID of the system time zone to convert
        return:
          type: NodaTime.TimeZones.BclDateTimeZone
          description: The Noda Time representation of the given BCL time zone
      overload: NodaTime.TimeZones.BclDateTimeZoneSource.ForId*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: The given zone doesn't exist.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.TimeZones.BclDateTimeZone: 
        System.TimeZoneInfo: 
    - id: NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      commentId: M:NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      language: CSharp
      name:
        CSharp: MapTimeZoneId(TimeZoneInfo)
        VB: MapTimeZoneId(TimeZoneInfo)
      nameWithType:
        CSharp: BclDateTimeZoneSource.MapTimeZoneId(TimeZoneInfo)
        VB: BclDateTimeZoneSource.MapTimeZoneId(TimeZoneInfo)
      qualifiedName:
        CSharp: NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
        VB: NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MapTimeZoneId
        path: src/NodaTime/TimeZones/BclDateTimeZoneSource.cs
        startLine: 123
      summary: "\nMaps the BCL ID to \"our\" ID as an identity projection.\n"
      example: []
      syntax:
        content:
          CSharp: public string MapTimeZoneId(TimeZoneInfo timeZone)
          VB: Public Function MapTimeZoneId(timeZone As TimeZoneInfo) As String
        parameters:
        - id: timeZone
          type: System.TimeZoneInfo
          description: The BCL time zone, which must be a known system time zone.
        return:
          type: System.String
          description: "\nThe ID for the given BCL time zone for this source; that is, the value of the <code>Id</code> property of the\npassed-in <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      overload: NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId*
      implements:
      - NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.TimeZoneInfo: 
    references:
      NodaTime.TimeZones.IDateTimeZoneSource: 
      System.TimeZoneInfo: 
      NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String): 
      NodaTime.TimeZones.BclDateTimeZone: 
  - id: NodaTime.TimeZones.DateTimeZoneCache
    commentId: T:NodaTime.TimeZones.DateTimeZoneCache
    language: CSharp
    name:
      CSharp: DateTimeZoneCache
      VB: DateTimeZoneCache
    nameWithType:
      CSharp: DateTimeZoneCache
      VB: DateTimeZoneCache
    qualifiedName:
      CSharp: NodaTime.TimeZones.DateTimeZoneCache
      VB: NodaTime.TimeZones.DateTimeZoneCache
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/DateTimeZoneCache.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: DateTimeZoneCache
      path: src/NodaTime/TimeZones/DateTimeZoneCache.cs
      startLine: 23
    summary: "\nProvides an implementation of <xref href=\"NodaTime.IDateTimeZoneProvider\" data-throw-if-not-resolved=\"false\"></xref> that caches results from an\n<xref href=\"NodaTime.TimeZones.IDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    remarks: "\nThe process of loading or creating time zones may be an expensive operation. This class implements an\nunlimited-size non-expiring cache over a time zone source, and adapts an implementation of the\n<code>IDateTimeZoneSource</code> interface to an <code>IDateTimeZoneProvider</code>.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class DateTimeZoneCache : IDateTimeZoneProvider'
        VB: >-
          Public NotInheritable Class DateTimeZoneCache

              Implements IDateTimeZoneProvider
    seealso:
    - linkId: NodaTime.DateTimeZoneProviders
      commentId: T:NodaTime.DateTimeZoneProviders
    inheritance:
    - System.Object
    implements:
    - NodaTime.IDateTimeZoneProvider
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.DateTimeZoneCache.#ctor(NodaTime.TimeZones.IDateTimeZoneSource)
      commentId: M:NodaTime.TimeZones.DateTimeZoneCache.#ctor(NodaTime.TimeZones.IDateTimeZoneSource)
      language: CSharp
      name:
        CSharp: DateTimeZoneCache(IDateTimeZoneSource)
        VB: DateTimeZoneCache(IDateTimeZoneSource)
      nameWithType:
        CSharp: DateTimeZoneCache.DateTimeZoneCache(IDateTimeZoneSource)
        VB: DateTimeZoneCache.DateTimeZoneCache(IDateTimeZoneSource)
      qualifiedName:
        CSharp: NodaTime.TimeZones.DateTimeZoneCache.DateTimeZoneCache(NodaTime.TimeZones.IDateTimeZoneSource)
        VB: NodaTime.TimeZones.DateTimeZoneCache.DateTimeZoneCache(NodaTime.TimeZones.IDateTimeZoneSource)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/DateTimeZoneCache.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/TimeZones/DateTimeZoneCache.cs
        startLine: 42
      summary: "\nCreates a provider backed by the given <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      remarks: "\nNote that the source will never be consulted for requests for the fixed-offset timezones \"UTC\" and\n\"UTC+/-Offset\" (a standard implementation will be returned instead). This is true even if these IDs are\nadvertised by the source.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTimeZoneCache(IDateTimeZoneSource source)
          VB: Public Sub New(source As IDateTimeZoneSource)
        parameters:
        - id: source
          type: NodaTime.TimeZones.IDateTimeZoneSource
          description: The <xref href="NodaTime.TimeZones.IDateTimeZoneSource" data-throw-if-not-resolved="false"></xref> for this provider.
      overload: NodaTime.TimeZones.DateTimeZoneCache.#ctor*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">source</span> is null.
      - type: NodaTime.TimeZones.InvalidDateTimeZoneSourceException
        commentId: T:NodaTime.TimeZones.InvalidDateTimeZoneSourceException
        description: <span class="paramref">source</span> violates its contract.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.TimeZones.IDateTimeZoneSource: 
    - id: NodaTime.TimeZones.DateTimeZoneCache.VersionId
      commentId: P:NodaTime.TimeZones.DateTimeZoneCache.VersionId
      language: CSharp
      name:
        CSharp: VersionId
        VB: VersionId
      nameWithType:
        CSharp: DateTimeZoneCache.VersionId
        VB: DateTimeZoneCache.VersionId
      qualifiedName:
        CSharp: NodaTime.TimeZones.DateTimeZoneCache.VersionId
        VB: NodaTime.TimeZones.DateTimeZoneCache.VersionId
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/DateTimeZoneCache.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: VersionId
        path: src/NodaTime/TimeZones/DateTimeZoneCache.cs
        startLine: 73
      summary: "\nThe version ID of this provider. This is simply the <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource.VersionId\" data-throw-if-not-resolved=\"false\"></xref> returned by\nthe underlying source.\n"
      example: []
      syntax:
        content:
          CSharp: public string VersionId { get; }
          VB: Public ReadOnly Property VersionId As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.DateTimeZoneCache.VersionId*
      implements:
      - NodaTime.IDateTimeZoneProvider.VersionId
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.TimeZones.IDateTimeZoneSource.VersionId: 
    - id: NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault
      commentId: M:NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault
      language: CSharp
      name:
        CSharp: GetSystemDefault()
        VB: GetSystemDefault()
      nameWithType:
        CSharp: DateTimeZoneCache.GetSystemDefault()
        VB: DateTimeZoneCache.GetSystemDefault()
      qualifiedName:
        CSharp: NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault()
        VB: NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/DateTimeZoneCache.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetSystemDefault
        path: src/NodaTime/TimeZones/DateTimeZoneCache.cs
        startLine: 76
      example: []
      syntax:
        content:
          CSharp: public DateTimeZone GetSystemDefault()
          VB: Public Function GetSystemDefault As DateTimeZone
        return:
          type: NodaTime.DateTimeZone
      overload: NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault*
      implements:
      - NodaTime.IDateTimeZoneProvider.GetSystemDefault
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.TimeZones.DateTimeZoneCache.Ids
      commentId: P:NodaTime.TimeZones.DateTimeZoneCache.Ids
      language: CSharp
      name:
        CSharp: Ids
        VB: Ids
      nameWithType:
        CSharp: DateTimeZoneCache.Ids
        VB: DateTimeZoneCache.Ids
      qualifiedName:
        CSharp: NodaTime.TimeZones.DateTimeZoneCache.Ids
        VB: NodaTime.TimeZones.DateTimeZoneCache.Ids
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/DateTimeZoneCache.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Ids
        path: src/NodaTime/TimeZones/DateTimeZoneCache.cs
        startLine: 92
      example: []
      syntax:
        content:
          CSharp: public ReadOnlyCollection<string> Ids { get; }
          VB: Public ReadOnly Property Ids As ReadOnlyCollection(Of String)
        parameters: []
        return:
          type: System.Collections.ObjectModel.ReadOnlyCollection{System.String}
      overload: NodaTime.TimeZones.DateTimeZoneCache.Ids*
      implements:
      - NodaTime.IDateTimeZoneProvider.Ids
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull(System.String)
      commentId: M:NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull(System.String)
      language: CSharp
      name:
        CSharp: GetZoneOrNull(String)
        VB: GetZoneOrNull(String)
      nameWithType:
        CSharp: DateTimeZoneCache.GetZoneOrNull(String)
        VB: DateTimeZoneCache.GetZoneOrNull(String)
      qualifiedName:
        CSharp: NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull(System.String)
        VB: NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/DateTimeZoneCache.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetZoneOrNull
        path: src/NodaTime/TimeZones/DateTimeZoneCache.cs
        startLine: 95
      example: []
      syntax:
        content:
          CSharp: public DateTimeZone GetZoneOrNull(string id)
          VB: Public Function GetZoneOrNull(id As String) As DateTimeZone
        parameters:
        - id: id
          type: System.String
        return:
          type: NodaTime.DateTimeZone
      overload: NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull*
      implements:
      - NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.TimeZones.DateTimeZoneCache.Item(System.String)
      commentId: P:NodaTime.TimeZones.DateTimeZoneCache.Item(System.String)
      language: CSharp
      name:
        CSharp: Item[String]
        VB: Item(String)
      nameWithType:
        CSharp: DateTimeZoneCache.Item[String]
        VB: DateTimeZoneCache.Item(String)
      qualifiedName:
        CSharp: NodaTime.TimeZones.DateTimeZoneCache.Item[System.String]
        VB: NodaTime.TimeZones.DateTimeZoneCache.Item(System.String)
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/DateTimeZoneCache.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: this[]
        path: src/NodaTime/TimeZones/DateTimeZoneCache.cs
        startLine: 124
      example: []
      syntax:
        content:
          CSharp: public DateTimeZone this[string id] { get; }
          VB: Public ReadOnly Property Item(id As String) As DateTimeZone
        parameters:
        - id: id
          type: System.String
        return:
          type: NodaTime.DateTimeZone
      overload: NodaTime.TimeZones.DateTimeZoneCache.Item*
      implements:
      - NodaTime.IDateTimeZoneProvider.Item(System.String)
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    references:
      NodaTime.IDateTimeZoneProvider: 
      NodaTime.TimeZones.IDateTimeZoneSource: 
      NodaTime.DateTimeZoneProviders: 
  - id: NodaTime.TimeZones.DateTimeZoneNotFoundException
    commentId: T:NodaTime.TimeZones.DateTimeZoneNotFoundException
    language: CSharp
    name:
      CSharp: DateTimeZoneNotFoundException
      VB: DateTimeZoneNotFoundException
    nameWithType:
      CSharp: DateTimeZoneNotFoundException
      VB: DateTimeZoneNotFoundException
    qualifiedName:
      CSharp: NodaTime.TimeZones.DateTimeZoneNotFoundException
      VB: NodaTime.TimeZones.DateTimeZoneNotFoundException
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/DateTimeZoneNotFoundException.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: DateTimeZoneNotFoundException
      path: src/NodaTime/TimeZones/DateTimeZoneNotFoundException.cs
      startLine: 22
    summary: "\nException thrown when time zone is requested from an <xref href=\"NodaTime.IDateTimeZoneProvider\" data-throw-if-not-resolved=\"false\"></xref>,\nbut the specified ID is invalid for that provider.\n"
    remarks: "\nThis type only exists as <code>TimeZoneNotFoundException</code> doesn't exist in the Portable Class Library.\nBy creating an exception which derives from <code>TimeZoneNotFoundException</code> on the desktop version\nand <code>Exception</code> on the PCL version, we achieve reasonable consistency while remaining\nbackwardly compatible with Noda Time v1 (which was desktop-only, and threw <code>TimeZoneNotFoundException</code>).\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public sealed class DateTimeZoneNotFoundException : TimeZoneNotFoundException, ISerializable, _Exception
        VB: >-
          <Serializable>

          Public NotInheritable Class DateTimeZoneNotFoundException

              Inherits TimeZoneNotFoundException

              Implements ISerializable, _Exception
    inheritance:
    - System.Object
    - System.Exception
    - System.TimeZoneNotFoundException
    implements:
    - System.Runtime.Serialization.ISerializable
    - System.Runtime.InteropServices._Exception
    inheritedMembers:
    - System.Exception.GetBaseException
    - System.Exception.ToString
    - System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    - System.Exception.GetType
    - System.Exception.Message
    - System.Exception.Data
    - System.Exception.InnerException
    - System.Exception.TargetSite
    - System.Exception.StackTrace
    - System.Exception.HelpLink
    - System.Exception.Source
    - System.Exception.HResult
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.MemberwiseClone
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.DateTimeZoneNotFoundException.#ctor(System.String)
      commentId: M:NodaTime.TimeZones.DateTimeZoneNotFoundException.#ctor(System.String)
      language: CSharp
      name:
        CSharp: DateTimeZoneNotFoundException(String)
        VB: DateTimeZoneNotFoundException(String)
      nameWithType:
        CSharp: DateTimeZoneNotFoundException.DateTimeZoneNotFoundException(String)
        VB: DateTimeZoneNotFoundException.DateTimeZoneNotFoundException(String)
      qualifiedName:
        CSharp: NodaTime.TimeZones.DateTimeZoneNotFoundException.DateTimeZoneNotFoundException(System.String)
        VB: NodaTime.TimeZones.DateTimeZoneNotFoundException.DateTimeZoneNotFoundException(System.String)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/DateTimeZoneNotFoundException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/TimeZones/DateTimeZoneNotFoundException.cs
        startLine: 35
      summary: "\nCreates an instance with the given message.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTimeZoneNotFoundException(string message)
          VB: Public Sub New(message As String)
        parameters:
        - id: message
          type: System.String
          description: The message for the exception.
      overload: NodaTime.TimeZones.DateTimeZoneNotFoundException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.IDateTimeZoneProvider: 
  - id: NodaTime.TimeZones.AmbiguousTimeResolver
    commentId: T:NodaTime.TimeZones.AmbiguousTimeResolver
    language: CSharp
    name:
      CSharp: AmbiguousTimeResolver
      VB: AmbiguousTimeResolver
    nameWithType:
      CSharp: AmbiguousTimeResolver
      VB: AmbiguousTimeResolver
    qualifiedName:
      CSharp: NodaTime.TimeZones.AmbiguousTimeResolver
      VB: NodaTime.TimeZones.AmbiguousTimeResolver
    type: Delegate
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/Delegates.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: AmbiguousTimeResolver
      path: src/NodaTime/TimeZones/Delegates.cs
      startLine: 34
    summary: "\nChooses between two <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> values that resolve to the same <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    remarks: "\n<p>\nThis delegate is used by <xref href=\"NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver%2cNodaTime.TimeZones.SkippedTimeResolver)\" data-throw-if-not-resolved=\"false\"></xref> when handling an ambiguous local time,\ndue to clocks moving backward in a time zone transition (usually due to an autumnal daylight saving transition).\n</p>\n<p>\nThe returned value should be one of the two parameter values, based on the policy of the specific\nimplementation. Alternatively, it can throw an <xref href=\"NodaTime.AmbiguousTimeException\" data-throw-if-not-resolved=\"false\"></xref> to implement a policy of\n\"reject ambiguous times.\"\n</p>\n<p>See the <xref href=\"NodaTime.TimeZones.Resolvers\" data-throw-if-not-resolved=\"false\"></xref> class for predefined implementations.</p>\n<p>\nImplementations of this delegate can reasonably\nassume that the target local date and time really is ambiguous; the behaviour when the local date and time\ncan be unambiguously mapped into the target time zone (or when it's skipped) is undefined.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: public delegate ZonedDateTime AmbiguousTimeResolver(ZonedDateTime earlier, ZonedDateTime later);
        VB: Public Delegate Function AmbiguousTimeResolver(earlier As ZonedDateTime, later As ZonedDateTime) As ZonedDateTime
      parameters:
      - id: earlier
        type: NodaTime.ZonedDateTime
        description: The earlier of the ambiguous matches for the original local date and time
      - id: later
        type: NodaTime.ZonedDateTime
        description: The later of the ambiguous matches for the original local date and time
      return:
        type: NodaTime.ZonedDateTime
        description: "\nA <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> in the target time zone; typically, one of the two input parameters.\n"
    exceptions:
    - type: NodaTime.AmbiguousTimeException
      commentId: T:NodaTime.AmbiguousTimeException
      description: The implementation rejects requests to map ambiguous times.
    modifiers:
      CSharp:
      - public
      - delegate
      VB:
      - Public
      - Delegate
    items: []
    references:
      NodaTime.ZonedDateTime: 
      NodaTime.LocalDateTime: 
      ? NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)
      : 
      NodaTime.AmbiguousTimeException: 
      NodaTime.TimeZones.Resolvers: 
  - id: NodaTime.TimeZones.SkippedTimeResolver
    commentId: T:NodaTime.TimeZones.SkippedTimeResolver
    language: CSharp
    name:
      CSharp: SkippedTimeResolver
      VB: SkippedTimeResolver
    nameWithType:
      CSharp: SkippedTimeResolver
      VB: SkippedTimeResolver
    qualifiedName:
      CSharp: NodaTime.TimeZones.SkippedTimeResolver
      VB: NodaTime.TimeZones.SkippedTimeResolver
    type: Delegate
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/Delegates.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: SkippedTimeResolver
      path: src/NodaTime/TimeZones/Delegates.cs
      startLine: 66
    summary: "\nResolves a <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> in the situation\nwhere the requested local time does not exist in the target time zone.\n"
    remarks: "\n<p>\nThis delegate is used by <xref href=\"NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver%2cNodaTime.TimeZones.SkippedTimeResolver)\" data-throw-if-not-resolved=\"false\"></xref> when handling the situation where the\nrequested local time does not exist, due to clocks moving forward in a time zone transition (usually due to a\nspring daylight saving transition).\n</p>\n<p>\nThe returned value will necessarily represent a different local date and time to the target one, but\nthe exact form of mapping is up to the delegate implementation. For example, it could return a value\nas close to the target local date and time as possible, or the time immediately after the transition.\nAlternatively, it can throw a <xref href=\"NodaTime.SkippedTimeException\" data-throw-if-not-resolved=\"false\"></xref> to implement a policy of \"reject\nskipped times.\"\n</p>\n<p>See the <xref href=\"NodaTime.TimeZones.Resolvers\" data-throw-if-not-resolved=\"false\"></xref> class for predefined implementations.</p>\n<p>\nImplementations of this delegate can reasonably\nassume that the target local date and time really is skipped; the behaviour when the local date and time\ncan be directly mapped into the target time zone is undefined.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: public delegate ZonedDateTime SkippedTimeResolver(LocalDateTime localDateTime, DateTimeZone zone, ZoneInterval intervalBefore, ZoneInterval intervalAfter);
        VB: Public Delegate Function SkippedTimeResolver(localDateTime As LocalDateTime, zone As DateTimeZone, intervalBefore As ZoneInterval, intervalAfter As ZoneInterval) As ZonedDateTime
      parameters:
      - id: localDateTime
        type: NodaTime.LocalDateTime
        description: The local date and time to map to the given time zone
      - id: zone
        type: NodaTime.DateTimeZone
        description: The target time zone
      - id: intervalBefore
        type: NodaTime.TimeZones.ZoneInterval
        description: The zone interval directly before the target local date and time would have occurred
      - id: intervalAfter
        type: NodaTime.TimeZones.ZoneInterval
        description: The zone interval directly after the target local date and time would have occurred
      return:
        type: NodaTime.ZonedDateTime
        description: A <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> in the target time zone.
    exceptions:
    - type: NodaTime.SkippedTimeException
      commentId: T:NodaTime.SkippedTimeException
      description: The implementation rejects requests to map skipped times.
    modifiers:
      CSharp:
      - public
      - delegate
      VB:
      - Public
      - Delegate
    items: []
    references:
      NodaTime.LocalDateTime: 
      NodaTime.ZonedDateTime: 
      ? NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)
      : 
      NodaTime.SkippedTimeException: 
      NodaTime.TimeZones.Resolvers: 
  - id: NodaTime.TimeZones.ZoneLocalMappingResolver
    commentId: T:NodaTime.TimeZones.ZoneLocalMappingResolver
    language: CSharp
    name:
      CSharp: ZoneLocalMappingResolver
      VB: ZoneLocalMappingResolver
    nameWithType:
      CSharp: ZoneLocalMappingResolver
      VB: ZoneLocalMappingResolver
    qualifiedName:
      CSharp: NodaTime.TimeZones.ZoneLocalMappingResolver
      VB: NodaTime.TimeZones.ZoneLocalMappingResolver
    type: Delegate
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/Delegates.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: ZoneLocalMappingResolver
      path: src/NodaTime/TimeZones/Delegates.cs
      startLine: 84
    summary: "\nResolves the result of attempting to map a local date and time to a target time zone.\n"
    remarks: "\n<p>\nThis delegate is consumed by <xref href=\"NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone%2cNodaTime.TimeZones.ZoneLocalMappingResolver)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime%2cNodaTime.TimeZones.ZoneLocalMappingResolver)\" data-throw-if-not-resolved=\"false\"></xref>,\namong others. It provides the strategy for converting a <xref href=\"NodaTime.TimeZones.ZoneLocalMapping\" data-throw-if-not-resolved=\"false\"></xref> (the result of attempting\nto map a local date and time to a target time zone) to a <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>.\n</p>\n<p>See the <xref href=\"NodaTime.TimeZones.Resolvers\" data-throw-if-not-resolved=\"false\"></xref> class for predefined implementations and a way of combining\nseparate <xref href=\"NodaTime.TimeZones.SkippedTimeResolver\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.TimeZones.AmbiguousTimeResolver\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    example: []
    syntax:
      content:
        CSharp: public delegate ZonedDateTime ZoneLocalMappingResolver(ZoneLocalMapping mapping);
        VB: Public Delegate Function ZoneLocalMappingResolver(mapping As ZoneLocalMapping) As ZonedDateTime
      parameters:
      - id: mapping
        type: NodaTime.TimeZones.ZoneLocalMapping
        description: The intermediate result of mapping a local time to a target time zone.
      return:
        type: NodaTime.ZonedDateTime
        description: A <xref href="NodaTime.ZonedDateTime" data-throw-if-not-resolved="false"></xref> in the target time zone.
    exceptions:
    - type: NodaTime.AmbiguousTimeException
      commentId: T:NodaTime.AmbiguousTimeException
      description: The implementation rejects requests to map ambiguous times.
    - type: NodaTime.SkippedTimeException
      commentId: T:NodaTime.SkippedTimeException
      description: The implementation rejects requests to map skipped times.
    modifiers:
      CSharp:
      - public
      - delegate
      VB:
      - Public
      - Delegate
    items: []
    references:
      NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver): 
      NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver): 
      NodaTime.TimeZones.ZoneLocalMapping: 
      NodaTime.ZonedDateTime: 
      NodaTime.TimeZones.Resolvers: 
      NodaTime.TimeZones.SkippedTimeResolver: 
      NodaTime.TimeZones.AmbiguousTimeResolver: 
  - id: NodaTime.TimeZones.TzdbZoneLocation
    commentId: T:NodaTime.TimeZones.TzdbZoneLocation
    language: CSharp
    name:
      CSharp: TzdbZoneLocation
      VB: TzdbZoneLocation
    nameWithType:
      CSharp: TzdbZoneLocation
      VB: TzdbZoneLocation
    qualifiedName:
      CSharp: NodaTime.TimeZones.TzdbZoneLocation
      VB: NodaTime.TimeZones.TzdbZoneLocation
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/TzdbZoneLocation.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: TzdbZoneLocation
      path: src/NodaTime/TimeZones/TzdbZoneLocation.cs
      startLine: 14
    summary: "\nA location entry generated from the \"zone.tab\" file in a TZDB release. This can be used to provide\nusers with a choice of time zone, although it is not internationalized.\n"
    example: []
    syntax:
      content:
        CSharp: public sealed class TzdbZoneLocation
        VB: Public NotInheritable Class TzdbZoneLocation
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.TzdbZoneLocation.Latitude
      commentId: P:NodaTime.TimeZones.TzdbZoneLocation.Latitude
      language: CSharp
      name:
        CSharp: Latitude
        VB: Latitude
      nameWithType:
        CSharp: TzdbZoneLocation.Latitude
        VB: TzdbZoneLocation.Latitude
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbZoneLocation.Latitude
        VB: NodaTime.TimeZones.TzdbZoneLocation.Latitude
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbZoneLocation.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Latitude
        path: src/NodaTime/TimeZones/TzdbZoneLocation.cs
        startLine: 25
      summary: "\nLatitude in degrees; positive for North, negative for South.\n"
      remarks: The value will be in the range [-90, 90].
      example: []
      syntax:
        content:
          CSharp: public double Latitude { get; }
          VB: Public ReadOnly Property Latitude As Double
        parameters: []
        return:
          type: System.Double
      overload: NodaTime.TimeZones.TzdbZoneLocation.Latitude*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.TzdbZoneLocation.Longitude
      commentId: P:NodaTime.TimeZones.TzdbZoneLocation.Longitude
      language: CSharp
      name:
        CSharp: Longitude
        VB: Longitude
      nameWithType:
        CSharp: TzdbZoneLocation.Longitude
        VB: TzdbZoneLocation.Longitude
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbZoneLocation.Longitude
        VB: NodaTime.TimeZones.TzdbZoneLocation.Longitude
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbZoneLocation.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Longitude
        path: src/NodaTime/TimeZones/TzdbZoneLocation.cs
        startLine: 31
      summary: "\nLongitude in degrees; positive for East, negative for West.\n"
      remarks: The value will be in the range [-180, 180].
      example: []
      syntax:
        content:
          CSharp: public double Longitude { get; }
          VB: Public ReadOnly Property Longitude As Double
        parameters: []
        return:
          type: System.Double
      overload: NodaTime.TimeZones.TzdbZoneLocation.Longitude*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.TzdbZoneLocation.CountryName
      commentId: P:NodaTime.TimeZones.TzdbZoneLocation.CountryName
      language: CSharp
      name:
        CSharp: CountryName
        VB: CountryName
      nameWithType:
        CSharp: TzdbZoneLocation.CountryName
        VB: TzdbZoneLocation.CountryName
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbZoneLocation.CountryName
        VB: NodaTime.TimeZones.TzdbZoneLocation.CountryName
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbZoneLocation.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CountryName
        path: src/NodaTime/TimeZones/TzdbZoneLocation.cs
        startLine: 37
      summary: "\nThe English name of the country containing the location.\n"
      remarks: This will never be null.
      example: []
      syntax:
        content:
          CSharp: public string CountryName { get; }
          VB: Public ReadOnly Property CountryName As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.TzdbZoneLocation.CountryName*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.TzdbZoneLocation.CountryCode
      commentId: P:NodaTime.TimeZones.TzdbZoneLocation.CountryCode
      language: CSharp
      name:
        CSharp: CountryCode
        VB: CountryCode
      nameWithType:
        CSharp: TzdbZoneLocation.CountryCode
        VB: TzdbZoneLocation.CountryCode
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbZoneLocation.CountryCode
        VB: NodaTime.TimeZones.TzdbZoneLocation.CountryCode
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbZoneLocation.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CountryCode
        path: src/NodaTime/TimeZones/TzdbZoneLocation.cs
        startLine: 43
      summary: "\nThe ISO-3166 2-letter country code for the country containing the location.\n"
      remarks: This will never be null.
      example: []
      syntax:
        content:
          CSharp: public string CountryCode { get; }
          VB: Public ReadOnly Property CountryCode As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.TzdbZoneLocation.CountryCode*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.TzdbZoneLocation.ZoneId
      commentId: P:NodaTime.TimeZones.TzdbZoneLocation.ZoneId
      language: CSharp
      name:
        CSharp: ZoneId
        VB: ZoneId
      nameWithType:
        CSharp: TzdbZoneLocation.ZoneId
        VB: TzdbZoneLocation.ZoneId
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbZoneLocation.ZoneId
        VB: NodaTime.TimeZones.TzdbZoneLocation.ZoneId
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbZoneLocation.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ZoneId
        path: src/NodaTime/TimeZones/TzdbZoneLocation.cs
        startLine: 51
      summary: "\nThe ID of the time zone for this location.\n"
      remarks: >
        This will never be null, and if this mapping was fetched

        from a <xref href="NodaTime.TimeZones.TzdbDateTimeZoneSource" data-throw-if-not-resolved="false"></xref>, it will always be a valid ID within that source.
      example: []
      syntax:
        content:
          CSharp: public string ZoneId { get; }
          VB: Public ReadOnly Property ZoneId As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.TzdbZoneLocation.ZoneId*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource: 
    - id: NodaTime.TimeZones.TzdbZoneLocation.Comment
      commentId: P:NodaTime.TimeZones.TzdbZoneLocation.Comment
      language: CSharp
      name:
        CSharp: Comment
        VB: Comment
      nameWithType:
        CSharp: TzdbZoneLocation.Comment
        VB: TzdbZoneLocation.Comment
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbZoneLocation.Comment
        VB: NodaTime.TimeZones.TzdbZoneLocation.Comment
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbZoneLocation.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Comment
        path: src/NodaTime/TimeZones/TzdbZoneLocation.cs
        startLine: 60
      summary: "\nThe comment (in English) for the mapping, if any.\n"
      remarks: "\nThis is usually used to differentiate between locations in the same country.\nThis will return an empty string if no comment was provided in the original data.\n"
      example: []
      syntax:
        content:
          CSharp: public string Comment { get; }
          VB: Public ReadOnly Property Comment As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.TzdbZoneLocation.Comment*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.TzdbZoneLocation.#ctor(System.Int32,System.Int32,System.String,System.String,System.String,System.String)
      commentId: M:NodaTime.TimeZones.TzdbZoneLocation.#ctor(System.Int32,System.Int32,System.String,System.String,System.String,System.String)
      language: CSharp
      name:
        CSharp: TzdbZoneLocation(Int32, Int32, String, String, String, String)
        VB: TzdbZoneLocation(Int32, Int32, String, String, String, String)
      nameWithType:
        CSharp: TzdbZoneLocation.TzdbZoneLocation(Int32, Int32, String, String, String, String)
        VB: TzdbZoneLocation.TzdbZoneLocation(Int32, Int32, String, String, String, String)
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbZoneLocation.TzdbZoneLocation(System.Int32, System.Int32, System.String, System.String, System.String, System.String)
        VB: NodaTime.TimeZones.TzdbZoneLocation.TzdbZoneLocation(System.Int32, System.Int32, System.String, System.String, System.String, System.String)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbZoneLocation.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/TimeZones/TzdbZoneLocation.cs
        startLine: 75
      summary: "\nCreates a new location.\n"
      remarks: >
        This constructor is only public for the sake of testability. Non-test code should

        usually obtain locations from a <xref href="NodaTime.TimeZones.TzdbDateTimeZoneSource" data-throw-if-not-resolved="false"></xref>.
      example: []
      syntax:
        content:
          CSharp: public TzdbZoneLocation(int latitudeSeconds, int longitudeSeconds, string countryName, string countryCode, string zoneId, string comment)
          VB: Public Sub New(latitudeSeconds As Integer, longitudeSeconds As Integer, countryName As String, countryCode As String, zoneId As String, comment As String)
        parameters:
        - id: latitudeSeconds
          type: System.Int32
          description: Latitude of the location, in seconds.
        - id: longitudeSeconds
          type: System.Int32
          description: Longitude of the location, in seconds.
        - id: countryName
          type: System.String
          description: English country name of the location, in degrees. Must not be null.
        - id: countryCode
          type: System.String
          description: ISO-3166 country code of the location. Must not be null.
        - id: zoneId
          type: System.String
          description: Time zone identifier of the location. Must not be null.
        - id: comment
          type: System.String
          description: Optional comment. Must not be null, but may be empty.
      overload: NodaTime.TimeZones.TzdbZoneLocation.#ctor*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The latitude or longitude is invalid.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource: 
  - id: NodaTime.TimeZones.Resolvers
    commentId: T:NodaTime.TimeZones.Resolvers
    language: CSharp
    name:
      CSharp: Resolvers
      VB: Resolvers
    nameWithType:
      CSharp: Resolvers
      VB: Resolvers
    qualifiedName:
      CSharp: NodaTime.TimeZones.Resolvers
      VB: NodaTime.TimeZones.Resolvers
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/Resolvers.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: Resolvers
      path: src/NodaTime/TimeZones/Resolvers.cs
      startLine: 22
    summary: "\nCommonly-used implementations of the delegates used in resolving a <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> to a\n<xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref>, and a method to combine two \"partial\" resolvers into a full one.\n"
    remarks: "\n<p>\nThis class contains predefined implementations of <xref href=\"NodaTime.TimeZones.ZoneLocalMappingResolver\" data-throw-if-not-resolved=\"false\"></xref>,\n<xref href=\"NodaTime.TimeZones.AmbiguousTimeResolver\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"NodaTime.TimeZones.SkippedTimeResolver\" data-throw-if-not-resolved=\"false\"></xref>, along with\n<xref href=\"NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver%2cNodaTime.TimeZones.SkippedTimeResolver)\" data-throw-if-not-resolved=\"false\"></xref>, which produces a <code>ZoneLocalMappingResolver</code> from instances of the\nother two.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: public static class Resolvers
        VB: Public Module Resolvers
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: NodaTime.TimeZones.Resolvers.ReturnEarlier
      commentId: F:NodaTime.TimeZones.Resolvers.ReturnEarlier
      language: CSharp
      name:
        CSharp: ReturnEarlier
        VB: ReturnEarlier
      nameWithType:
        CSharp: Resolvers.ReturnEarlier
        VB: Resolvers.ReturnEarlier
      qualifiedName:
        CSharp: NodaTime.TimeZones.Resolvers.ReturnEarlier
        VB: NodaTime.TimeZones.Resolvers.ReturnEarlier
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Resolvers.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ReturnEarlier
        path: src/NodaTime/TimeZones/Resolvers.cs
        startLine: 27
      summary: "\nAn <xref href=\"NodaTime.TimeZones.AmbiguousTimeResolver\" data-throw-if-not-resolved=\"false\"></xref> which returns the earlier of the two matching times.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly AmbiguousTimeResolver ReturnEarlier
          VB: Public Shared ReadOnly ReturnEarlier As AmbiguousTimeResolver
        return:
          type: NodaTime.TimeZones.AmbiguousTimeResolver
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.AmbiguousTimeResolver: 
    - id: NodaTime.TimeZones.Resolvers.ReturnLater
      commentId: F:NodaTime.TimeZones.Resolvers.ReturnLater
      language: CSharp
      name:
        CSharp: ReturnLater
        VB: ReturnLater
      nameWithType:
        CSharp: Resolvers.ReturnLater
        VB: Resolvers.ReturnLater
      qualifiedName:
        CSharp: NodaTime.TimeZones.Resolvers.ReturnLater
        VB: NodaTime.TimeZones.Resolvers.ReturnLater
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Resolvers.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ReturnLater
        path: src/NodaTime/TimeZones/Resolvers.cs
        startLine: 32
      summary: "\nAn <xref href=\"NodaTime.TimeZones.AmbiguousTimeResolver\" data-throw-if-not-resolved=\"false\"></xref> which returns the later of the two matching times.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly AmbiguousTimeResolver ReturnLater
          VB: Public Shared ReadOnly ReturnLater As AmbiguousTimeResolver
        return:
          type: NodaTime.TimeZones.AmbiguousTimeResolver
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.AmbiguousTimeResolver: 
    - id: NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous
      commentId: F:NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous
      language: CSharp
      name:
        CSharp: ThrowWhenAmbiguous
        VB: ThrowWhenAmbiguous
      nameWithType:
        CSharp: Resolvers.ThrowWhenAmbiguous
        VB: Resolvers.ThrowWhenAmbiguous
      qualifiedName:
        CSharp: NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous
        VB: NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Resolvers.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ThrowWhenAmbiguous
        path: src/NodaTime/TimeZones/Resolvers.cs
        startLine: 37
      summary: "\nAn <xref href=\"NodaTime.TimeZones.AmbiguousTimeResolver\" data-throw-if-not-resolved=\"false\"></xref> which simply throws an <xref href=\"NodaTime.AmbiguousTimeException\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly AmbiguousTimeResolver ThrowWhenAmbiguous
          VB: Public Shared ReadOnly ThrowWhenAmbiguous As AmbiguousTimeResolver
        return:
          type: NodaTime.TimeZones.AmbiguousTimeResolver
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.AmbiguousTimeResolver: 
        NodaTime.AmbiguousTimeException: 
    - id: NodaTime.TimeZones.Resolvers.ReturnEndOfIntervalBefore
      commentId: F:NodaTime.TimeZones.Resolvers.ReturnEndOfIntervalBefore
      language: CSharp
      name:
        CSharp: ReturnEndOfIntervalBefore
        VB: ReturnEndOfIntervalBefore
      nameWithType:
        CSharp: Resolvers.ReturnEndOfIntervalBefore
        VB: Resolvers.ReturnEndOfIntervalBefore
      qualifiedName:
        CSharp: NodaTime.TimeZones.Resolvers.ReturnEndOfIntervalBefore
        VB: NodaTime.TimeZones.Resolvers.ReturnEndOfIntervalBefore
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Resolvers.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ReturnEndOfIntervalBefore
        path: src/NodaTime/TimeZones/Resolvers.cs
        startLine: 46
      summary: "\nA <xref href=\"NodaTime.TimeZones.SkippedTimeResolver\" data-throw-if-not-resolved=\"false\"></xref> which returns the final tick of the time zone interval\nbefore the \"gap\".\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly SkippedTimeResolver ReturnEndOfIntervalBefore
          VB: Public Shared ReadOnly ReturnEndOfIntervalBefore As SkippedTimeResolver
        return:
          type: NodaTime.TimeZones.SkippedTimeResolver
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.SkippedTimeResolver: 
    - id: NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter
      commentId: F:NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter
      language: CSharp
      name:
        CSharp: ReturnStartOfIntervalAfter
        VB: ReturnStartOfIntervalAfter
      nameWithType:
        CSharp: Resolvers.ReturnStartOfIntervalAfter
        VB: Resolvers.ReturnStartOfIntervalAfter
      qualifiedName:
        CSharp: NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter
        VB: NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Resolvers.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ReturnStartOfIntervalAfter
        path: src/NodaTime/TimeZones/Resolvers.cs
        startLine: 56
      summary: "\nA <xref href=\"NodaTime.TimeZones.SkippedTimeResolver\" data-throw-if-not-resolved=\"false\"></xref> which returns the first tick of the time zone interval\nafter the \"gap\".\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly SkippedTimeResolver ReturnStartOfIntervalAfter
          VB: Public Shared ReadOnly ReturnStartOfIntervalAfter As SkippedTimeResolver
        return:
          type: NodaTime.TimeZones.SkippedTimeResolver
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.SkippedTimeResolver: 
    - id: NodaTime.TimeZones.Resolvers.ThrowWhenSkipped
      commentId: F:NodaTime.TimeZones.Resolvers.ThrowWhenSkipped
      language: CSharp
      name:
        CSharp: ThrowWhenSkipped
        VB: ThrowWhenSkipped
      nameWithType:
        CSharp: Resolvers.ThrowWhenSkipped
        VB: Resolvers.ThrowWhenSkipped
      qualifiedName:
        CSharp: NodaTime.TimeZones.Resolvers.ThrowWhenSkipped
        VB: NodaTime.TimeZones.Resolvers.ThrowWhenSkipped
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Resolvers.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ThrowWhenSkipped
        path: src/NodaTime/TimeZones/Resolvers.cs
        startLine: 68
      summary: "\nA <xref href=\"NodaTime.TimeZones.SkippedTimeResolver\" data-throw-if-not-resolved=\"false\"></xref> which simply throws a <xref href=\"NodaTime.SkippedTimeException\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly SkippedTimeResolver ThrowWhenSkipped
          VB: Public Shared ReadOnly ThrowWhenSkipped As SkippedTimeResolver
        return:
          type: NodaTime.TimeZones.SkippedTimeResolver
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.SkippedTimeResolver: 
        NodaTime.SkippedTimeException: 
    - id: NodaTime.TimeZones.Resolvers.StrictResolver
      commentId: F:NodaTime.TimeZones.Resolvers.StrictResolver
      language: CSharp
      name:
        CSharp: StrictResolver
        VB: StrictResolver
      nameWithType:
        CSharp: Resolvers.StrictResolver
        VB: Resolvers.StrictResolver
      qualifiedName:
        CSharp: NodaTime.TimeZones.Resolvers.StrictResolver
        VB: NodaTime.TimeZones.Resolvers.StrictResolver
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Resolvers.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: StrictResolver
        path: src/NodaTime/TimeZones/Resolvers.cs
        startLine: 86
      summary: "\nA <xref href=\"NodaTime.TimeZones.ZoneLocalMappingResolver\" data-throw-if-not-resolved=\"false\"></xref> which only ever succeeds in the (usual) case where the result\nof the mapping is unambiguous.\n"
      remarks: "\nIf the mapping is ambiguous or skipped, this throws <xref href=\"NodaTime.SkippedTimeException\" data-throw-if-not-resolved=\"false\"></xref> or\n<xref href=\"NodaTime.AmbiguousTimeException\" data-throw-if-not-resolved=\"false\"></xref>, as appropriate. This resolver combines\n<xref href=\"NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.TimeZones.Resolvers.ThrowWhenSkipped\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly ZoneLocalMappingResolver StrictResolver
          VB: Public Shared ReadOnly StrictResolver As ZoneLocalMappingResolver
        return:
          type: NodaTime.TimeZones.ZoneLocalMappingResolver
      seealso:
      - linkId: NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)
        commentId: M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.ZoneLocalMappingResolver: 
        NodaTime.SkippedTimeException: 
        NodaTime.AmbiguousTimeException: 
        NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous: 
        NodaTime.TimeZones.Resolvers.ThrowWhenSkipped: 
        NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime): 
    - id: NodaTime.TimeZones.Resolvers.LenientResolver
      commentId: F:NodaTime.TimeZones.Resolvers.LenientResolver
      language: CSharp
      name:
        CSharp: LenientResolver
        VB: LenientResolver
      nameWithType:
        CSharp: Resolvers.LenientResolver
        VB: Resolvers.LenientResolver
      qualifiedName:
        CSharp: NodaTime.TimeZones.Resolvers.LenientResolver
        VB: NodaTime.TimeZones.Resolvers.LenientResolver
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Resolvers.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: LenientResolver
        path: src/NodaTime/TimeZones/Resolvers.cs
        startLine: 96
      summary: "\nA <xref href=\"NodaTime.TimeZones.ZoneLocalMappingResolver\" data-throw-if-not-resolved=\"false\"></xref> which never throws an exception due to ambiguity or skipped time.\n"
      remarks: "\nAmbiguity is handled by returning the later occurrence, and skipped times are mapped to the start of the zone interval\nafter the gap. This resolver combines <xref href=\"NodaTime.TimeZones.Resolvers.ReturnLater\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly ZoneLocalMappingResolver LenientResolver
          VB: Public Shared ReadOnly LenientResolver As ZoneLocalMappingResolver
        return:
          type: NodaTime.TimeZones.ZoneLocalMappingResolver
      seealso:
      - linkId: NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)
        commentId: M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.ZoneLocalMappingResolver: 
        NodaTime.TimeZones.Resolvers.ReturnLater: 
        NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter: 
        NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime): 
    - id: NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)
      commentId: M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)
      language: CSharp
      name:
        CSharp: CreateMappingResolver(AmbiguousTimeResolver, SkippedTimeResolver)
        VB: CreateMappingResolver(AmbiguousTimeResolver, SkippedTimeResolver)
      nameWithType:
        CSharp: Resolvers.CreateMappingResolver(AmbiguousTimeResolver, SkippedTimeResolver)
        VB: Resolvers.CreateMappingResolver(AmbiguousTimeResolver, SkippedTimeResolver)
      qualifiedName:
        CSharp: NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver, NodaTime.TimeZones.SkippedTimeResolver)
        VB: NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver, NodaTime.TimeZones.SkippedTimeResolver)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Resolvers.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CreateMappingResolver
        path: src/NodaTime/TimeZones/Resolvers.cs
        startLine: 112
      summary: "\nCombines an <xref href=\"NodaTime.TimeZones.AmbiguousTimeResolver\" data-throw-if-not-resolved=\"false\"></xref> and a <xref href=\"NodaTime.TimeZones.SkippedTimeResolver\" data-throw-if-not-resolved=\"false\"></xref> to create a\n<xref href=\"NodaTime.TimeZones.ZoneLocalMappingResolver\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      remarks: "\nThe <code>ZoneLocalMappingResolver</code> created by this method operates in the obvious way: unambiguous mappings\nare returned directly, ambiguous mappings are delegated to the given <code>AmbiguousTimeResolver</code>, and\n\"skipped\" mappings are delegated to the given <code>SkippedTimeResolver</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static ZoneLocalMappingResolver CreateMappingResolver(AmbiguousTimeResolver ambiguousTimeResolver, SkippedTimeResolver skippedTimeResolver)
          VB: Public Shared Function CreateMappingResolver(ambiguousTimeResolver As AmbiguousTimeResolver, skippedTimeResolver As SkippedTimeResolver) As ZoneLocalMappingResolver
        parameters:
        - id: ambiguousTimeResolver
          type: NodaTime.TimeZones.AmbiguousTimeResolver
          description: Resolver to use for ambiguous mappings.
        - id: skippedTimeResolver
          type: NodaTime.TimeZones.SkippedTimeResolver
          description: Resolver to use for "skipped" mappings.
        return:
          type: NodaTime.TimeZones.ZoneLocalMappingResolver
          description: The logical combination of the two resolvers.
      overload: NodaTime.TimeZones.Resolvers.CreateMappingResolver*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: >-
          <span class="paramref">ambiguousTimeResolver</span> or

          <span class="paramref">skippedTimeResolver</span> is null.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.TimeZones.AmbiguousTimeResolver: 
        NodaTime.TimeZones.SkippedTimeResolver: 
        NodaTime.TimeZones.ZoneLocalMappingResolver: 
    references:
      NodaTime.LocalDateTime: 
      NodaTime.ZonedDateTime: 
      NodaTime.TimeZones.ZoneLocalMappingResolver: 
      NodaTime.TimeZones.AmbiguousTimeResolver: 
      NodaTime.TimeZones.SkippedTimeResolver: 
      ? NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)
      : 
  - id: NodaTime.TimeZones.InvalidDateTimeZoneSourceException
    commentId: T:NodaTime.TimeZones.InvalidDateTimeZoneSourceException
    language: CSharp
    name:
      CSharp: InvalidDateTimeZoneSourceException
      VB: InvalidDateTimeZoneSourceException
    nameWithType:
      CSharp: InvalidDateTimeZoneSourceException
      VB: InvalidDateTimeZoneSourceException
    qualifiedName:
      CSharp: NodaTime.TimeZones.InvalidDateTimeZoneSourceException
      VB: NodaTime.TimeZones.InvalidDateTimeZoneSourceException
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/InvalidDateTimeZoneSourceException.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: InvalidDateTimeZoneSourceException
      path: src/NodaTime/TimeZones/InvalidDateTimeZoneSourceException.cs
      startLine: 17
    summary: "\nException thrown to indicate that a time zone source has violated the contract of <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref>.\nThis exception is primarily intended to be thrown from <xref href=\"NodaTime.TimeZones.DateTimeZoneCache\" data-throw-if-not-resolved=\"false\"></xref>, and only in the face of a buggy\nsource; user code should not usually need to be aware of this or catch it.\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public sealed class InvalidDateTimeZoneSourceException : Exception, ISerializable, _Exception
        VB: >-
          <Serializable>

          Public NotInheritable Class InvalidDateTimeZoneSourceException

              Inherits Exception

              Implements ISerializable, _Exception
    inheritance:
    - System.Object
    - System.Exception
    implements:
    - System.Runtime.Serialization.ISerializable
    - System.Runtime.InteropServices._Exception
    inheritedMembers:
    - System.Exception.GetBaseException
    - System.Exception.ToString
    - System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    - System.Exception.GetType
    - System.Exception.Message
    - System.Exception.Data
    - System.Exception.InnerException
    - System.Exception.TargetSite
    - System.Exception.StackTrace
    - System.Exception.HelpLink
    - System.Exception.Source
    - System.Exception.HResult
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.MemberwiseClone
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.InvalidDateTimeZoneSourceException.#ctor(System.String)
      commentId: M:NodaTime.TimeZones.InvalidDateTimeZoneSourceException.#ctor(System.String)
      language: CSharp
      name:
        CSharp: InvalidDateTimeZoneSourceException(String)
        VB: InvalidDateTimeZoneSourceException(String)
      nameWithType:
        CSharp: InvalidDateTimeZoneSourceException.InvalidDateTimeZoneSourceException(String)
        VB: InvalidDateTimeZoneSourceException.InvalidDateTimeZoneSourceException(String)
      qualifiedName:
        CSharp: NodaTime.TimeZones.InvalidDateTimeZoneSourceException.InvalidDateTimeZoneSourceException(System.String)
        VB: NodaTime.TimeZones.InvalidDateTimeZoneSourceException.InvalidDateTimeZoneSourceException(System.String)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/InvalidDateTimeZoneSourceException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/TimeZones/InvalidDateTimeZoneSourceException.cs
        startLine: 25
      summary: "\nCreates a new instance with the given message.\n"
      example: []
      syntax:
        content:
          CSharp: public InvalidDateTimeZoneSourceException(string message)
          VB: Public Sub New(message As String)
        parameters:
        - id: message
          type: System.String
          description: The message for the exception.
      overload: NodaTime.TimeZones.InvalidDateTimeZoneSourceException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.TimeZones.IDateTimeZoneSource: 
      NodaTime.TimeZones.DateTimeZoneCache: 
  - id: NodaTime.TimeZones.IDateTimeZoneSource
    commentId: T:NodaTime.TimeZones.IDateTimeZoneSource
    language: CSharp
    name:
      CSharp: IDateTimeZoneSource
      VB: IDateTimeZoneSource
    nameWithType:
      CSharp: IDateTimeZoneSource
      VB: IDateTimeZoneSource
    qualifiedName:
      CSharp: NodaTime.TimeZones.IDateTimeZoneSource
      VB: NodaTime.TimeZones.IDateTimeZoneSource
    type: Interface
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/IDateTimeZoneSource.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: IDateTimeZoneSource
      path: src/NodaTime/TimeZones/IDateTimeZoneSource.cs
      startLine: 33
    summary: "\nProvides the interface for objects that can retrieve time zone definitions given an ID.\n"
    remarks: "\n<p>\nThe interface presumes that the available time zones are static; there is no mechanism for \nupdating the list of available time zones. Any time zone ID that is returned in <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource.GetIds\" data-throw-if-not-resolved=\"false\"></xref> \nmust be resolved by <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)\" data-throw-if-not-resolved=\"false\"></xref> for the life of the source.\n</p>\n<p>\nImplementations need not cache time zones or the available time zone IDs. \nCaching is typically provided by <xref href=\"NodaTime.TimeZones.DateTimeZoneCache\" data-throw-if-not-resolved=\"false\"></xref>, which most consumers should use instead of\nconsuming <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> directly in order to get better performance.\n</p>\n<p>\nIt is expected that any exceptions thrown are implementation-specific; nothing is explicitly\nspecified in the interface. Typically this would be unusual to the point that callers would not\ntry to catch them; any implementation which may break in ways that are sensible to catch should advertise\nthis clearly, so that clients will know to handle the exceptions appropriately. No wrapper exception\ntype is provided by Noda Time to handle this situation, and code in Noda Time does not try to catch\nsuch exceptions.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: public interface IDateTimeZoneSource
        VB: Public Interface IDateTimeZoneSource
    modifiers:
      CSharp:
      - public
      - interface
      VB:
      - Public
      - Interface
    items:
    - id: NodaTime.TimeZones.IDateTimeZoneSource.GetIds
      commentId: M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds
      language: CSharp
      name:
        CSharp: GetIds()
        VB: GetIds()
      nameWithType:
        CSharp: IDateTimeZoneSource.GetIds()
        VB: IDateTimeZoneSource.GetIds()
      qualifiedName:
        CSharp: NodaTime.TimeZones.IDateTimeZoneSource.GetIds()
        VB: NodaTime.TimeZones.IDateTimeZoneSource.GetIds()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/IDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetIds
        path: src/NodaTime/TimeZones/IDateTimeZoneSource.cs
        startLine: 54
      summary: "\nReturns an unordered enumeration of the IDs available from this source.\n"
      remarks: "\n<p>\nEvery value in this enumeration must return a valid time zone from <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)\" data-throw-if-not-resolved=\"false\"></xref> for the life of the source.\nThe enumeration may be empty, but must not be null, and must not contain any elements which are null.  It\nshould not contain duplicates: this is not enforced, and while it may not have a significant impact on\nclients in some cases, it is generally unfriendly.  The built-in implementations never return duplicates.\n</p>\n<p>\nThe source is not required to provide the IDs in any particular order, although they should be distinct.\n</p>\n<p>\nNote that this list may optionally contain any of the fixed-offset timezones (with IDs \"UTC\" and\n\"UTC+/-Offset\"), but there is no requirement they be included.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: IEnumerable<string> GetIds()
          VB: Function GetIds As IEnumerable(Of String)
        return:
          type: System.Collections.Generic.IEnumerable{System.String}
          description: The IDs available from this source.
      overload: NodaTime.TimeZones.IDateTimeZoneSource.GetIds*
      modifiers:
        CSharp: []
        VB: []
      references:
        NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String): 
    - id: NodaTime.TimeZones.IDateTimeZoneSource.VersionId
      commentId: P:NodaTime.TimeZones.IDateTimeZoneSource.VersionId
      language: CSharp
      name:
        CSharp: VersionId
        VB: VersionId
      nameWithType:
        CSharp: IDateTimeZoneSource.VersionId
        VB: IDateTimeZoneSource.VersionId
      qualifiedName:
        CSharp: NodaTime.TimeZones.IDateTimeZoneSource.VersionId
        VB: NodaTime.TimeZones.IDateTimeZoneSource.VersionId
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/IDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: VersionId
        path: src/NodaTime/TimeZones/IDateTimeZoneSource.cs
        startLine: 62
      summary: "\nReturns an appropriate version ID for diagnostic purposes, which must not be null.\nThis doesn't have any specific format; it's solely for diagnostic purposes.\nThe included sources return strings of the format \"source identifier: source version\" indicating where the\ninformation comes from and which version of the source information has been loaded.\n"
      example: []
      syntax:
        content:
          CSharp: string VersionId { get; }
          VB: ReadOnly Property VersionId As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.IDateTimeZoneSource.VersionId*
      modifiers:
        CSharp:
        - get
        VB:
        - ReadOnly
    - id: NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
      commentId: M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
      language: CSharp
      name:
        CSharp: ForId(String)
        VB: ForId(String)
      nameWithType:
        CSharp: IDateTimeZoneSource.ForId(String)
        VB: IDateTimeZoneSource.ForId(String)
      qualifiedName:
        CSharp: NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
        VB: NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/IDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ForId
        path: src/NodaTime/TimeZones/IDateTimeZoneSource.cs
        startLine: 92
      summary: "\nReturns the time zone definition associated with the given ID.\n"
      remarks: "\n<p>\nNote that this is permitted to return a <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> that has a different ID to that\nrequested, if the ID provided is an alias.\n</p>\n<p>\nNote also that this method is not required to return the same <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> instance for\nsuccessive requests for the same ID; however, all instances returned for a given ID must compare as equal.\n</p>\n<p>\nIt is advised that sources should document their behaviour regarding any fixed-offset timezones\n(i.e. \"UTC\" and \"UTC+/-Offset\") that are included in the list returned by <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource.GetIds\" data-throw-if-not-resolved=\"false\"></xref>.\n(These IDs will not be requested by <xref href=\"NodaTime.TimeZones.DateTimeZoneCache\" data-throw-if-not-resolved=\"false\"></xref>, but any users calling\ninto the source directly may care.)\n</p>\n<p>\nThe source need not attempt to cache time zones; caching is typically provided by\n<xref href=\"NodaTime.TimeZones.DateTimeZoneCache\" data-throw-if-not-resolved=\"false\"></xref>.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: DateTimeZone ForId(string id)
          VB: Function ForId(id As String) As DateTimeZone
        parameters:
        - id: id
          type: System.String
          description: >-
            The ID of the time zone to return. This must be one of the IDs

            returned by <xref href="NodaTime.TimeZones.IDateTimeZoneSource.GetIds" data-throw-if-not-resolved="false"></xref>.
        return:
          type: NodaTime.DateTimeZone
          description: The <xref href="NodaTime.DateTimeZone" data-throw-if-not-resolved="false"></xref> for the given ID.
      overload: NodaTime.TimeZones.IDateTimeZoneSource.ForId*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">id</span> is null.
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: <span class="paramref">id</span> is not supported by this source.
      modifiers:
        CSharp: []
        VB: []
      references:
        NodaTime.DateTimeZone: 
        NodaTime.TimeZones.IDateTimeZoneSource.GetIds: 
        NodaTime.TimeZones.DateTimeZoneCache: 
    - id: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      commentId: M:NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      language: CSharp
      name:
        CSharp: MapTimeZoneId(TimeZoneInfo)
        VB: MapTimeZoneId(TimeZoneInfo)
      nameWithType:
        CSharp: IDateTimeZoneSource.MapTimeZoneId(TimeZoneInfo)
        VB: IDateTimeZoneSource.MapTimeZoneId(TimeZoneInfo)
      qualifiedName:
        CSharp: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
        VB: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/IDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MapTimeZoneId
        path: src/NodaTime/TimeZones/IDateTimeZoneSource.cs
        startLine: 102
      summary: "\nReturns this source's corresponding ID for the given BCL time zone.\n"
      example: []
      syntax:
        content:
          CSharp: string MapTimeZoneId(TimeZoneInfo timeZone)
          VB: Function MapTimeZoneId(timeZone As TimeZoneInfo) As String
        parameters:
        - id: timeZone
          type: System.TimeZoneInfo
          description: The BCL time zone, which must be a known system time zone.
        return:
          type: System.String
          description: "\nThe ID for the given system time zone for this source, or null if the system time\nzone has no mapping in this source.\n"
      overload: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId*
      modifiers:
        CSharp: []
        VB: []
    references:
      NodaTime.TimeZones.IDateTimeZoneSource.GetIds: 
      NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String): 
      NodaTime.TimeZones.DateTimeZoneCache: 
      NodaTime.TimeZones.IDateTimeZoneSource: 
  - id: NodaTime.TimeZones.ZoneEqualityComparer
    commentId: T:NodaTime.TimeZones.ZoneEqualityComparer
    language: CSharp
    name:
      CSharp: ZoneEqualityComparer
      VB: ZoneEqualityComparer
    nameWithType:
      CSharp: ZoneEqualityComparer
      VB: ZoneEqualityComparer
    qualifiedName:
      CSharp: NodaTime.TimeZones.ZoneEqualityComparer
      VB: NodaTime.TimeZones.ZoneEqualityComparer
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: ZoneEqualityComparer
      path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
      startLine: 21
    summary: "\nEquality comparer for time zones, comparing specific aspects of the zone intervals within\na time zone for a specific interval of the time line.\n"
    remarks: "\nThe default behaviour of this comparator is to consider two time zones to be equal if they share the same wall\noffsets at all points within a given time interval, regardless of other aspects of each\n<xref href=\"NodaTime.TimeZones.ZoneInterval\" data-throw-if-not-resolved=\"false\"></xref> within the two time zones. This behaviour can be changed using the\n<xref href=\"NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)\" data-throw-if-not-resolved=\"false\"></xref> method.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class ZoneEqualityComparer : IEqualityComparer<DateTimeZone>'
        VB: >-
          Public NotInheritable Class ZoneEqualityComparer

              Implements IEqualityComparer(Of DateTimeZone)
    inheritance:
    - System.Object
    implements:
    - System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.ZoneEqualityComparer.ForInterval(NodaTime.Interval)
      commentId: M:NodaTime.TimeZones.ZoneEqualityComparer.ForInterval(NodaTime.Interval)
      language: CSharp
      name:
        CSharp: ForInterval(Interval)
        VB: ForInterval(Interval)
      nameWithType:
        CSharp: ZoneEqualityComparer.ForInterval(Interval)
        VB: ZoneEqualityComparer.ForInterval(Interval)
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneEqualityComparer.ForInterval(NodaTime.Interval)
        VB: NodaTime.TimeZones.ZoneEqualityComparer.ForInterval(NodaTime.Interval)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ForInterval
        path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        startLine: 148
      summary: "\nReturns a <xref href=\"NodaTime.TimeZones.ZoneEqualityComparer\" data-throw-if-not-resolved=\"false\"></xref> for the given interval with the default options.\n"
      remarks: "\nThe default behaviour of this comparator is to consider two time zones to be equal if they share the same wall\noffsets at all points within a given interval.\nTo specify non-default options, call the <xref href=\"NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)\" data-throw-if-not-resolved=\"false\"></xref> method on the result\nof this method."
      example: []
      syntax:
        content:
          CSharp: public static ZoneEqualityComparer ForInterval(Interval interval)
          VB: Public Shared Function ForInterval(interval As Interval) As ZoneEqualityComparer
        parameters:
        - id: interval
          type: NodaTime.Interval
          description: The interval over which to compare time zones.
        return:
          type: NodaTime.TimeZones.ZoneEqualityComparer
          description: A ZoneEqualityComparer for the given interval with the default options.
      overload: NodaTime.TimeZones.ZoneEqualityComparer.ForInterval*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.TimeZones.ZoneEqualityComparer: 
        NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options): 
    - id: NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)
      commentId: M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)
      language: CSharp
      name:
        CSharp: WithOptions(ZoneEqualityComparer.Options)
        VB: WithOptions(ZoneEqualityComparer.Options)
      nameWithType:
        CSharp: ZoneEqualityComparer.WithOptions(ZoneEqualityComparer.Options)
        VB: ZoneEqualityComparer.WithOptions(ZoneEqualityComparer.Options)
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)
        VB: NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WithOptions
        path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        startLine: 163
      summary: "\nReturns a comparer operating over the same interval as this one, but with the given\nset of options.\n"
      remarks: "\nThis method does not modify the comparer on which it's called.\n"
      example: []
      syntax:
        content:
          CSharp: public ZoneEqualityComparer WithOptions(ZoneEqualityComparer.Options options)
          VB: Public Function WithOptions(options As ZoneEqualityComparer.Options) As ZoneEqualityComparer
        parameters:
        - id: options
          type: NodaTime.TimeZones.ZoneEqualityComparer.Options
          description: New set of options, which must consist of flags defined within the <xref href="NodaTime.TimeZones.ZoneEqualityComparer.Options" data-throw-if-not-resolved="false"></xref> enum.
        return:
          type: NodaTime.TimeZones.ZoneEqualityComparer
          description: A comparer operating over the same interval as this one, but with the given set of options.
      overload: NodaTime.TimeZones.ZoneEqualityComparer.WithOptions*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: The specified options are invalid.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.TimeZones.ZoneEqualityComparer.Options: 
    - id: NodaTime.TimeZones.ZoneEqualityComparer.Equals(NodaTime.DateTimeZone,NodaTime.DateTimeZone)
      commentId: M:NodaTime.TimeZones.ZoneEqualityComparer.Equals(NodaTime.DateTimeZone,NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: Equals(DateTimeZone, DateTimeZone)
        VB: Equals(DateTimeZone, DateTimeZone)
      nameWithType:
        CSharp: ZoneEqualityComparer.Equals(DateTimeZone, DateTimeZone)
        VB: ZoneEqualityComparer.Equals(DateTimeZone, DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneEqualityComparer.Equals(NodaTime.DateTimeZone, NodaTime.DateTimeZone)
        VB: NodaTime.TimeZones.ZoneEqualityComparer.Equals(NodaTime.DateTimeZone, NodaTime.DateTimeZone)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        startLine: 174
      summary: "\nCompares two time zones for equality according to the options and interval provided to this comparer.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(DateTimeZone x, DateTimeZone y)
          VB: Public Function Equals(x As DateTimeZone, y As DateTimeZone) As Boolean
        parameters:
        - id: x
          type: NodaTime.DateTimeZone
          description: The first <xref href="NodaTime.DateTimeZone" data-throw-if-not-resolved="false"></xref> to compare.
        - id: y
          type: NodaTime.DateTimeZone
          description: The second <xref href="NodaTime.DateTimeZone" data-throw-if-not-resolved="false"></xref> to compare.
        return:
          type: System.Boolean
          description: <code>true</code> if the specified time zones are equal under the options and interval of this comparer; otherwise, <code>false</code>.
      overload: NodaTime.TimeZones.ZoneEqualityComparer.Equals*
      implements:
      - System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}.Equals(NodaTime.DateTimeZone,NodaTime.DateTimeZone)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.DateTimeZone: 
    - id: NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode(NodaTime.DateTimeZone)
      commentId: M:NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode(NodaTime.DateTimeZone)
      language: CSharp
      name:
        CSharp: GetHashCode(DateTimeZone)
        VB: GetHashCode(DateTimeZone)
      nameWithType:
        CSharp: ZoneEqualityComparer.GetHashCode(DateTimeZone)
        VB: ZoneEqualityComparer.GetHashCode(DateTimeZone)
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode(NodaTime.DateTimeZone)
        VB: NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode(NodaTime.DateTimeZone)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        startLine: 200
      summary: "\nReturns a hash code for the specified time zone.\n"
      remarks: "\nThe hash code generated by any instance of <code>ZoneEqualityComparer</code> will be equal to the hash code\ngenerated by any other instance constructed with the same options and interval, for the same time zone (or equal ones).\nTwo instances of <code>ZoneEqualityComparer</code> with different options or intervals may (but may not) produce\ndifferent hash codes for the same zone.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetHashCode(DateTimeZone obj)
          VB: Public Function GetHashCode(obj As DateTimeZone) As Integer
        parameters:
        - id: obj
          type: NodaTime.DateTimeZone
          description: The time zone to compute a hash code for.
        return:
          type: System.Int32
          description: A hash code for the specified object.
      overload: NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode*
      implements:
      - System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}.GetHashCode(NodaTime.DateTimeZone)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.TimeZones.ZoneInterval: 
      NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options): 
  - id: NodaTime.TimeZones.ZoneEqualityComparer.Options
    commentId: T:NodaTime.TimeZones.ZoneEqualityComparer.Options
    language: CSharp
    name:
      CSharp: ZoneEqualityComparer.Options
      VB: ZoneEqualityComparer.Options
    nameWithType:
      CSharp: ZoneEqualityComparer.Options
      VB: ZoneEqualityComparer.Options
    qualifiedName:
      CSharp: NodaTime.TimeZones.ZoneEqualityComparer.Options
      VB: NodaTime.TimeZones.ZoneEqualityComparer.Options
    type: Enum
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: Options
      path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
      startLine: 56
    summary: "\nOptions to use when comparing time zones for equality. Each option makes the comparison more restrictive.\n"
    remarks: "\n<p>\nBy default, the comparer only compares the wall offset (total of standard offset and any daylight saving offset)\nat every instant within the interval over which the comparer operates. In practice, this is done by comparing each\n<xref href=\"NodaTime.TimeZones.ZoneInterval\" data-throw-if-not-resolved=\"false\"></xref> which includes an instant within the interval (using <xref href=\"NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)\" data-throw-if-not-resolved=\"false\"></xref>).\nFor most purposes, this is all that's required: from the simple perspective of a time zone being just a function from instants to local time,\nthe default option of <xref href=\"NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset\" data-throw-if-not-resolved=\"false\"></xref> effectively checks that the function gives the same result across the two time\nzones being compared, for any given instant within the interval.\n</p>\n<p>\nIt's possible for a time zone to have a transition from one <code>ZoneInterval</code> to another which doesn't adjust the offset: it\nmight just change the name, or the balance between standard offset to daylight saving offset. (As an example, at midnight local\ntime on October 27th 1968, the Europe/London time zone went from a standard offset of 0 and a daylight saving offset of 1 hour\nto a standard offset of 1 and a daylight saving offset of 0... which left the clocks unchanged.) This transition is irrelevant\nto the default options, so the two zone intervals involved are effectively coalesced.\n</p>\n<p>\nThe options available change what sort of comparison is performed - which can also change which zone intervals can be coalesced. For\nexample, by specifying just the <xref href=\"NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions\" data-throw-if-not-resolved=\"false\"></xref> option, you would indicate that even though you don't care about the name within a zone\ninterval or how the wall offset is calculated, you do care about the fact that there was a transition at all, and when it occurred.\nWith that option enabled, zone intervals are never coalesced and the transition points within the operating interval are checked.\n</p>\n<p>Similarly, the <xref href=\"NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions\" data-throw-if-not-resolved=\"false\"></xref> option is the only one where instants outside the operating interval are\nrelevant. For example, consider a comparer which operates over the interval [2000-01-01T00:00:00Z, 2011-01-01T00:00:00Z). Normally,\nanything that happens before the year 2000 (UTC) would be irrelevant - but with this option enabled, the transitions of the first and last zone\nintervals are part of the comparison... so if one time zone has a zone interval 1999-09-01T00:00:00Z to 2000-03-01T00:00:00Z and the other has\na zone interval 1999-10-15T00:00:00Z to 2000-03-01T00:00:Z, the two zones would be considered unequal, despite the fact that the only instants observing\nthe difference occur outside the operating interval.\n</p>\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Flags]

          public enum Options
        VB: >-
          <Flags>

          Public Enum Options
    attributes:
    - type: System.FlagsAttribute
      ctor: System.FlagsAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset
      commentId: F:NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset
      language: CSharp
      name:
        CSharp: OnlyMatchWallOffset
        VB: OnlyMatchWallOffset
      nameWithType:
        CSharp: ZoneEqualityComparer.Options.OnlyMatchWallOffset
        VB: ZoneEqualityComparer.Options.OnlyMatchWallOffset
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset
        VB: NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: OnlyMatchWallOffset
        path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        startLine: 64
      summary: "\nThe default comparison, which only cares about the wall offset at any particular\ninstant, within the interval of the comparer. In other words, if <xref href=\"NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)\" data-throw-if-not-resolved=\"false\"></xref>\nreturns the same value for all instants in the interval, the comparer will consider the zones to be equal.\n"
      example: []
      syntax:
        content:
          CSharp: OnlyMatchWallOffset = 0
          VB: OnlyMatchWallOffset = 0
        return:
          type: NodaTime.TimeZones.ZoneEqualityComparer.Options
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant): 
    - id: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchOffsetComponents
      commentId: F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchOffsetComponents
      language: CSharp
      name:
        CSharp: MatchOffsetComponents
        VB: MatchOffsetComponents
      nameWithType:
        CSharp: ZoneEqualityComparer.Options.MatchOffsetComponents
        VB: ZoneEqualityComparer.Options.MatchOffsetComponents
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchOffsetComponents
        VB: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchOffsetComponents
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MatchOffsetComponents
        path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        startLine: 72
      summary: "\nInstead of only comparing wall offsets, the standard/savings split is also considered. So when this\noption is used, two zones which both have a wall offset of +2 at one instant would be considered\nunequal if one of those offsets was +1 standard, +1 savings and the other was +2 standard with no daylight\nsaving.\n"
      example: []
      syntax:
        content:
          CSharp: MatchOffsetComponents = 1
          VB: MatchOffsetComponents = 1
        return:
          type: NodaTime.TimeZones.ZoneEqualityComparer.Options
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchNames
      commentId: F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchNames
      language: CSharp
      name:
        CSharp: MatchNames
        VB: MatchNames
      nameWithType:
        CSharp: ZoneEqualityComparer.Options.MatchNames
        VB: ZoneEqualityComparer.Options.MatchNames
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchNames
        VB: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchNames
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MatchNames
        path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        startLine: 77
      summary: "\nCompare the names of zone intervals as well as offsets.\n"
      example: []
      syntax:
        content:
          CSharp: MatchNames = 2
          VB: MatchNames = 2
        return:
          type: NodaTime.TimeZones.ZoneEqualityComparer.Options
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions
      commentId: F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions
      language: CSharp
      name:
        CSharp: MatchAllTransitions
        VB: MatchAllTransitions
      nameWithType:
        CSharp: ZoneEqualityComparer.Options.MatchAllTransitions
        VB: ZoneEqualityComparer.Options.MatchAllTransitions
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions
        VB: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MatchAllTransitions
        path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        startLine: 83
      summary: "\nThis option prevents adjacent zone intervals from being coalesced, even if they are otherwise considered\nequivalent according to other options.\n"
      example: []
      syntax:
        content:
          CSharp: MatchAllTransitions = 4
          VB: MatchAllTransitions = 4
        return:
          type: NodaTime.TimeZones.ZoneEqualityComparer.Options
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions
      commentId: F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions
      language: CSharp
      name:
        CSharp: MatchStartAndEndTransitions
        VB: MatchStartAndEndTransitions
      nameWithType:
        CSharp: ZoneEqualityComparer.Options.MatchStartAndEndTransitions
        VB: ZoneEqualityComparer.Options.MatchStartAndEndTransitions
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions
        VB: NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MatchStartAndEndTransitions
        path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        startLine: 90
      summary: "\nIncludes the transitions into the first zone interval and out of the\nlast zone interval as part of the comparison, even if they do not affect\nthe offset or name for any instant within the operating interval.\n"
      example: []
      syntax:
        content:
          CSharp: MatchStartAndEndTransitions = 8
          VB: MatchStartAndEndTransitions = 8
        return:
          type: NodaTime.TimeZones.ZoneEqualityComparer.Options
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.TimeZones.ZoneEqualityComparer.Options.StrictestMatch
      commentId: F:NodaTime.TimeZones.ZoneEqualityComparer.Options.StrictestMatch
      language: CSharp
      name:
        CSharp: StrictestMatch
        VB: StrictestMatch
      nameWithType:
        CSharp: ZoneEqualityComparer.Options.StrictestMatch
        VB: ZoneEqualityComparer.Options.StrictestMatch
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneEqualityComparer.Options.StrictestMatch
        VB: NodaTime.TimeZones.ZoneEqualityComparer.Options.StrictestMatch
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneEqualityComparer.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: StrictestMatch
        path: src/NodaTime/TimeZones/ZoneEqualityComparer.cs
        startLine: 95
      summary: "\nThe combination of all available match options.\n"
      example: []
      syntax:
        content:
          CSharp: StrictestMatch = 15
          VB: StrictestMatch = 15
        return:
          type: NodaTime.TimeZones.ZoneEqualityComparer.Options
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    references:
      NodaTime.TimeZones.ZoneInterval: 
      NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval): 
      NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset: 
      NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions: 
      NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions: 
  - id: NodaTime.TimeZones.ZoneInterval
    commentId: T:NodaTime.TimeZones.ZoneInterval
    language: CSharp
    name:
      CSharp: ZoneInterval
      VB: ZoneInterval
    nameWithType:
      CSharp: ZoneInterval
      VB: ZoneInterval
    qualifiedName:
      CSharp: NodaTime.TimeZones.ZoneInterval
      VB: NodaTime.TimeZones.ZoneInterval
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: ZoneInterval
      path: src/NodaTime/TimeZones/ZoneInterval.cs
      startLine: 15
    summary: "\nRepresents a range of time for which a particular Offset applies.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class ZoneInterval : IEquatable<ZoneInterval>'
        VB: >-
          Public NotInheritable Class ZoneInterval

              Implements IEquatable(Of ZoneInterval)
    inheritance:
    - System.Object
    implements:
    - System.IEquatable{NodaTime.TimeZones.ZoneInterval}
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.ZoneInterval.#ctor(System.String,NodaTime.Instant,NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)
      commentId: M:NodaTime.TimeZones.ZoneInterval.#ctor(System.String,NodaTime.Instant,NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)
      language: CSharp
      name:
        CSharp: ZoneInterval(String, Instant, Instant, Offset, Offset)
        VB: ZoneInterval(String, Instant, Instant, Offset, Offset)
      nameWithType:
        CSharp: ZoneInterval.ZoneInterval(String, Instant, Instant, Offset, Offset)
        VB: ZoneInterval.ZoneInterval(String, Instant, Instant, Offset, Offset)
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.ZoneInterval(System.String, NodaTime.Instant, NodaTime.Instant, NodaTime.Offset, NodaTime.Offset)
        VB: NodaTime.TimeZones.ZoneInterval.ZoneInterval(System.String, NodaTime.Instant, NodaTime.Instant, NodaTime.Offset, NodaTime.Offset)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 35
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.TimeZones.ZoneInterval\" data-throw-if-not-resolved=\"false\"></xref> class.\n"
      example: []
      syntax:
        content:
          CSharp: public ZoneInterval(string name, Instant start, Instant end, Offset wallOffset, Offset savings)
          VB: Public Sub New(name As String, start As Instant, end As Instant, wallOffset As Offset, savings As Offset)
        parameters:
        - id: name
          type: System.String
          description: The name of this offset period (e.g. PST or PDT).
        - id: start
          type: NodaTime.Instant
          description: The first <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> that the <span class="paramref">wallOffset</span> applies.
        - id: end
          type: NodaTime.Instant
          description: The last <xref href="NodaTime.Instant" data-throw-if-not-resolved="false"></xref> (exclusive) that the <span class="paramref">wallOffset</span> applies.
        - id: wallOffset
          type: NodaTime.Offset
          description: The <xref href="NodaTime.TimeZones.ZoneInterval.WallOffset" data-throw-if-not-resolved="false"></xref> from UTC for this period including any daylight savings.
        - id: savings
          type: NodaTime.Offset
          description: The <xref href="NodaTime.TimeZones.ZoneInterval.WallOffset" data-throw-if-not-resolved="false"></xref> daylight savings contribution to the offset.
      overload: NodaTime.TimeZones.ZoneInterval.#ctor*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: If <code><span class="paramref">start</span> &gt;= <span class="paramref">end</span></code>.
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">name</span> is null.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.TimeZones.ZoneInterval: 
        NodaTime.Instant: 
        NodaTime.TimeZones.ZoneInterval.WallOffset: 
    - id: NodaTime.TimeZones.ZoneInterval.StandardOffset
      commentId: P:NodaTime.TimeZones.ZoneInterval.StandardOffset
      language: CSharp
      name:
        CSharp: StandardOffset
        VB: StandardOffset
      nameWithType:
        CSharp: ZoneInterval.StandardOffset
        VB: ZoneInterval.StandardOffset
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.StandardOffset
        VB: NodaTime.TimeZones.ZoneInterval.StandardOffset
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: StandardOffset
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 74
      summary: "\nGets the standard offset for this period. This is the offset without any daylight savings\ncontributions.\n"
      remarks: "\nThis is effectively <code>Offset - Savings</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public Offset StandardOffset { get; }
          VB: Public ReadOnly Property StandardOffset As Offset
        parameters: []
        return:
          type: NodaTime.Offset
          description: The base Offset.
      overload: NodaTime.TimeZones.ZoneInterval.StandardOffset*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.ZoneInterval.Duration
      commentId: P:NodaTime.TimeZones.ZoneInterval.Duration
      language: CSharp
      name:
        CSharp: Duration
        VB: Duration
      nameWithType:
        CSharp: ZoneInterval.Duration
        VB: ZoneInterval.Duration
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.Duration
        VB: NodaTime.TimeZones.ZoneInterval.Duration
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Duration
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 86
      summary: "\nGets the duration of this period.\n"
      remarks: "\nThis is effectively <code>End - Start</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public Duration Duration { get; }
          VB: Public ReadOnly Property Duration As Duration
        parameters: []
        return:
          type: NodaTime.Duration
          description: The Duration of this period.
      overload: NodaTime.TimeZones.ZoneInterval.Duration*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.ZoneInterval.End
      commentId: P:NodaTime.TimeZones.ZoneInterval.End
      language: CSharp
      name:
        CSharp: End
        VB: End
      nameWithType:
        CSharp: ZoneInterval.End
        VB: ZoneInterval.End
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.End
        VB: NodaTime.TimeZones.ZoneInterval.End
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: End
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 95
      summary: "\nGets the last Instant (exclusive) that the Offset applies.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant End { get; }
          VB: Public ReadOnly Property End As Instant
        parameters: []
        return:
          type: NodaTime.Instant
          description: The last Instant (exclusive) that the Offset applies.
      overload: NodaTime.TimeZones.ZoneInterval.End*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.ZoneInterval.IsoLocalStart
      commentId: P:NodaTime.TimeZones.ZoneInterval.IsoLocalStart
      language: CSharp
      name:
        CSharp: IsoLocalStart
        VB: IsoLocalStart
      nameWithType:
        CSharp: ZoneInterval.IsoLocalStart
        VB: ZoneInterval.IsoLocalStart
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.IsoLocalStart
        VB: NodaTime.TimeZones.ZoneInterval.IsoLocalStart
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: IsoLocalStart
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 128
      summary: "\nReturns the local start time of the interval, as LocalDateTime\nin the ISO calendar.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime IsoLocalStart { get; }
          VB: Public ReadOnly Property IsoLocalStart As LocalDateTime
        parameters: []
        return:
          type: NodaTime.LocalDateTime
      overload: NodaTime.TimeZones.ZoneInterval.IsoLocalStart*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.ZoneInterval.IsoLocalEnd
      commentId: P:NodaTime.TimeZones.ZoneInterval.IsoLocalEnd
      language: CSharp
      name:
        CSharp: IsoLocalEnd
        VB: IsoLocalEnd
      nameWithType:
        CSharp: ZoneInterval.IsoLocalEnd
        VB: ZoneInterval.IsoLocalEnd
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.IsoLocalEnd
        VB: NodaTime.TimeZones.ZoneInterval.IsoLocalEnd
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: IsoLocalEnd
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 137
      summary: "\nReturns the local start time of the interval, as LocalDateTime\nin the ISO calendar. This does not include any daylight saving \n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime IsoLocalEnd { get; }
          VB: Public ReadOnly Property IsoLocalEnd As LocalDateTime
        parameters: []
        return:
          type: NodaTime.LocalDateTime
      overload: NodaTime.TimeZones.ZoneInterval.IsoLocalEnd*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.ZoneInterval.Name
      commentId: P:NodaTime.TimeZones.ZoneInterval.Name
      language: CSharp
      name:
        CSharp: Name
        VB: Name
      nameWithType:
        CSharp: ZoneInterval.Name
        VB: ZoneInterval.Name
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.Name
        VB: NodaTime.TimeZones.ZoneInterval.Name
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Name
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 146
      summary: "\nGets the name of this offset period (e.g. PST or PDT).\n"
      example: []
      syntax:
        content:
          CSharp: public string Name { get; }
          VB: Public ReadOnly Property Name As String
        parameters: []
        return:
          type: System.String
          description: The name of this offset period (e.g. PST or PDT).
      overload: NodaTime.TimeZones.ZoneInterval.Name*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.ZoneInterval.WallOffset
      commentId: P:NodaTime.TimeZones.ZoneInterval.WallOffset
      language: CSharp
      name:
        CSharp: WallOffset
        VB: WallOffset
      nameWithType:
        CSharp: ZoneInterval.WallOffset
        VB: ZoneInterval.WallOffset
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.WallOffset
        VB: NodaTime.TimeZones.ZoneInterval.WallOffset
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WallOffset
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 155
      summary: "\nGets the offset from UTC for this period. This includes any daylight savings value.\n"
      example: []
      syntax:
        content:
          CSharp: public Offset WallOffset { get; }
          VB: Public ReadOnly Property WallOffset As Offset
        parameters: []
        return:
          type: NodaTime.Offset
          description: The offset from UTC for this period.
      overload: NodaTime.TimeZones.ZoneInterval.WallOffset*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.ZoneInterval.Savings
      commentId: P:NodaTime.TimeZones.ZoneInterval.Savings
      language: CSharp
      name:
        CSharp: Savings
        VB: Savings
      nameWithType:
        CSharp: ZoneInterval.Savings
        VB: ZoneInterval.Savings
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.Savings
        VB: NodaTime.TimeZones.ZoneInterval.Savings
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Savings
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 164
      summary: "\nGets the daylight savings value for this period.\n"
      example: []
      syntax:
        content:
          CSharp: public Offset Savings { get; }
          VB: Public ReadOnly Property Savings As Offset
        parameters: []
        return:
          type: NodaTime.Offset
          description: The savings value.
      overload: NodaTime.TimeZones.ZoneInterval.Savings*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.ZoneInterval.Start
      commentId: P:NodaTime.TimeZones.ZoneInterval.Start
      language: CSharp
      name:
        CSharp: Start
        VB: Start
      nameWithType:
        CSharp: ZoneInterval.Start
        VB: ZoneInterval.Start
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.Start
        VB: NodaTime.TimeZones.ZoneInterval.Start
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Start
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 173
      summary: "\nGets the first Instant that the Offset applies.\n"
      example: []
      syntax:
        content:
          CSharp: public Instant Start { get; }
          VB: Public ReadOnly Property Start As Instant
        parameters: []
        return:
          type: NodaTime.Instant
          description: The first Instant that the Offset applies.
      overload: NodaTime.TimeZones.ZoneInterval.Start*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.Instant)
      commentId: M:NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.Instant)
      language: CSharp
      name:
        CSharp: Contains(Instant)
        VB: Contains(Instant)
      nameWithType:
        CSharp: ZoneInterval.Contains(Instant)
        VB: ZoneInterval.Contains(Instant)
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.Instant)
        VB: NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.Instant)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Contains
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 191
      summary: "\nDetermines whether this period contains the given Instant in its range.\n"
      remarks: "\nUsually this is half-open, i.e. the end is exclusive, but an interval with an end point of \"the end of time\" \nis deemed to be inclusive at the end.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Contains(Instant instant)
          VB: Public Function Contains(instant As Instant) As Boolean
        parameters:
        - id: instant
          type: NodaTime.Instant
          description: The instant to test.
        return:
          type: System.Boolean
          description: "\n<code>true</code> if this period contains the given Instant in its range; otherwise, <code>false</code>.\n"
      overload: NodaTime.TimeZones.ZoneInterval.Contains*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.TimeZones.ZoneInterval.Equals(NodaTime.TimeZones.ZoneInterval)
      commentId: M:NodaTime.TimeZones.ZoneInterval.Equals(NodaTime.TimeZones.ZoneInterval)
      language: CSharp
      name:
        CSharp: Equals(ZoneInterval)
        VB: Equals(ZoneInterval)
      nameWithType:
        CSharp: ZoneInterval.Equals(ZoneInterval)
        VB: ZoneInterval.Equals(ZoneInterval)
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.Equals(NodaTime.TimeZones.ZoneInterval)
        VB: NodaTime.TimeZones.ZoneInterval.Equals(NodaTime.TimeZones.ZoneInterval)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 220
      summary: "\nIndicates whether the current object is equal to another object of the same type.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Equals(ZoneInterval other)
          VB: Public Function Equals(other As ZoneInterval) As Boolean
        parameters:
        - id: other
          type: NodaTime.TimeZones.ZoneInterval
          description: >
            An object to compare with this object.
        return:
          type: System.Boolean
          description: "\ntrue if the current object is equal to the <span class=\"paramref\">other</span> parameter; otherwise, false.\n"
      overload: NodaTime.TimeZones.ZoneInterval.Equals*
      implements:
      - System.IEquatable{NodaTime.TimeZones.ZoneInterval}.Equals(NodaTime.TimeZones.ZoneInterval)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.TimeZones.ZoneInterval.Equals(System.Object)
      commentId: M:NodaTime.TimeZones.ZoneInterval.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: ZoneInterval.Equals(Object)
        VB: ZoneInterval.Equals(Object)
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.Equals(System.Object)
        VB: NodaTime.TimeZones.ZoneInterval.Equals(System.Object)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Equals
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 244
      summary: "\nDetermines whether the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to the current <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: The <xref href="System.Object" data-throw-if-not-resolved="false"></xref> to compare with the current <xref href="System.Object" data-throw-if-not-resolved="false"></xref>.
        return:
          type: System.Boolean
          description: "\n<code>true</code> if the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to the current <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>; otherwise, <code>false</code>.\n"
      overload: NodaTime.TimeZones.ZoneInterval.Equals*
      overridden: System.Object.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.Object: 
    - id: NodaTime.TimeZones.ZoneInterval.GetHashCode
      commentId: M:NodaTime.TimeZones.ZoneInterval.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: ZoneInterval.GetHashCode()
        VB: ZoneInterval.GetHashCode()
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.GetHashCode()
        VB: NodaTime.TimeZones.ZoneInterval.GetHashCode()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetHashCode
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 257
      summary: "\nServes as a hash function for a particular type.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: "\nA hash code for the current <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      overload: NodaTime.TimeZones.ZoneInterval.GetHashCode*
      overridden: System.Object.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.Object: 
    - id: NodaTime.TimeZones.ZoneInterval.ToString
      commentId: M:NodaTime.TimeZones.ZoneInterval.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: ZoneInterval.ToString()
        VB: ZoneInterval.ToString()
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneInterval.ToString()
        VB: NodaTime.TimeZones.ZoneInterval.ToString()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneInterval.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToString
        path: src/NodaTime/TimeZones/ZoneInterval.cs
        startLine: 274
      summary: "\nReturns a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nA <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that represents this instance.\n"
      overload: NodaTime.TimeZones.ZoneInterval.ToString*
      overridden: System.Object.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
      references:
        System.String: 
  - id: NodaTime.TimeZones.ZoneLocalMapping
    commentId: T:NodaTime.TimeZones.ZoneLocalMapping
    language: CSharp
    name:
      CSharp: ZoneLocalMapping
      VB: ZoneLocalMapping
    nameWithType:
      CSharp: ZoneLocalMapping
      VB: ZoneLocalMapping
    qualifiedName:
      CSharp: NodaTime.TimeZones.ZoneLocalMapping
      VB: NodaTime.TimeZones.ZoneLocalMapping
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/ZoneLocalMapping.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: ZoneLocalMapping
      path: src/NodaTime/TimeZones/ZoneLocalMapping.cs
      startLine: 47
    summary: "\nThe result of mapping a <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> within a time zone, i.e. finding out\nat what \"global\" time the \"local\" time occurred.\n"
    remarks: "\n<p>\nThis class is used as the return type of <xref href=\"NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)\" data-throw-if-not-resolved=\"false\"></xref>. It allows for\nfinely-grained handling of the three possible results:\n</p>\n<ul><li>Unambiguous mappingThe local time occurs exactly once in the target time zone.</li><li>Ambiguous mapping\n      The local time occurs twice in the target time zone, due to the offset from UTC\n      changing. This usually occurs for an autumnal daylight saving transition, where the clocks\n      are put back by an hour. If the clocks change from 2am to 1am for example, then 1:30am occurs\n      twice - once before the transition and once afterwards.\n</li><li>Impossible mapping\n  The local time does not occur at all in the target time zone, due to the offset from UTC\n  changing. This usually occurs for a vernal (spring-time) daylight saving transition, where the clocks\n  are put forward by an hour. If the clocks change from 1am to 2am for example, then 1:30am is\n  skipped entirely.\n</li></ul>\n"
    example: []
    syntax:
      content:
        CSharp: public sealed class ZoneLocalMapping
        VB: Public NotInheritable Class ZoneLocalMapping
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.ZoneLocalMapping.Count
      commentId: P:NodaTime.TimeZones.ZoneLocalMapping.Count
      language: CSharp
      name:
        CSharp: Count
        VB: Count
      nameWithType:
        CSharp: ZoneLocalMapping.Count
        VB: ZoneLocalMapping.Count
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneLocalMapping.Count
        VB: NodaTime.TimeZones.ZoneLocalMapping.Count
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneLocalMapping.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Count
        path: src/NodaTime/TimeZones/ZoneLocalMapping.cs
        startLine: 69
      summary: "\nReturns the number of results within this mapping: the number of distinct\n<xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> values which map to the original <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public int Count { get; }
          VB: Public ReadOnly Property Count As Integer
        parameters: []
        return:
          type: System.Int32
      overload: NodaTime.TimeZones.ZoneLocalMapping.Count*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.ZonedDateTime: 
        NodaTime.LocalDateTime: 
    - id: NodaTime.TimeZones.ZoneLocalMapping.Zone
      commentId: P:NodaTime.TimeZones.ZoneLocalMapping.Zone
      language: CSharp
      name:
        CSharp: Zone
        VB: Zone
      nameWithType:
        CSharp: ZoneLocalMapping.Zone
        VB: ZoneLocalMapping.Zone
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneLocalMapping.Zone
        VB: NodaTime.TimeZones.ZoneLocalMapping.Zone
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneLocalMapping.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Zone
        path: src/NodaTime/TimeZones/ZoneLocalMapping.cs
        startLine: 74
      summary: "\nReturns the <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref> in which this mapping was performed.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTimeZone Zone { get; }
          VB: Public ReadOnly Property Zone As DateTimeZone
        parameters: []
        return:
          type: NodaTime.DateTimeZone
      overload: NodaTime.TimeZones.ZoneLocalMapping.Zone*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.DateTimeZone: 
    - id: NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime
      commentId: P:NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime
      language: CSharp
      name:
        CSharp: LocalDateTime
        VB: LocalDateTime
      nameWithType:
        CSharp: ZoneLocalMapping.LocalDateTime
        VB: ZoneLocalMapping.LocalDateTime
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime
        VB: NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneLocalMapping.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: LocalDateTime
        path: src/NodaTime/TimeZones/ZoneLocalMapping.cs
        startLine: 79
      summary: "\nReturns the <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> which was mapped with in the time zone.\n"
      example: []
      syntax:
        content:
          CSharp: public LocalDateTime LocalDateTime { get; }
          VB: Public ReadOnly Property LocalDateTime As LocalDateTime
        parameters: []
        return:
          type: NodaTime.LocalDateTime
      overload: NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.LocalDateTime: 
    - id: NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval
      commentId: P:NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval
      language: CSharp
      name:
        CSharp: EarlyInterval
        VB: EarlyInterval
      nameWithType:
        CSharp: ZoneLocalMapping.EarlyInterval
        VB: ZoneLocalMapping.EarlyInterval
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval
        VB: NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneLocalMapping.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: EarlyInterval
        path: src/NodaTime/TimeZones/ZoneLocalMapping.cs
        startLine: 87
      summary: "\nReturns the earlier <xref href=\"NodaTime.TimeZones.ZoneInterval\" data-throw-if-not-resolved=\"false\"></xref> within this mapping. For unambiguous\nmappings, this is the same as <xref href=\"NodaTime.TimeZones.ZoneLocalMapping.LateInterval\" data-throw-if-not-resolved=\"false\"></xref>; for ambiguous mappings,\nthis is the interval during which the mapped local time first occurs; for impossible\nmappings, this is the interval before which the mapped local time occurs.\n"
      example: []
      syntax:
        content:
          CSharp: public ZoneInterval EarlyInterval { get; }
          VB: Public ReadOnly Property EarlyInterval As ZoneInterval
        parameters: []
        return:
          type: NodaTime.TimeZones.ZoneInterval
      overload: NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.TimeZones.ZoneInterval: 
        NodaTime.TimeZones.ZoneLocalMapping.LateInterval: 
    - id: NodaTime.TimeZones.ZoneLocalMapping.LateInterval
      commentId: P:NodaTime.TimeZones.ZoneLocalMapping.LateInterval
      language: CSharp
      name:
        CSharp: LateInterval
        VB: LateInterval
      nameWithType:
        CSharp: ZoneLocalMapping.LateInterval
        VB: ZoneLocalMapping.LateInterval
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneLocalMapping.LateInterval
        VB: NodaTime.TimeZones.ZoneLocalMapping.LateInterval
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneLocalMapping.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: LateInterval
        path: src/NodaTime/TimeZones/ZoneLocalMapping.cs
        startLine: 95
      summary: "\nReturns the later <xref href=\"NodaTime.TimeZones.ZoneInterval\" data-throw-if-not-resolved=\"false\"></xref> within this mapping. For unambiguous\nmappings, this is the same as <xref href=\"NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval\" data-throw-if-not-resolved=\"false\"></xref>; for ambiguous mappings,\nthis is the interval during which the mapped local time last occurs; for impossible\nmappings, this is the interval after which the mapped local time occurs.\n"
      example: []
      syntax:
        content:
          CSharp: public ZoneInterval LateInterval { get; }
          VB: Public ReadOnly Property LateInterval As ZoneInterval
        parameters: []
        return:
          type: NodaTime.TimeZones.ZoneInterval
      overload: NodaTime.TimeZones.ZoneLocalMapping.LateInterval*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.TimeZones.ZoneInterval: 
        NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval: 
    - id: NodaTime.TimeZones.ZoneLocalMapping.Single
      commentId: M:NodaTime.TimeZones.ZoneLocalMapping.Single
      language: CSharp
      name:
        CSharp: Single()
        VB: Single()
      nameWithType:
        CSharp: ZoneLocalMapping.Single()
        VB: ZoneLocalMapping.Single()
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneLocalMapping.Single()
        VB: NodaTime.TimeZones.ZoneLocalMapping.Single()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneLocalMapping.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Single
        path: src/NodaTime/TimeZones/ZoneLocalMapping.cs
        startLine: 104
      summary: "\nReturns the single <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> which maps to the original\n<xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref> in the mapped <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref>.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime Single()
          VB: Public Function Single As ZonedDateTime
        return:
          type: NodaTime.ZonedDateTime
          description: The unambiguous result of mapping the local date/time in the time zone.
      overload: NodaTime.TimeZones.ZoneLocalMapping.Single*
      exceptions:
      - type: NodaTime.SkippedTimeException
        commentId: T:NodaTime.SkippedTimeException
        description: The local date/time was skipped in the time zone.
      - type: NodaTime.AmbiguousTimeException
        commentId: T:NodaTime.AmbiguousTimeException
        description: The local date/time was ambiguous in the time zone.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
        NodaTime.LocalDateTime: 
        NodaTime.DateTimeZone: 
    - id: NodaTime.TimeZones.ZoneLocalMapping.First
      commentId: M:NodaTime.TimeZones.ZoneLocalMapping.First
      language: CSharp
      name:
        CSharp: First()
        VB: First()
      nameWithType:
        CSharp: ZoneLocalMapping.First()
        VB: ZoneLocalMapping.First()
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneLocalMapping.First()
        VB: NodaTime.TimeZones.ZoneLocalMapping.First()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneLocalMapping.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: First
        path: src/NodaTime/TimeZones/ZoneLocalMapping.cs
        startLine: 125
      summary: "\nReturns a <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> which maps to the original <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref>\nin the mapped <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref>: either the single result if the mapping is unambiguous,\nor the earlier result if the local date/time occurs twice in the time zone due to a time zone\noffset change such as an autumnal daylight saving transition.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime First()
          VB: Public Function First As ZonedDateTime
        return:
          type: NodaTime.ZonedDateTime
          description: The unambiguous result of mapping a local date/time in a time zone.
      overload: NodaTime.TimeZones.ZoneLocalMapping.First*
      exceptions:
      - type: NodaTime.SkippedTimeException
        commentId: T:NodaTime.SkippedTimeException
        description: The local date/time was skipped in the time zone.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
        NodaTime.LocalDateTime: 
        NodaTime.DateTimeZone: 
    - id: NodaTime.TimeZones.ZoneLocalMapping.Last
      commentId: M:NodaTime.TimeZones.ZoneLocalMapping.Last
      language: CSharp
      name:
        CSharp: Last()
        VB: Last()
      nameWithType:
        CSharp: ZoneLocalMapping.Last()
        VB: ZoneLocalMapping.Last()
      qualifiedName:
        CSharp: NodaTime.TimeZones.ZoneLocalMapping.Last()
        VB: NodaTime.TimeZones.ZoneLocalMapping.Last()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/ZoneLocalMapping.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Last
        path: src/NodaTime/TimeZones/ZoneLocalMapping.cs
        startLine: 144
      summary: "\nReturns a <xref href=\"NodaTime.ZonedDateTime\" data-throw-if-not-resolved=\"false\"></xref> which maps to the original <xref href=\"NodaTime.LocalDateTime\" data-throw-if-not-resolved=\"false\"></xref>\nin the mapped <xref href=\"NodaTime.DateTimeZone\" data-throw-if-not-resolved=\"false\"></xref>: either the single result if the mapping is unambiguous,\nor the later result if the local date/time occurs twice in the time zone due to a time zone\noffset change such as an autumnal daylight saving transition.\n"
      example: []
      syntax:
        content:
          CSharp: public ZonedDateTime Last()
          VB: Public Function Last As ZonedDateTime
        return:
          type: NodaTime.ZonedDateTime
          description: The unambiguous result of mapping a local date/time in a time zone.
      overload: NodaTime.TimeZones.ZoneLocalMapping.Last*
      exceptions:
      - type: NodaTime.SkippedTimeException
        commentId: T:NodaTime.SkippedTimeException
        description: The local date/time was skipped in the time zone.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.ZonedDateTime: 
        NodaTime.LocalDateTime: 
        NodaTime.DateTimeZone: 
    references:
      NodaTime.LocalDateTime: 
      NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime): 
  - id: NodaTime.TimeZones.TzdbDateTimeZoneSource
    commentId: T:NodaTime.TimeZones.TzdbDateTimeZoneSource
    language: CSharp
    name:
      CSharp: TzdbDateTimeZoneSource
      VB: TzdbDateTimeZoneSource
    nameWithType:
      CSharp: TzdbDateTimeZoneSource
      VB: TzdbDateTimeZoneSource
    qualifiedName:
      CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource
      VB: NodaTime.TimeZones.TzdbDateTimeZoneSource
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: TzdbDateTimeZoneSource
      path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
      startLine: 28
    summary: "\nProvides an implementation of <xref href=\"NodaTime.TimeZones.IDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> that loads data originating from the\n<a href=\"http://www.iana.org/time-zones\">tz database</a> (also known as the IANA Time Zone database, or zoneinfo\nor Olson database).\n"
    remarks: "\nAll calls to <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)\" data-throw-if-not-resolved=\"false\"></xref> for fixed-offset IDs advertised by the source (i.e. \"UTC\" and \"UTC+/-Offset\")\nwill return zones equal to those returned by <xref href=\"NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class TzdbDateTimeZoneSource : IDateTimeZoneSource'
        VB: >-
          Public NotInheritable Class TzdbDateTimeZoneSource

              Implements IDateTimeZoneSource
    inheritance:
    - System.Object
    implements:
    - NodaTime.TimeZones.IDateTimeZoneSource
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.Default
      commentId: P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Default
      language: CSharp
      name:
        CSharp: Default
        VB: Default
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.Default
        VB: TzdbDateTimeZoneSource.Default
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.Default
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.Default
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Default
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 33
      summary: "\nThe <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> initialised from resources within the NodaTime assembly.\n"
      example: []
      syntax:
        content:
          CSharp: public static TzdbDateTimeZoneSource Default { get; }
          VB: Public Shared ReadOnly Property Default As TzdbDateTimeZoneSource
        parameters: []
        return:
          type: NodaTime.TimeZones.TzdbDateTimeZoneSource
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.Default*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource: 
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.String)
      commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.String)
      language: CSharp
      name:
        CSharp: TzdbDateTimeZoneSource(String)
        VB: TzdbDateTimeZoneSource(String)
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(String)
        VB: TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(String)
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(System.String)
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(System.String)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 86
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> class from a resource within\nthe NodaTime assembly.\n"
      remarks: >-
        For backwards compatibility, this will use the blob time zone data when given the same

        base name which would previously have loaded the now-obsolete resource data.
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("Use TzdbDateTimeZoneSource.Default to access the only TZDB resources within the NodaTime assembly")]

            public TzdbDateTimeZoneSource(string baseName)
          VB: >-
            <Obsolete("Use TzdbDateTimeZoneSource.Default to access the only TZDB resources within the NodaTime assembly")>

            Public Sub New(baseName As String)
        parameters:
        - id: baseName
          type: System.String
          description: The root name of the resource file.
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor*
      exceptions:
      - type: NodaTime.Utility.InvalidNodaDataException
        commentId: T:NodaTime.Utility.InvalidNodaDataException
        description: The data within the resource is invalid.
      - type: System.Resources.MissingManifestResourceException
        commentId: T:System.Resources.MissingManifestResourceException
        description: The resource set cannot be found.
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: Use TzdbDateTimeZoneSource.Default to access the only TZDB resources within the NodaTime assembly
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource: 
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.String,System.Reflection.Assembly)
      commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.String,System.Reflection.Assembly)
      language: CSharp
      name:
        CSharp: TzdbDateTimeZoneSource(String, Assembly)
        VB: TzdbDateTimeZoneSource(String, Assembly)
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(String, Assembly)
        VB: TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(String, Assembly)
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(System.String, System.Reflection.Assembly)
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(System.String, System.Reflection.Assembly)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 102
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> class.\n"
      remarks: >-
        For backwards compatibility, this will use the blob time zone data when given the same

        base name which would previously have loaded the now-obsolete resource data from the Noda Time assembly

        itself.
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The resource format for time zone data is deprecated; future versions will only support blob-based data")]

            public TzdbDateTimeZoneSource(string baseName, Assembly assembly)
          VB: >-
            <Obsolete("The resource format for time zone data is deprecated; future versions will only support blob-based data")>

            Public Sub New(baseName As String, assembly As Assembly)
        parameters:
        - id: baseName
          type: System.String
          description: The root name of the resource file.
        - id: assembly
          type: System.Reflection.Assembly
          description: The assembly to search for the time zone resources.
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor*
      exceptions:
      - type: NodaTime.Utility.InvalidNodaDataException
        commentId: T:NodaTime.Utility.InvalidNodaDataException
        description: The data within the resource is invalid.
      - type: System.Resources.MissingManifestResourceException
        commentId: T:System.Resources.MissingManifestResourceException
        description: The resource set cannot be found.
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The resource format for time zone data is deprecated; future versions will only support blob-based data
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource: 
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.Resources.ResourceSet)
      commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.Resources.ResourceSet)
      language: CSharp
      name:
        CSharp: TzdbDateTimeZoneSource(ResourceSet)
        VB: TzdbDateTimeZoneSource(ResourceSet)
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(ResourceSet)
        VB: TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(ResourceSet)
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(System.Resources.ResourceSet)
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(System.Resources.ResourceSet)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 113
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> class.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The resource format for time zone data is deprecated; future versions will only support blob-based data")]

            public TzdbDateTimeZoneSource(ResourceSet source)
          VB: >-
            <Obsolete("The resource format for time zone data is deprecated; future versions will only support blob-based data")>

            Public Sub New(source As ResourceSet)
        parameters:
        - id: source
          type: System.Resources.ResourceSet
          description: The <xref href="System.Resources.ResourceSet" data-throw-if-not-resolved="false"></xref> to search for the time zone resources.
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor*
      exceptions:
      - type: NodaTime.Utility.InvalidNodaDataException
        commentId: T:NodaTime.Utility.InvalidNodaDataException
        description: The data within the resource set is invalid.
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The resource format for time zone data is deprecated; future versions will only support blob-based data
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource: 
        System.Resources.ResourceSet: 
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.Resources.ResourceManager)
      commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.Resources.ResourceManager)
      language: CSharp
      name:
        CSharp: TzdbDateTimeZoneSource(ResourceManager)
        VB: TzdbDateTimeZoneSource(ResourceManager)
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(ResourceManager)
        VB: TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(ResourceManager)
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(System.Resources.ResourceManager)
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbDateTimeZoneSource(System.Resources.ResourceManager)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 124
      summary: "\nInitializes a new instance of the <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> class.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The resource format for time zone data is deprecated; future versions will only support blob-based data")]

            public TzdbDateTimeZoneSource(ResourceManager manager)
          VB: >-
            <Obsolete("The resource format for time zone data is deprecated; future versions will only support blob-based data")>

            Public Sub New(manager As ResourceManager)
        parameters:
        - id: manager
          type: System.Resources.ResourceManager
          description: The <xref href="System.Resources.ResourceManager" data-throw-if-not-resolved="false"></xref> to search for the time zone resources.
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor*
      exceptions:
      - type: NodaTime.Utility.InvalidNodaDataException
        commentId: T:NodaTime.Utility.InvalidNodaDataException
        description: The data within the resource manager is invalid.
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The resource format for time zone data is deprecated; future versions will only support blob-based data
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource: 
        System.Resources.ResourceManager: 
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream(System.IO.Stream)
      commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream(System.IO.Stream)
      language: CSharp
      name:
        CSharp: FromStream(Stream)
        VB: FromStream(Stream)
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.FromStream(Stream)
        VB: TzdbDateTimeZoneSource.FromStream(Stream)
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream(System.IO.Stream)
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream(System.IO.Stream)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FromStream
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 151
      summary: "\nCreates an instance from a stream in the custom Noda Time format. The stream must be readable.\n"
      remarks: "\n<p>\nThe stream is not closed by this method, but will be read from\nwithout rewinding. A successful call will read the stream to the end.\n</p>\n<p>\nSee the user guide for instructions on how to generate an updated time zone database file from a copy of the\n(textual) tz database.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public static TzdbDateTimeZoneSource FromStream(Stream stream)
          VB: Public Shared Function FromStream(stream As Stream) As TzdbDateTimeZoneSource
        parameters:
        - id: stream
          type: System.IO.Stream
          description: The stream containing time zone data
        return:
          type: NodaTime.TimeZones.TzdbDateTimeZoneSource
          description: A <code>TzdbDateTimeZoneSource</code> providing information from the given stream.
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: <span class="paramref">stream</span> is null.
      - type: NodaTime.Utility.InvalidNodaDataException
        commentId: T:NodaTime.Utility.InvalidNodaDataException
        description: >-
          The stream contains invalid time zone data, or data which cannot

          be read by this version of Noda Time.
      - type: System.IO.IOException
        commentId: T:System.IO.IOException
        description: Reading from the stream failed.
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: The supplied stream doesn't support reading.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)
      commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)
      language: CSharp
      name:
        CSharp: ForId(String)
        VB: ForId(String)
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.ForId(String)
        VB: TzdbDateTimeZoneSource.ForId(String)
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ForId
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 172
      example: []
      syntax:
        content:
          CSharp: public DateTimeZone ForId(string id)
          VB: Public Function ForId(id As String) As DateTimeZone
        parameters:
        - id: id
          type: System.String
        return:
          type: NodaTime.DateTimeZone
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId*
      implements:
      - NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds
      commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds
      language: CSharp
      name:
        CSharp: GetIds()
        VB: GetIds()
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.GetIds()
        VB: TzdbDateTimeZoneSource.GetIds()
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds()
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: GetIds
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 183
      example: []
      syntax:
        content:
          CSharp: public IEnumerable<string> GetIds()
          VB: Public Function GetIds As IEnumerable(Of String)
        return:
          type: System.Collections.Generic.IEnumerable{System.String}
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds*
      implements:
      - NodaTime.TimeZones.IDateTimeZoneSource.GetIds
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId
      commentId: P:NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId
      language: CSharp
      name:
        CSharp: VersionId
        VB: VersionId
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.VersionId
        VB: TzdbDateTimeZoneSource.VersionId
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: VersionId
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 200
      remarks: "\n<p>\nThis source returns a string such as \"TZDB: 2013b (mapping: 8274)\" corresponding to the versions of the tz\ndatabase and the CLDR Windows zones mapping file.\n</p>\n<p>\nNote that there is no need to parse this string to extract any of the above information, as it is available\ndirectly from the <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"NodaTime.TimeZones.Cldr.WindowsZones.Version\" data-throw-if-not-resolved=\"false\"></xref> properties.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public string VersionId { get; }
          VB: Public ReadOnly Property VersionId As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId*
      implements:
      - NodaTime.TimeZones.IDateTimeZoneSource.VersionId
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion: 
        NodaTime.TimeZones.Cldr.WindowsZones.Version: 
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      language: CSharp
      name:
        CSharp: MapTimeZoneId(TimeZoneInfo)
        VB: MapTimeZoneId(TimeZoneInfo)
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.MapTimeZoneId(TimeZoneInfo)
        VB: TzdbDateTimeZoneSource.MapTimeZoneId(TimeZoneInfo)
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MapTimeZoneId
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 204
      example: []
      syntax:
        content:
          CSharp: public string MapTimeZoneId(TimeZoneInfo zone)
          VB: Public Function MapTimeZoneId(zone As TimeZoneInfo) As String
        parameters:
        - id: zone
          type: System.TimeZoneInfo
          description: The BCL time zone, which must be a known system time zone.
        return:
          type: System.String
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId*
      implements:
      - NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases
      commentId: P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases
      language: CSharp
      name:
        CSharp: Aliases
        VB: Aliases
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.Aliases
        VB: TzdbDateTimeZoneSource.Aliases
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Aliases
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 299
      summary: "\nReturns a lookup from canonical time zone ID (e.g. \"Europe/London\") to a group of aliases for that time zone\n(e.g. {\"Europe/Belfast\", \"Europe/Guernsey\", \"Europe/Jersey\", \"Europe/Isle_of_Man\", \"GB\", \"GB-Eire\"}).\n"
      remarks: "\nThe group of values for a key never contains the canonical ID, only aliases. Any time zone\nID which is itself an alias or has no aliases linking to it will not be present in the lookup.\nThe aliases within a group are returned in alphabetical (ordinal) order.\n"
      example: []
      syntax:
        content:
          CSharp: public ILookup<string, string> Aliases { get; }
          VB: Public ReadOnly Property Aliases As ILookup(Of String, String)
        parameters: []
        return:
          type: System.Linq.ILookup{System.String,System.String}
          description: A lookup from canonical ID to the aliases of that ID.
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap
      commentId: P:NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap
      language: CSharp
      name:
        CSharp: CanonicalIdMap
        VB: CanonicalIdMap
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.CanonicalIdMap
        VB: TzdbDateTimeZoneSource.CanonicalIdMap
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: CanonicalIdMap
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 312
      summary: "\nReturns a read-only map from time zone ID to the canonical ID. For example, the key \"Europe/Jersey\"\nwould be associated with the value \"Europe/London\".\n"
      remarks: "\n<p>This map contains an entry for every ID returned by <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds\" data-throw-if-not-resolved=\"false\"></xref>, where\ncanonical IDs map to themselves.</p>\n<p>The returned map is read-only; any attempts to call a mutating method will throw\n<xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
      example: []
      syntax:
        content:
          CSharp: public IDictionary<string, string> CanonicalIdMap { get; }
          VB: Public ReadOnly Property CanonicalIdMap As IDictionary(Of String, String)
        parameters: []
        return:
          type: System.Collections.Generic.IDictionary{System.String,System.String}
          description: A map from time zone ID to the canonical ID.
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds: 
        System.NotSupportedException: 
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations
      commentId: P:NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations
      language: CSharp
      name:
        CSharp: ZoneLocations
        VB: ZoneLocations
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.ZoneLocations
        VB: TzdbDateTimeZoneSource.ZoneLocations
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ZoneLocations
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 331
      summary: "\nReturns a read-only list of zone locations known to this source.\n"
      remarks: "\n<p>\nEvery zone location's time zone ID is guaranteed to be valid within this source (assuming the source\nhas been validated).\n</p>\n<p>\nThe legacy resource format does not include location information,\nand this property will throw an exception if the information is requested. It is expected\nthat callers who wish to use newer features will not be attempting to use legacy formats\nfor time zone data.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public IList<TzdbZoneLocation> ZoneLocations { get; }
          VB: Public ReadOnly Property ZoneLocations As IList(Of TzdbZoneLocation)
        parameters: []
        return:
          type: System.Collections.Generic.IList{NodaTime.TimeZones.TzdbZoneLocation}
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: >-
          This is a legacy resource-based data source which does

          not include location information.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion
      commentId: P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion
      language: CSharp
      name:
        CSharp: TzdbVersion
        VB: TzdbVersion
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.TzdbVersion
        VB: TzdbDateTimeZoneSource.TzdbVersion
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TzdbVersion
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 346
      summary: "\nReturns just the TZDB version (e.g. \"2013a\") of the source data.\n"
      example: []
      syntax:
        content:
          CSharp: public string TzdbVersion { get; }
          VB: Public ReadOnly Property TzdbVersion As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping
      commentId: P:NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping
      language: CSharp
      name:
        CSharp: WindowsMapping
        VB: WindowsMapping
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.WindowsMapping
        VB: TzdbDateTimeZoneSource.WindowsMapping
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WindowsMapping
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 352
      summary: "\nGets the Windows time zone mapping information provided in the CLDR\nsupplemental \"windowsZones.xml\" file.\n"
      example: []
      syntax:
        content:
          CSharp: public WindowsZones WindowsMapping { get; }
          VB: Public ReadOnly Property WindowsMapping As WindowsZones
        parameters: []
        return:
          type: NodaTime.TimeZones.Cldr.WindowsZones
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate
      commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate
      language: CSharp
      name:
        CSharp: Validate()
        VB: Validate()
      nameWithType:
        CSharp: TzdbDateTimeZoneSource.Validate()
        VB: TzdbDateTimeZoneSource.Validate()
      qualifiedName:
        CSharp: NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate()
        VB: NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate()
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Validate
        path: src/NodaTime/TimeZones/TzdbDateTimeZoneSource.cs
        startLine: 365
      summary: "\nValidates that the data within this source is consistent with itself.\n"
      remarks: "\nSource data is not validated automatically when it's loaded, but any source\nloaded from data produced by <code>NodaTime.TzdbCompiler</code> (including the data shipped with Noda Time)\nwill already have been validated via this method when it was originally produced. This method should\nonly normally be called explicitly if you have data from a source you're unsure of.\n"
      example: []
      syntax:
        content:
          CSharp: public void Validate()
          VB: Public Sub Validate
      overload: NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate*
      exceptions:
      - type: NodaTime.Utility.InvalidNodaDataException
        commentId: T:NodaTime.Utility.InvalidNodaDataException
        description: >-
          The source data is invalid. The source may not function

          correctly.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    references:
      NodaTime.TimeZones.IDateTimeZoneSource: 
      NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String): 
      NodaTime.DateTimeZone.ForOffset(NodaTime.Offset): 
- id: NodaTime.TimeZones.Cldr
  commentId: N:NodaTime.TimeZones.Cldr
  language: CSharp
  name:
    CSharp: NodaTime.TimeZones.Cldr
    VB: NodaTime.TimeZones.Cldr
  nameWithType:
    CSharp: NodaTime.TimeZones.Cldr
    VB: NodaTime.TimeZones.Cldr
  qualifiedName:
    CSharp: NodaTime.TimeZones.Cldr
    VB: NodaTime.TimeZones.Cldr
  type: Namespace
  assemblies:
  - NodaTime
  modifiers: {}
  items:
  - id: NodaTime.TimeZones.Cldr.MapZone
    commentId: T:NodaTime.TimeZones.Cldr.MapZone
    language: CSharp
    name:
      CSharp: MapZone
      VB: MapZone
    nameWithType:
      CSharp: MapZone
      VB: MapZone
    qualifiedName:
      CSharp: NodaTime.TimeZones.Cldr.MapZone
      VB: NodaTime.TimeZones.Cldr.MapZone
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones.Cldr
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/Cldr/MapZone.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: MapZone
      path: src/NodaTime/TimeZones/Cldr/MapZone.cs
      startLine: 15
    summary: "\nRepresents a single <code>&lt;mapZone&gt;</code> element in the CLDR Windows zone mapping file. \n"
    example: []
    syntax:
      content:
        CSharp: public sealed class MapZone
        VB: Public NotInheritable Class MapZone
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory
      commentId: F:NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory
      language: CSharp
      name:
        CSharp: PrimaryTerritory
        VB: PrimaryTerritory
      nameWithType:
        CSharp: MapZone.PrimaryTerritory
        VB: MapZone.PrimaryTerritory
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory
        VB: NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/MapZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PrimaryTerritory
        path: src/NodaTime/TimeZones/Cldr/MapZone.cs
        startLine: 21
      summary: "\nIdentifier used for the primary territory of each Windows time zone. A zone mapping with\nthis territory will always have a single entry. The value of this constant is \"001\".\n"
      example: []
      syntax:
        content:
          CSharp: public const string PrimaryTerritory = "001"
          VB: Public Const PrimaryTerritory As String = "001"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.TimeZones.Cldr.MapZone.FixedOffsetTerritory
      commentId: F:NodaTime.TimeZones.Cldr.MapZone.FixedOffsetTerritory
      language: CSharp
      name:
        CSharp: FixedOffsetTerritory
        VB: FixedOffsetTerritory
      nameWithType:
        CSharp: MapZone.FixedOffsetTerritory
        VB: MapZone.FixedOffsetTerritory
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.MapZone.FixedOffsetTerritory
        VB: NodaTime.TimeZones.Cldr.MapZone.FixedOffsetTerritory
      type: Field
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/MapZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: FixedOffsetTerritory
        path: src/NodaTime/TimeZones/Cldr/MapZone.cs
        startLine: 26
      summary: "\nIdentifier used for the \"fixed offset\" territory. A zone mapping with\nthis territory will always have a single entry. The value of this constant is \"ZZ\".\n"
      example: []
      syntax:
        content:
          CSharp: public const string FixedOffsetTerritory = "ZZ"
          VB: Public Const FixedOffsetTerritory As String = "ZZ"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: NodaTime.TimeZones.Cldr.MapZone.WindowsId
      commentId: P:NodaTime.TimeZones.Cldr.MapZone.WindowsId
      language: CSharp
      name:
        CSharp: WindowsId
        VB: WindowsId
      nameWithType:
        CSharp: MapZone.WindowsId
        VB: MapZone.WindowsId
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.MapZone.WindowsId
        VB: NodaTime.TimeZones.Cldr.MapZone.WindowsId
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/MapZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WindowsId
        path: src/NodaTime/TimeZones/Cldr/MapZone.cs
        startLine: 42
      summary: "\nGets the Windows system time zone identifier for this mapping, such as \"Central Standard Time\".\n"
      remarks: "\n<p>\nMost Windows system time zone identifiers use the name for the \"standard\" part of the zone as\nthe overall identifier. Don't be fooled: just because a time zone includes \"standard\" in its identifier\ndoesn't mean that it doesn't observe daylight saving time.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public string WindowsId { get; }
          VB: Public ReadOnly Property WindowsId As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.Cldr.MapZone.WindowsId*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.Cldr.MapZone.Territory
      commentId: P:NodaTime.TimeZones.Cldr.MapZone.Territory
      language: CSharp
      name:
        CSharp: Territory
        VB: Territory
      nameWithType:
        CSharp: MapZone.Territory
        VB: MapZone.Territory
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.MapZone.Territory
        VB: NodaTime.TimeZones.Cldr.MapZone.Territory
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/MapZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Territory
        path: src/NodaTime/TimeZones/Cldr/MapZone.cs
        startLine: 52
      summary: "\nGets the territory code for this mapping.\n"
      remarks: "\nThis is typically either \"001\" to indicate that it's the primary territory for this ID, or\n\"ZZ\" to indicate a fixed-offset ID, or a different two-character capitalized code\nwhich indicates the geographical territory.\n"
      example: []
      syntax:
        content:
          CSharp: public string Territory { get; }
          VB: Public ReadOnly Property Territory As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.Cldr.MapZone.Territory*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.Cldr.MapZone.TzdbIds
      commentId: P:NodaTime.TimeZones.Cldr.MapZone.TzdbIds
      language: CSharp
      name:
        CSharp: TzdbIds
        VB: TzdbIds
      nameWithType:
        CSharp: MapZone.TzdbIds
        VB: MapZone.TzdbIds
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.MapZone.TzdbIds
        VB: NodaTime.TimeZones.Cldr.MapZone.TzdbIds
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/MapZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TzdbIds
        path: src/NodaTime/TimeZones/Cldr/MapZone.cs
        startLine: 63
      summary: "\nGets a read-only non-empty collection of TZDB zone identifiers for this mapping, such as\n\"America/Chicago\" and \"America/Matamoros\" (both of which are TZDB zones associated with the \"Central Standard Time\"\nWindows system time zone).\n"
      remarks: "\nFor the primary and fixed-offset territory IDs (\"001\" and \"ZZ\") this always\ncontains exactly one time zone ID.\n"
      example: []
      syntax:
        content:
          CSharp: public IList<string> TzdbIds { get; }
          VB: Public ReadOnly Property TzdbIds As IList(Of String)
        parameters: []
        return:
          type: System.Collections.Generic.IList{System.String}
      overload: NodaTime.TimeZones.Cldr.MapZone.TzdbIds*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.Cldr.MapZone.#ctor(System.String,System.String,System.Collections.Generic.IList{System.String})
      commentId: M:NodaTime.TimeZones.Cldr.MapZone.#ctor(System.String,System.String,System.Collections.Generic.IList{System.String})
      language: CSharp
      name:
        CSharp: MapZone(String, String, IList<String>)
        VB: MapZone(String, String, IList(Of String))
      nameWithType:
        CSharp: MapZone.MapZone(String, String, IList<String>)
        VB: MapZone.MapZone(String, String, IList(Of String))
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.MapZone.MapZone(System.String, System.String, System.Collections.Generic.IList<System.String>)
        VB: NodaTime.TimeZones.Cldr.MapZone.MapZone(System.String, System.String, System.Collections.Generic.IList(Of System.String))
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/MapZone.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/TimeZones/Cldr/MapZone.cs
        startLine: 75
      summary: "\nCreates a new mapping entry.\n"
      remarks: "\nThis constructor is only public for the sake of testability.\n"
      example: []
      syntax:
        content:
          CSharp: public MapZone(string windowsId, string territory, IList<string> tzdbIds)
          VB: Public Sub New(windowsId As String, territory As String, tzdbIds As IList(Of String))
        parameters:
        - id: windowsId
          type: System.String
          description: Windows system time zone identifier. Must not be null.
        - id: territory
          type: System.String
          description: Territory code. Must not be null.
        - id: tzdbIds
          type: System.Collections.Generic.IList{System.String}
          description: >-
            List of territory codes. Must not be null, and must not

            contains null values.
      overload: NodaTime.TimeZones.Cldr.MapZone.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
  - id: NodaTime.TimeZones.Cldr.WindowsZones
    commentId: T:NodaTime.TimeZones.Cldr.WindowsZones
    language: CSharp
    name:
      CSharp: WindowsZones
      VB: WindowsZones
    nameWithType:
      CSharp: WindowsZones
      VB: WindowsZones
    qualifiedName:
      CSharp: NodaTime.TimeZones.Cldr.WindowsZones
      VB: NodaTime.TimeZones.Cldr.WindowsZones
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.TimeZones.Cldr
    source:
      remote:
        path: 1.2.x/src/NodaTime/TimeZones/Cldr/WindowsZones.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: WindowsZones
      path: src/NodaTime/TimeZones/Cldr/WindowsZones.cs
      startLine: 20
    summary: "\nRepresentation of the <code>&lt;windowsZones&gt;</code> element of CLDR supplemental data.\n"
    remarks: "\nSee <a href=\"http://cldr.unicode.org/development/development-process/design-proposals/extended-windows-olson-zid-mapping\">the CLDR design proposal</a>\nfor more details of the structure of the file from which data is taken.\n"
    example: []
    syntax:
      content:
        CSharp: public sealed class WindowsZones
        VB: Public NotInheritable Class WindowsZones
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.TimeZones.Cldr.WindowsZones.Version
      commentId: P:NodaTime.TimeZones.Cldr.WindowsZones.Version
      language: CSharp
      name:
        CSharp: Version
        VB: Version
      nameWithType:
        CSharp: WindowsZones.Version
        VB: WindowsZones.Version
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.WindowsZones.Version
        VB: NodaTime.TimeZones.Cldr.WindowsZones.Version
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/WindowsZones.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: Version
        path: src/NodaTime/TimeZones/Cldr/WindowsZones.cs
        startLine: 37
      summary: "\nGets the version of the Windows zones mapping data read from the original file.\n"
      remarks: "\n<p>\nAs with other IDs, this should largely be treated as an opaque string, but the current method for\ngenerating this from the mapping file extracts a number from an element such as <code>&lt;version number=\"$Revision: 7825 $\"/&gt;</code>.\nThis is a Subversion revision number, but that association should only be used for diagnostic curiosity, and never\nassumed in code.\n</p>\n<p>\nThis property will never return a null value.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public string Version { get; }
          VB: Public ReadOnly Property Version As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.Cldr.WindowsZones.Version*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion
      commentId: P:NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion
      language: CSharp
      name:
        CSharp: TzdbVersion
        VB: TzdbVersion
      nameWithType:
        CSharp: WindowsZones.TzdbVersion
        VB: WindowsZones.TzdbVersion
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion
        VB: NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/WindowsZones.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: TzdbVersion
        path: src/NodaTime/TimeZones/Cldr/WindowsZones.cs
        startLine: 55
      summary: "\nGets the TZDB version this Windows zone mapping data was created from.\n"
      remarks: "\n<p>\nThe CLDR mapping file usually lags behind the TZDB file somewhat - partly because the\nmappings themselves don't always change when the time zone data does. For example, it's entirely\nreasonable for a <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource\" data-throw-if-not-resolved=\"false\"></xref> with a <xref href=\"NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion\" data-throw-if-not-resolved=\"false\"></xref> of\n\"2013b\" to be supply a <code>WindowsZones</code> object with a <code>TzdbVersion</code> of \"2012f\".\n</p>\n<p>\nThis property will never return a null value, but will be \"Unknown\" if the data\nis loaded from the legacy resource format.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public string TzdbVersion { get; }
          VB: Public ReadOnly Property TzdbVersion As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.TimeZones.TzdbDateTimeZoneSource: 
        NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion: 
    - id: NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion
      commentId: P:NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion
      language: CSharp
      name:
        CSharp: WindowsVersion
        VB: WindowsVersion
      nameWithType:
        CSharp: WindowsZones.WindowsVersion
        VB: WindowsZones.WindowsVersion
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion
        VB: NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/WindowsZones.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: WindowsVersion
        path: src/NodaTime/TimeZones/Cldr/WindowsZones.cs
        startLine: 72
      summary: "\nGets the Windows time zone database version this Windows zone mapping data was created from.\n"
      remarks: "\n<p>\nAt the time of this writing, this is populated (by CLDR) from the registry key\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\TzVersion,\nso \"7dc0101\" for example.\n</p>\n<p>\nThis property will never return a null value, but will be \"Unknown\" if the data\nis loaded from the legacy resource format.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public string WindowsVersion { get; }
          VB: Public ReadOnly Property WindowsVersion As String
        parameters: []
        return:
          type: System.String
      overload: NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: NodaTime.TimeZones.Cldr.WindowsZones.MapZones
      commentId: P:NodaTime.TimeZones.Cldr.WindowsZones.MapZones
      language: CSharp
      name:
        CSharp: MapZones
        VB: MapZones
      nameWithType:
        CSharp: WindowsZones.MapZones
        VB: WindowsZones.MapZones
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.WindowsZones.MapZones
        VB: NodaTime.TimeZones.Cldr.WindowsZones.MapZones
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/WindowsZones.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: MapZones
        path: src/NodaTime/TimeZones/Cldr/WindowsZones.cs
        startLine: 102
      summary: "\nGets an immutable collection of mappings from Windows system time zones to\nTZDB time zones.\n"
      remarks: "\n<p>\nEach mapping consists of a single Windows time zone ID and a single\nterritory to potentially multiple TZDB IDs that are broadly equivalent to that Windows zone/territory\npair.\n</p>\n<p>\nMappings for a single Windows system time zone can appear multiple times\nin this list, in different territories. For example, \"Central Standard Time\"\nmaps to different TZDB zones in different countries (the US, Canada, Mexico) and\neven within a single territory there can be multiple zones. Every Windows system time zone covered within\nthis collection has a \"primary\" entry with a territory code of \"001\" (which is the value of\n<xref href=\"NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory\" data-throw-if-not-resolved=\"false\"></xref>) and a single corresponding TZDB zone. \n</p>\n<p>This collection is not guaranteed to cover every Windows time zone. Some zones may be unmappable\n(such as \"Mid-Atlantic Standard Time\") and there can be a delay between a new Windows time zone being introduced\nand it appearing in CLDR, ready to be used by Noda Time. (There's also bound to be a delay between it appearing\nin CLDR and being used in your production system.) In practice however, you're unlikely to wish to use a time zone\nwhich isn't covered here.</p>\n<p>\nIf the data is loaded from the legacy resource format, this will only include the primary mappings.\n</p>\n"
      example: []
      syntax:
        content:
          CSharp: public IList<MapZone> MapZones { get; }
          VB: Public ReadOnly Property MapZones As IList(Of MapZone)
        parameters: []
        return:
          type: System.Collections.Generic.IList{NodaTime.TimeZones.Cldr.MapZone}
      overload: NodaTime.TimeZones.Cldr.WindowsZones.MapZones*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
      references:
        NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory: 
    - id: NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping
      commentId: P:NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping
      language: CSharp
      name:
        CSharp: PrimaryMapping
        VB: PrimaryMapping
      nameWithType:
        CSharp: WindowsZones.PrimaryMapping
        VB: WindowsZones.PrimaryMapping
      qualifiedName:
        CSharp: NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping
        VB: NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping
      type: Property
      assemblies:
      - NodaTime
      namespace: NodaTime.TimeZones.Cldr
      source:
        remote:
          path: 1.2.x/src/NodaTime/TimeZones/Cldr/WindowsZones.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: PrimaryMapping
        path: src/NodaTime/TimeZones/Cldr/WindowsZones.cs
        startLine: 110
      summary: "\nGets an immutable dictionary of primary mappings, from Windows system time zone ID\nto TZDB zone ID. This corresponds to the \"001\" territory which is present for every zone\nwithin the mapping file.\n"
      example: []
      syntax:
        content:
          CSharp: public IDictionary<string, string> PrimaryMapping { get; }
          VB: Public ReadOnly Property PrimaryMapping As IDictionary(Of String, String)
        parameters: []
        return:
          type: System.Collections.Generic.IDictionary{System.String,System.String}
      overload: NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
- id: NodaTime.Utility
  commentId: N:NodaTime.Utility
  language: CSharp
  name:
    CSharp: NodaTime.Utility
    VB: NodaTime.Utility
  nameWithType:
    CSharp: NodaTime.Utility
    VB: NodaTime.Utility
  qualifiedName:
    CSharp: NodaTime.Utility
    VB: NodaTime.Utility
  type: Namespace
  assemblies:
  - NodaTime
  modifiers: {}
  items:
  - id: NodaTime.Utility.BclConversions
    commentId: T:NodaTime.Utility.BclConversions
    language: CSharp
    name:
      CSharp: BclConversions
      VB: BclConversions
    nameWithType:
      CSharp: BclConversions
      VB: BclConversions
    qualifiedName:
      CSharp: NodaTime.Utility.BclConversions
      VB: NodaTime.Utility.BclConversions
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Utility
    source:
      remote:
        path: 1.2.x/src/NodaTime/Utility/BclConversions.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: BclConversions
      path: src/NodaTime/Utility/BclConversions.cs
      startLine: 20
    summary: "\nConversion methods which don't naturally fit into any other types - for example, for\nenums which can't specify any other code. In most cases, conversions to and from BCL types\nare provided within the type itself - such as <xref href=\"NodaTime.LocalDateTime.ToDateTimeUnspecified\" data-throw-if-not-resolved=\"false\"></xref>\nand <xref href=\"NodaTime.LocalDateTime.FromDateTime(System.DateTime)\" data-throw-if-not-resolved=\"false\"></xref>.\n"
    remarks: "\nMany of the methods within this class could be expressed as extension methods - but currently\nNoda Time always builds against .NET 2. In a future version, there may be multiple build targets,\nallowing these to become extension methods for the builds which use .NET 3.5 and higher.\n"
    example: []
    syntax:
      content:
        CSharp: public static class BclConversions
        VB: Public Module BclConversions
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: NodaTime.Utility.BclConversions.ToDayOfWeek(NodaTime.IsoDayOfWeek)
      commentId: M:NodaTime.Utility.BclConversions.ToDayOfWeek(NodaTime.IsoDayOfWeek)
      language: CSharp
      name:
        CSharp: ToDayOfWeek(IsoDayOfWeek)
        VB: ToDayOfWeek(IsoDayOfWeek)
      nameWithType:
        CSharp: BclConversions.ToDayOfWeek(IsoDayOfWeek)
        VB: BclConversions.ToDayOfWeek(IsoDayOfWeek)
      qualifiedName:
        CSharp: NodaTime.Utility.BclConversions.ToDayOfWeek(NodaTime.IsoDayOfWeek)
        VB: NodaTime.Utility.BclConversions.ToDayOfWeek(NodaTime.IsoDayOfWeek)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Utility
      source:
        remote:
          path: 1.2.x/src/NodaTime/Utility/BclConversions.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToDayOfWeek
        path: src/NodaTime/Utility/BclConversions.cs
        startLine: 31
      summary: "\nConverts from the Noda Time <xref href=\"NodaTime.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref> enum to the equivalent BCL\n<xref href=\"System.DayOfWeek\" data-throw-if-not-resolved=\"false\"></xref> value. Other than Sunday, the BCL and ISO values are the same -\nbut ISO 8601 defines Sunday as day 7, and the BCL defines it as day 0.\n"
      example: []
      syntax:
        content:
          CSharp: public static DayOfWeek ToDayOfWeek(IsoDayOfWeek isoDayOfWeek)
          VB: Public Shared Function ToDayOfWeek(isoDayOfWeek As IsoDayOfWeek) As DayOfWeek
        parameters:
        - id: isoDayOfWeek
          type: NodaTime.IsoDayOfWeek
          description: ISO day of week value to convert.
        return:
          type: System.DayOfWeek
          description: The ISO day of week value equivalent to the one passed in.
      overload: NodaTime.Utility.BclConversions.ToDayOfWeek*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: >-
          The <span class="paramref">isoDayOfWeek</span> parameter

          is not a valid day of the week.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        NodaTime.IsoDayOfWeek: 
        System.DayOfWeek: 
    - id: NodaTime.Utility.BclConversions.ToIsoDayOfWeek(System.DayOfWeek)
      commentId: M:NodaTime.Utility.BclConversions.ToIsoDayOfWeek(System.DayOfWeek)
      language: CSharp
      name:
        CSharp: ToIsoDayOfWeek(DayOfWeek)
        VB: ToIsoDayOfWeek(DayOfWeek)
      nameWithType:
        CSharp: BclConversions.ToIsoDayOfWeek(DayOfWeek)
        VB: BclConversions.ToIsoDayOfWeek(DayOfWeek)
      qualifiedName:
        CSharp: NodaTime.Utility.BclConversions.ToIsoDayOfWeek(System.DayOfWeek)
        VB: NodaTime.Utility.BclConversions.ToIsoDayOfWeek(System.DayOfWeek)
      type: Method
      assemblies:
      - NodaTime
      namespace: NodaTime.Utility
      source:
        remote:
          path: 1.2.x/src/NodaTime/Utility/BclConversions.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: ToIsoDayOfWeek
        path: src/NodaTime/Utility/BclConversions.cs
        startLine: 49
      summary: "\nConverts from the BCL <xref href=\"System.DayOfWeek\" data-throw-if-not-resolved=\"false\"></xref> enum to the equivalent Noda Time <xref href=\"NodaTime.IsoDayOfWeek\" data-throw-if-not-resolved=\"false\"></xref> value.\nOther than Sunday, the BCL and ISO values are the same - but ISO 8601 defines\nSunday as day 7, and the BCL defines it as day 0.\n"
      example: []
      syntax:
        content:
          CSharp: public static IsoDayOfWeek ToIsoDayOfWeek(DayOfWeek dayOfWeek)
          VB: Public Shared Function ToIsoDayOfWeek(dayOfWeek As DayOfWeek) As IsoDayOfWeek
        parameters:
        - id: dayOfWeek
          type: System.DayOfWeek
          description: ISO day of week value to convert.
        return:
          type: NodaTime.IsoDayOfWeek
          description: The BCL day of week value equivalent to the one passed in.
      overload: NodaTime.Utility.BclConversions.ToIsoDayOfWeek*
      exceptions:
      - type: System.ArgumentOutOfRangeException
        commentId: T:System.ArgumentOutOfRangeException
        description: >-
          The <span class="paramref">dayOfWeek</span> parameter

          is not a valid day of the week.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.DayOfWeek: 
        NodaTime.IsoDayOfWeek: 
    references:
      NodaTime.LocalDateTime.ToDateTimeUnspecified: 
      NodaTime.LocalDateTime.FromDateTime(System.DateTime): 
  - id: NodaTime.Utility.InvalidNodaDataException
    commentId: T:NodaTime.Utility.InvalidNodaDataException
    language: CSharp
    name:
      CSharp: InvalidNodaDataException
      VB: InvalidNodaDataException
    nameWithType:
      CSharp: InvalidNodaDataException
      VB: InvalidNodaDataException
    qualifiedName:
      CSharp: NodaTime.Utility.InvalidNodaDataException
      VB: NodaTime.Utility.InvalidNodaDataException
    type: Class
    assemblies:
    - NodaTime
    namespace: NodaTime.Utility
    source:
      remote:
        path: 1.2.x/src/NodaTime/Utility/InvalidNodaDataException.cs
        branch: history
        repo: https://github.com/nodatime/nodatime.git
      id: InvalidNodaDataException
      path: src/NodaTime/Utility/InvalidNodaDataException.cs
      startLine: 21
    summary: "\nException thrown when data read by Noda Time (such as serialized time zone data) is invalid. This includes\ndata which is truncated, i.e. we expect more data than we can read.\n"
    remarks: "\nThis type only exists as <code>InvalidDataException</code> doesn't exist in the Portable Class Library.\nUnfortunately, <code>InvalidDataException</code> itself is sealed, so we can't derive from it for the sake\nof backward compatibility.\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Serializable]

          public sealed class InvalidNodaDataException : Exception, ISerializable, _Exception
        VB: >-
          <Serializable>

          Public NotInheritable Class InvalidNodaDataException

              Inherits Exception

              Implements ISerializable, _Exception
    inheritance:
    - System.Object
    - System.Exception
    implements:
    - System.Runtime.Serialization.ISerializable
    - System.Runtime.InteropServices._Exception
    inheritedMembers:
    - System.Exception.GetBaseException
    - System.Exception.ToString
    - System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    - System.Exception.GetType
    - System.Exception.Message
    - System.Exception.Data
    - System.Exception.InnerException
    - System.Exception.TargetSite
    - System.Exception.StackTrace
    - System.Exception.HelpLink
    - System.Exception.Source
    - System.Exception.HResult
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.MemberwiseClone
    attributes:
    - type: System.SerializableAttribute
      ctor: System.SerializableAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: NodaTime.Utility.InvalidNodaDataException.#ctor(System.String)
      commentId: M:NodaTime.Utility.InvalidNodaDataException.#ctor(System.String)
      language: CSharp
      name:
        CSharp: InvalidNodaDataException(String)
        VB: InvalidNodaDataException(String)
      nameWithType:
        CSharp: InvalidNodaDataException.InvalidNodaDataException(String)
        VB: InvalidNodaDataException.InvalidNodaDataException(String)
      qualifiedName:
        CSharp: NodaTime.Utility.InvalidNodaDataException.InvalidNodaDataException(System.String)
        VB: NodaTime.Utility.InvalidNodaDataException.InvalidNodaDataException(System.String)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.Utility
      source:
        remote:
          path: 1.2.x/src/NodaTime/Utility/InvalidNodaDataException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/Utility/InvalidNodaDataException.cs
        startLine: 29
      summary: "\nCreates an instance with the given message.\n"
      example: []
      syntax:
        content:
          CSharp: public InvalidNodaDataException(string message)
          VB: Public Sub New(message As String)
        parameters:
        - id: message
          type: System.String
          description: The message for the exception.
      overload: NodaTime.Utility.InvalidNodaDataException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: NodaTime.Utility.InvalidNodaDataException.#ctor(System.String,System.Exception)
      commentId: M:NodaTime.Utility.InvalidNodaDataException.#ctor(System.String,System.Exception)
      language: CSharp
      name:
        CSharp: InvalidNodaDataException(String, Exception)
        VB: InvalidNodaDataException(String, Exception)
      nameWithType:
        CSharp: InvalidNodaDataException.InvalidNodaDataException(String, Exception)
        VB: InvalidNodaDataException.InvalidNodaDataException(String, Exception)
      qualifiedName:
        CSharp: NodaTime.Utility.InvalidNodaDataException.InvalidNodaDataException(System.String, System.Exception)
        VB: NodaTime.Utility.InvalidNodaDataException.InvalidNodaDataException(System.String, System.Exception)
      type: Constructor
      assemblies:
      - NodaTime
      namespace: NodaTime.Utility
      source:
        remote:
          path: 1.2.x/src/NodaTime/Utility/InvalidNodaDataException.cs
          branch: history
          repo: https://github.com/nodatime/nodatime.git
        id: .ctor
        path: src/NodaTime/Utility/InvalidNodaDataException.cs
        startLine: 36
      summary: "\nCreates an instance with the given message.\n"
      example: []
      syntax:
        content:
          CSharp: public InvalidNodaDataException(string message, Exception innerException)
          VB: Public Sub New(message As String, innerException As Exception)
        parameters:
        - id: message
          type: System.String
          description: The message for the exception.
        - id: innerException
          type: System.Exception
          description: Underlying cause of the error.
      overload: NodaTime.Utility.InvalidNodaDataException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
references:
  NodaTime.CalendarSystem:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem
        name: CalendarSystem
        nameWithType: CalendarSystem
        qualifiedName: NodaTime.CalendarSystem
      VB:
      - id: NodaTime.CalendarSystem
        name: CalendarSystem
        nameWithType: CalendarSystem
        qualifiedName: NodaTime.CalendarSystem
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.CalendarSystem
  NodaTime.CalendarSystem.Iso:
    commentId: P:NodaTime.CalendarSystem.Iso
  NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32):
    commentId: M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)
  System:
    name:
      CSharp:
      - name: System
        nameWithType: System
        qualifiedName: System
      VB:
      - name: System
        nameWithType: System
        qualifiedName: System
    isDefinition: true
    commentId: N:System
  System.Object:
    name:
      CSharp:
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      VB:
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Object
  System.Object.Equals(System.Object):
    name:
      CSharp:
      - id: System.Object.Equals(System.Object)
        name: Equals
        nameWithType: Object.Equals
        qualifiedName: System.Object.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.Equals(System.Object)
        name: Equals
        nameWithType: Object.Equals
        qualifiedName: System.Object.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.Equals(System.Object)
  System.Object.Equals(System.Object,System.Object):
    name:
      CSharp:
      - id: System.Object.Equals(System.Object,System.Object)
        name: Equals
        nameWithType: Object.Equals
        qualifiedName: System.Object.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.Equals(System.Object,System.Object)
        name: Equals
        nameWithType: Object.Equals
        qualifiedName: System.Object.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.Equals(System.Object,System.Object)
  System.Object.ReferenceEquals(System.Object,System.Object):
    name:
      CSharp:
      - id: System.Object.ReferenceEquals(System.Object,System.Object)
        name: ReferenceEquals
        nameWithType: Object.ReferenceEquals
        qualifiedName: System.Object.ReferenceEquals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.ReferenceEquals(System.Object,System.Object)
        name: ReferenceEquals
        nameWithType: Object.ReferenceEquals
        qualifiedName: System.Object.ReferenceEquals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  System.Object.GetHashCode:
    name:
      CSharp:
      - id: System.Object.GetHashCode
        name: GetHashCode
        nameWithType: Object.GetHashCode
        qualifiedName: System.Object.GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.GetHashCode
        name: GetHashCode
        nameWithType: Object.GetHashCode
        qualifiedName: System.Object.GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.GetHashCode
  System.Object.GetType:
    name:
      CSharp:
      - id: System.Object.GetType
        name: GetType
        nameWithType: Object.GetType
        qualifiedName: System.Object.GetType
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.GetType
        name: GetType
        nameWithType: Object.GetType
        qualifiedName: System.Object.GetType
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.GetType
  System.Object.MemberwiseClone:
    name:
      CSharp:
      - id: System.Object.MemberwiseClone
        name: MemberwiseClone
        nameWithType: Object.MemberwiseClone
        qualifiedName: System.Object.MemberwiseClone
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.MemberwiseClone
        name: MemberwiseClone
        nameWithType: Object.MemberwiseClone
        qualifiedName: System.Object.MemberwiseClone
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.MemberwiseClone
  NodaTime.CalendarSystem.Id:
    commentId: P:NodaTime.CalendarSystem.Id
  System.Collections.Generic.KeyNotFoundException:
    commentId: T:System.Collections.Generic.KeyNotFoundException
  NodaTime:
    name:
      CSharp:
      - name: NodaTime
        nameWithType: NodaTime
        qualifiedName: NodaTime
      VB:
      - name: NodaTime
        nameWithType: NodaTime
        qualifiedName: NodaTime
    isDefinition: true
    commentId: N:NodaTime
  System.String:
    name:
      CSharp:
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      VB:
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.String
  NodaTime.CalendarSystem.ForId*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.ForId*
        name: ForId
        nameWithType: CalendarSystem.ForId
        qualifiedName: NodaTime.CalendarSystem.ForId
      VB:
      - id: NodaTime.CalendarSystem.ForId*
        name: ForId
        nameWithType: CalendarSystem.ForId
        qualifiedName: NodaTime.CalendarSystem.ForId
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.ForId
  System.Collections.Generic.IEnumerable`1:
    name:
      CSharp:
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.Generic.IEnumerable`1
  System.Collections.Generic:
    name:
      CSharp:
      - name: System.Collections.Generic
        nameWithType: System.Collections.Generic
        qualifiedName: System.Collections.Generic
      VB:
      - name: System.Collections.Generic
        nameWithType: System.Collections.Generic
        qualifiedName: System.Collections.Generic
    isDefinition: true
    commentId: N:System.Collections.Generic
  System.Collections.Generic.IEnumerable{System.String}:
    name:
      CSharp:
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IEnumerable`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IEnumerable{System.String}
  NodaTime.CalendarSystem.Ids*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.Ids*
        name: Ids
        nameWithType: CalendarSystem.Ids
        qualifiedName: NodaTime.CalendarSystem.Ids
      VB:
      - id: NodaTime.CalendarSystem.Ids*
        name: Ids
        nameWithType: CalendarSystem.Ids
        qualifiedName: NodaTime.CalendarSystem.Ids
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.Ids
  NodaTime.CalendarSystem.Iso*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.Iso*
        name: Iso
        nameWithType: CalendarSystem.Iso
        qualifiedName: NodaTime.CalendarSystem.Iso
      VB:
      - id: NodaTime.CalendarSystem.Iso*
        name: Iso
        nameWithType: CalendarSystem.Iso
        qualifiedName: NodaTime.CalendarSystem.Iso
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.Iso
  System.Int32:
    name:
      CSharp:
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      VB:
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Int32
  NodaTime.CalendarSystem.GetGregorianCalendar*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.GetGregorianCalendar*
        name: GetGregorianCalendar
        nameWithType: CalendarSystem.GetGregorianCalendar
        qualifiedName: NodaTime.CalendarSystem.GetGregorianCalendar
      VB:
      - id: NodaTime.CalendarSystem.GetGregorianCalendar*
        name: GetGregorianCalendar
        nameWithType: CalendarSystem.GetGregorianCalendar
        qualifiedName: NodaTime.CalendarSystem.GetGregorianCalendar
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.GetGregorianCalendar
  NodaTime.CalendarSystem.GetJulianCalendar*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.GetJulianCalendar*
        name: GetJulianCalendar
        nameWithType: CalendarSystem.GetJulianCalendar
        qualifiedName: NodaTime.CalendarSystem.GetJulianCalendar
      VB:
      - id: NodaTime.CalendarSystem.GetJulianCalendar*
        name: GetJulianCalendar
        nameWithType: CalendarSystem.GetJulianCalendar
        qualifiedName: NodaTime.CalendarSystem.GetJulianCalendar
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.GetJulianCalendar
  NodaTime.CalendarSystem.GetCopticCalendar*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.GetCopticCalendar*
        name: GetCopticCalendar
        nameWithType: CalendarSystem.GetCopticCalendar
        qualifiedName: NodaTime.CalendarSystem.GetCopticCalendar
      VB:
      - id: NodaTime.CalendarSystem.GetCopticCalendar*
        name: GetCopticCalendar
        nameWithType: CalendarSystem.GetCopticCalendar
        qualifiedName: NodaTime.CalendarSystem.GetCopticCalendar
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.GetCopticCalendar
  NodaTime.Calendars.IslamicEpoch.Civil:
    commentId: F:NodaTime.Calendars.IslamicEpoch.Civil
  NodaTime.Calendars.IslamicEpoch.Astronomical:
    commentId: F:NodaTime.Calendars.IslamicEpoch.Astronomical
  NodaTime.Calendars:
    name:
      CSharp:
      - name: NodaTime.Calendars
        nameWithType: NodaTime.Calendars
        qualifiedName: NodaTime.Calendars
      VB:
      - name: NodaTime.Calendars
        nameWithType: NodaTime.Calendars
        qualifiedName: NodaTime.Calendars
    isDefinition: true
    commentId: N:NodaTime.Calendars
  NodaTime.Calendars.IslamicLeapYearPattern:
    name:
      CSharp:
      - id: NodaTime.Calendars.IslamicLeapYearPattern
        name: IslamicLeapYearPattern
        nameWithType: IslamicLeapYearPattern
        qualifiedName: NodaTime.Calendars.IslamicLeapYearPattern
      VB:
      - id: NodaTime.Calendars.IslamicLeapYearPattern
        name: IslamicLeapYearPattern
        nameWithType: IslamicLeapYearPattern
        qualifiedName: NodaTime.Calendars.IslamicLeapYearPattern
    isDefinition: true
    parent: NodaTime.Calendars
    commentId: T:NodaTime.Calendars.IslamicLeapYearPattern
  NodaTime.Calendars.IslamicEpoch:
    name:
      CSharp:
      - id: NodaTime.Calendars.IslamicEpoch
        name: IslamicEpoch
        nameWithType: IslamicEpoch
        qualifiedName: NodaTime.Calendars.IslamicEpoch
      VB:
      - id: NodaTime.Calendars.IslamicEpoch
        name: IslamicEpoch
        nameWithType: IslamicEpoch
        qualifiedName: NodaTime.Calendars.IslamicEpoch
    isDefinition: true
    parent: NodaTime.Calendars
    commentId: T:NodaTime.Calendars.IslamicEpoch
  NodaTime.CalendarSystem.GetIslamicCalendar*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.GetIslamicCalendar*
        name: GetIslamicCalendar
        nameWithType: CalendarSystem.GetIslamicCalendar
        qualifiedName: NodaTime.CalendarSystem.GetIslamicCalendar
      VB:
      - id: NodaTime.CalendarSystem.GetIslamicCalendar*
        name: GetIslamicCalendar
        nameWithType: CalendarSystem.GetIslamicCalendar
        qualifiedName: NodaTime.CalendarSystem.GetIslamicCalendar
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.GetIslamicCalendar
  NodaTime.CalendarSystem.ForId(System.String):
    commentId: M:NodaTime.CalendarSystem.ForId(System.String)
  NodaTime.CalendarSystem.GetCopticCalendar(System.Int32):
    commentId: M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)
  NodaTime.CalendarSystem.GetJulianCalendar(System.Int32):
    commentId: M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)
  NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch):
    commentId: M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)
  NodaTime.CalendarSystem.Id*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.Id*
        name: Id
        nameWithType: CalendarSystem.Id
        qualifiedName: NodaTime.CalendarSystem.Id
      VB:
      - id: NodaTime.CalendarSystem.Id*
        name: Id
        nameWithType: CalendarSystem.Id
        qualifiedName: NodaTime.CalendarSystem.Id
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.Id
  NodaTime.CalendarSystem.Name*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.Name*
        name: Name
        nameWithType: CalendarSystem.Name
        qualifiedName: NodaTime.CalendarSystem.Name
      VB:
      - id: NodaTime.CalendarSystem.Name*
        name: Name
        nameWithType: CalendarSystem.Name
        qualifiedName: NodaTime.CalendarSystem.Name
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.Name
  NodaTime.LocalDateTime:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      VB:
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.LocalDateTime
  NodaTime.IsoDayOfWeek:
    name:
      CSharp:
      - id: NodaTime.IsoDayOfWeek
        name: IsoDayOfWeek
        nameWithType: IsoDayOfWeek
        qualifiedName: NodaTime.IsoDayOfWeek
      VB:
      - id: NodaTime.IsoDayOfWeek
        name: IsoDayOfWeek
        nameWithType: IsoDayOfWeek
        qualifiedName: NodaTime.IsoDayOfWeek
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.IsoDayOfWeek
  System.Boolean:
    name:
      CSharp:
      - id: System.Boolean
        name: Boolean
        nameWithType: Boolean
        qualifiedName: System.Boolean
        isExternal: true
      VB:
      - id: System.Boolean
        name: Boolean
        nameWithType: Boolean
        qualifiedName: System.Boolean
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Boolean
  NodaTime.CalendarSystem.UsesIsoDayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.UsesIsoDayOfWeek*
        name: UsesIsoDayOfWeek
        nameWithType: CalendarSystem.UsesIsoDayOfWeek
        qualifiedName: NodaTime.CalendarSystem.UsesIsoDayOfWeek
      VB:
      - id: NodaTime.CalendarSystem.UsesIsoDayOfWeek*
        name: UsesIsoDayOfWeek
        nameWithType: CalendarSystem.UsesIsoDayOfWeek
        qualifiedName: NodaTime.CalendarSystem.UsesIsoDayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.UsesIsoDayOfWeek
  NodaTime.CalendarSystem.MinYear*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.MinYear*
        name: MinYear
        nameWithType: CalendarSystem.MinYear
        qualifiedName: NodaTime.CalendarSystem.MinYear
      VB:
      - id: NodaTime.CalendarSystem.MinYear*
        name: MinYear
        nameWithType: CalendarSystem.MinYear
        qualifiedName: NodaTime.CalendarSystem.MinYear
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.MinYear
  NodaTime.CalendarSystem.MaxYear*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.MaxYear*
        name: MaxYear
        nameWithType: CalendarSystem.MaxYear
        qualifiedName: NodaTime.CalendarSystem.MaxYear
      VB:
      - id: NodaTime.CalendarSystem.MaxYear*
        name: MaxYear
        nameWithType: CalendarSystem.MaxYear
        qualifiedName: NodaTime.CalendarSystem.MaxYear
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.MaxYear
  System.Collections.Generic.IList`1:
    name:
      CSharp:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.Generic.IList`1
  System.Collections.Generic.IList{NodaTime.Calendars.Era}:
    name:
      CSharp:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Calendars.Era
        name: Era
        nameWithType: Era
        qualifiedName: NodaTime.Calendars.Era
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Calendars.Era
        name: Era
        nameWithType: Era
        qualifiedName: NodaTime.Calendars.Era
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IList`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IList{NodaTime.Calendars.Era}
  NodaTime.CalendarSystem.Eras*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.Eras*
        name: Eras
        nameWithType: CalendarSystem.Eras
        qualifiedName: NodaTime.CalendarSystem.Eras
      VB:
      - id: NodaTime.CalendarSystem.Eras*
        name: Eras
        nameWithType: CalendarSystem.Eras
        qualifiedName: NodaTime.CalendarSystem.Eras
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.Eras
  System.ArgumentNullException:
    commentId: T:System.ArgumentNullException
  System.ArgumentOutOfRangeException:
    name:
      CSharp:
      - id: System.ArgumentOutOfRangeException
        name: ArgumentOutOfRangeException
        nameWithType: ArgumentOutOfRangeException
        qualifiedName: System.ArgumentOutOfRangeException
        isExternal: true
      VB:
      - id: System.ArgumentOutOfRangeException
        name: ArgumentOutOfRangeException
        nameWithType: ArgumentOutOfRangeException
        qualifiedName: System.ArgumentOutOfRangeException
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.ArgumentOutOfRangeException
  System.ArgumentException:
    name:
      CSharp:
      - id: System.ArgumentException
        name: ArgumentException
        nameWithType: ArgumentException
        qualifiedName: System.ArgumentException
        isExternal: true
      VB:
      - id: System.ArgumentException
        name: ArgumentException
        nameWithType: ArgumentException
        qualifiedName: System.ArgumentException
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.ArgumentException
  NodaTime.Calendars.Era:
    name:
      CSharp:
      - id: NodaTime.Calendars.Era
        name: Era
        nameWithType: Era
        qualifiedName: NodaTime.Calendars.Era
      VB:
      - id: NodaTime.Calendars.Era
        name: Era
        nameWithType: Era
        qualifiedName: NodaTime.Calendars.Era
    isDefinition: true
    parent: NodaTime.Calendars
    commentId: T:NodaTime.Calendars.Era
  NodaTime.CalendarSystem.GetAbsoluteYear*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.GetAbsoluteYear*
        name: GetAbsoluteYear
        nameWithType: CalendarSystem.GetAbsoluteYear
        qualifiedName: NodaTime.CalendarSystem.GetAbsoluteYear
      VB:
      - id: NodaTime.CalendarSystem.GetAbsoluteYear*
        name: GetAbsoluteYear
        nameWithType: CalendarSystem.GetAbsoluteYear
        qualifiedName: NodaTime.CalendarSystem.GetAbsoluteYear
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.GetAbsoluteYear
  NodaTime.CalendarSystem.GetMaxYearOfEra*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.GetMaxYearOfEra*
        name: GetMaxYearOfEra
        nameWithType: CalendarSystem.GetMaxYearOfEra
        qualifiedName: NodaTime.CalendarSystem.GetMaxYearOfEra
      VB:
      - id: NodaTime.CalendarSystem.GetMaxYearOfEra*
        name: GetMaxYearOfEra
        nameWithType: CalendarSystem.GetMaxYearOfEra
        qualifiedName: NodaTime.CalendarSystem.GetMaxYearOfEra
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.GetMaxYearOfEra
  NodaTime.CalendarSystem.GetMinYearOfEra*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.GetMinYearOfEra*
        name: GetMinYearOfEra
        nameWithType: CalendarSystem.GetMinYearOfEra
        qualifiedName: NodaTime.CalendarSystem.GetMinYearOfEra
      VB:
      - id: NodaTime.CalendarSystem.GetMinYearOfEra*
        name: GetMinYearOfEra
        nameWithType: CalendarSystem.GetMinYearOfEra
        qualifiedName: NodaTime.CalendarSystem.GetMinYearOfEra
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.GetMinYearOfEra
  System.Object.ToString:
    name:
      CSharp:
      - id: System.Object.ToString
        name: ToString
        nameWithType: Object.ToString
        qualifiedName: System.Object.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.ToString
        name: ToString
        nameWithType: Object.ToString
        qualifiedName: System.Object.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.ToString
  NodaTime.CalendarSystem.ToString*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.ToString*
        name: ToString
        nameWithType: CalendarSystem.ToString
        qualifiedName: NodaTime.CalendarSystem.ToString
      VB:
      - id: NodaTime.CalendarSystem.ToString*
        name: ToString
        nameWithType: CalendarSystem.ToString
        qualifiedName: NodaTime.CalendarSystem.ToString
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.ToString
  NodaTime.CalendarSystem.GetDaysInMonth*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.GetDaysInMonth*
        name: GetDaysInMonth
        nameWithType: CalendarSystem.GetDaysInMonth
        qualifiedName: NodaTime.CalendarSystem.GetDaysInMonth
      VB:
      - id: NodaTime.CalendarSystem.GetDaysInMonth*
        name: GetDaysInMonth
        nameWithType: CalendarSystem.GetDaysInMonth
        qualifiedName: NodaTime.CalendarSystem.GetDaysInMonth
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.GetDaysInMonth
  NodaTime.CalendarSystem.IsLeapYear*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.IsLeapYear*
        name: IsLeapYear
        nameWithType: CalendarSystem.IsLeapYear
        qualifiedName: NodaTime.CalendarSystem.IsLeapYear
      VB:
      - id: NodaTime.CalendarSystem.IsLeapYear*
        name: IsLeapYear
        nameWithType: CalendarSystem.IsLeapYear
        qualifiedName: NodaTime.CalendarSystem.IsLeapYear
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.IsLeapYear
  NodaTime.CalendarSystem.GetMaxMonth*:
    name:
      CSharp:
      - id: NodaTime.CalendarSystem.GetMaxMonth*
        name: GetMaxMonth
        nameWithType: CalendarSystem.GetMaxMonth
        qualifiedName: NodaTime.CalendarSystem.GetMaxMonth
      VB:
      - id: NodaTime.CalendarSystem.GetMaxMonth*
        name: GetMaxMonth
        nameWithType: CalendarSystem.GetMaxMonth
        qualifiedName: NodaTime.CalendarSystem.GetMaxMonth
    isDefinition: true
    commentId: Overload:NodaTime.CalendarSystem.GetMaxMonth
  ? System.ArgumentOutOfRangeException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  : name:
      CSharp:
      - id: System.ArgumentOutOfRangeException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        name: GetObjectData
        nameWithType: ArgumentOutOfRangeException.GetObjectData
        qualifiedName: System.ArgumentOutOfRangeException.GetObjectData
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.ArgumentOutOfRangeException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        name: GetObjectData
        nameWithType: ArgumentOutOfRangeException.GetObjectData
        qualifiedName: System.ArgumentOutOfRangeException.GetObjectData
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.ArgumentOutOfRangeException
    commentId: M:System.ArgumentOutOfRangeException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  System.ArgumentOutOfRangeException.Message:
    name:
      CSharp:
      - id: System.ArgumentOutOfRangeException.Message
        name: Message
        nameWithType: ArgumentOutOfRangeException.Message
        qualifiedName: System.ArgumentOutOfRangeException.Message
        isExternal: true
      VB:
      - id: System.ArgumentOutOfRangeException.Message
        name: Message
        nameWithType: ArgumentOutOfRangeException.Message
        qualifiedName: System.ArgumentOutOfRangeException.Message
        isExternal: true
    isDefinition: true
    parent: System.ArgumentOutOfRangeException
    commentId: P:System.ArgumentOutOfRangeException.Message
  System.ArgumentOutOfRangeException.ActualValue:
    name:
      CSharp:
      - id: System.ArgumentOutOfRangeException.ActualValue
        name: ActualValue
        nameWithType: ArgumentOutOfRangeException.ActualValue
        qualifiedName: System.ArgumentOutOfRangeException.ActualValue
        isExternal: true
      VB:
      - id: System.ArgumentOutOfRangeException.ActualValue
        name: ActualValue
        nameWithType: ArgumentOutOfRangeException.ActualValue
        qualifiedName: System.ArgumentOutOfRangeException.ActualValue
        isExternal: true
    isDefinition: true
    parent: System.ArgumentOutOfRangeException
    commentId: P:System.ArgumentOutOfRangeException.ActualValue
  System.ArgumentException.ParamName:
    name:
      CSharp:
      - id: System.ArgumentException.ParamName
        name: ParamName
        nameWithType: ArgumentException.ParamName
        qualifiedName: System.ArgumentException.ParamName
        isExternal: true
      VB:
      - id: System.ArgumentException.ParamName
        name: ParamName
        nameWithType: ArgumentException.ParamName
        qualifiedName: System.ArgumentException.ParamName
        isExternal: true
    isDefinition: true
    parent: System.ArgumentException
    commentId: P:System.ArgumentException.ParamName
  System.SystemException:
    name:
      CSharp:
      - id: System.SystemException
        name: SystemException
        nameWithType: SystemException
        qualifiedName: System.SystemException
        isExternal: true
      VB:
      - id: System.SystemException
        name: SystemException
        nameWithType: SystemException
        qualifiedName: System.SystemException
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.SystemException
  System.Exception:
    name:
      CSharp:
      - id: System.Exception
        name: Exception
        nameWithType: Exception
        qualifiedName: System.Exception
        isExternal: true
      VB:
      - id: System.Exception
        name: Exception
        nameWithType: Exception
        qualifiedName: System.Exception
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Exception
  System.Exception.GetBaseException:
    name:
      CSharp:
      - id: System.Exception.GetBaseException
        name: GetBaseException
        nameWithType: Exception.GetBaseException
        qualifiedName: System.Exception.GetBaseException
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Exception.GetBaseException
        name: GetBaseException
        nameWithType: Exception.GetBaseException
        qualifiedName: System.Exception.GetBaseException
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Exception
    commentId: M:System.Exception.GetBaseException
  System.Exception.ToString:
    name:
      CSharp:
      - id: System.Exception.ToString
        name: ToString
        nameWithType: Exception.ToString
        qualifiedName: System.Exception.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Exception.ToString
        name: ToString
        nameWithType: Exception.ToString
        qualifiedName: System.Exception.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Exception
    commentId: M:System.Exception.ToString
  System.Exception.GetType:
    name:
      CSharp:
      - id: System.Exception.GetType
        name: GetType
        nameWithType: Exception.GetType
        qualifiedName: System.Exception.GetType
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Exception.GetType
        name: GetType
        nameWithType: Exception.GetType
        qualifiedName: System.Exception.GetType
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Exception
    commentId: M:System.Exception.GetType
  System.Exception.Data:
    name:
      CSharp:
      - id: System.Exception.Data
        name: Data
        nameWithType: Exception.Data
        qualifiedName: System.Exception.Data
        isExternal: true
      VB:
      - id: System.Exception.Data
        name: Data
        nameWithType: Exception.Data
        qualifiedName: System.Exception.Data
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.Data
  System.Exception.InnerException:
    name:
      CSharp:
      - id: System.Exception.InnerException
        name: InnerException
        nameWithType: Exception.InnerException
        qualifiedName: System.Exception.InnerException
        isExternal: true
      VB:
      - id: System.Exception.InnerException
        name: InnerException
        nameWithType: Exception.InnerException
        qualifiedName: System.Exception.InnerException
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.InnerException
  System.Exception.TargetSite:
    name:
      CSharp:
      - id: System.Exception.TargetSite
        name: TargetSite
        nameWithType: Exception.TargetSite
        qualifiedName: System.Exception.TargetSite
        isExternal: true
      VB:
      - id: System.Exception.TargetSite
        name: TargetSite
        nameWithType: Exception.TargetSite
        qualifiedName: System.Exception.TargetSite
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.TargetSite
  System.Exception.StackTrace:
    name:
      CSharp:
      - id: System.Exception.StackTrace
        name: StackTrace
        nameWithType: Exception.StackTrace
        qualifiedName: System.Exception.StackTrace
        isExternal: true
      VB:
      - id: System.Exception.StackTrace
        name: StackTrace
        nameWithType: Exception.StackTrace
        qualifiedName: System.Exception.StackTrace
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.StackTrace
  System.Exception.HelpLink:
    name:
      CSharp:
      - id: System.Exception.HelpLink
        name: HelpLink
        nameWithType: Exception.HelpLink
        qualifiedName: System.Exception.HelpLink
        isExternal: true
      VB:
      - id: System.Exception.HelpLink
        name: HelpLink
        nameWithType: Exception.HelpLink
        qualifiedName: System.Exception.HelpLink
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.HelpLink
  System.Exception.Source:
    name:
      CSharp:
      - id: System.Exception.Source
        name: Source
        nameWithType: Exception.Source
        qualifiedName: System.Exception.Source
        isExternal: true
      VB:
      - id: System.Exception.Source
        name: Source
        nameWithType: Exception.Source
        qualifiedName: System.Exception.Source
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.Source
  System.Exception.HResult:
    name:
      CSharp:
      - id: System.Exception.HResult
        name: HResult
        nameWithType: Exception.HResult
        qualifiedName: System.Exception.HResult
        isExternal: true
      VB:
      - id: System.Exception.HResult
        name: HResult
        nameWithType: Exception.HResult
        qualifiedName: System.Exception.HResult
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.HResult
  System.Runtime.InteropServices:
    name:
      CSharp:
      - name: System.Runtime.InteropServices
        nameWithType: System.Runtime.InteropServices
        qualifiedName: System.Runtime.InteropServices
      VB:
      - name: System.Runtime.InteropServices
        nameWithType: System.Runtime.InteropServices
        qualifiedName: System.Runtime.InteropServices
    isDefinition: true
    commentId: N:System.Runtime.InteropServices
  System.Runtime.InteropServices._Exception:
    name:
      CSharp:
      - id: System.Runtime.InteropServices._Exception
        name: _Exception
        nameWithType: _Exception
        qualifiedName: System.Runtime.InteropServices._Exception
        isExternal: true
      VB:
      - id: System.Runtime.InteropServices._Exception
        name: _Exception
        nameWithType: _Exception
        qualifiedName: System.Runtime.InteropServices._Exception
        isExternal: true
    isDefinition: true
    parent: System.Runtime.InteropServices
    commentId: T:System.Runtime.InteropServices._Exception
  System.Runtime.Serialization:
    name:
      CSharp:
      - name: System.Runtime.Serialization
        nameWithType: System.Runtime.Serialization
        qualifiedName: System.Runtime.Serialization
      VB:
      - name: System.Runtime.Serialization
        nameWithType: System.Runtime.Serialization
        qualifiedName: System.Runtime.Serialization
    isDefinition: true
    commentId: N:System.Runtime.Serialization
  System.Runtime.Serialization.ISerializable:
    name:
      CSharp:
      - id: System.Runtime.Serialization.ISerializable
        name: ISerializable
        nameWithType: ISerializable
        qualifiedName: System.Runtime.Serialization.ISerializable
        isExternal: true
      VB:
      - id: System.Runtime.Serialization.ISerializable
        name: ISerializable
        nameWithType: ISerializable
        qualifiedName: System.Runtime.Serialization.ISerializable
        isExternal: true
    isDefinition: true
    parent: System.Runtime.Serialization
    commentId: T:System.Runtime.Serialization.ISerializable
  NodaTime.DateTimeZone:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      VB:
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.DateTimeZone
  NodaTime.AmbiguousTimeException.Zone*:
    name:
      CSharp:
      - id: NodaTime.AmbiguousTimeException.Zone*
        name: Zone
        nameWithType: AmbiguousTimeException.Zone
        qualifiedName: NodaTime.AmbiguousTimeException.Zone
      VB:
      - id: NodaTime.AmbiguousTimeException.Zone*
        name: Zone
        nameWithType: AmbiguousTimeException.Zone
        qualifiedName: NodaTime.AmbiguousTimeException.Zone
    isDefinition: true
    commentId: Overload:NodaTime.AmbiguousTimeException.Zone
  NodaTime.ZonedDateTime:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      VB:
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.ZonedDateTime
  NodaTime.AmbiguousTimeException.EarlierMapping*:
    name:
      CSharp:
      - id: NodaTime.AmbiguousTimeException.EarlierMapping*
        name: EarlierMapping
        nameWithType: AmbiguousTimeException.EarlierMapping
        qualifiedName: NodaTime.AmbiguousTimeException.EarlierMapping
      VB:
      - id: NodaTime.AmbiguousTimeException.EarlierMapping*
        name: EarlierMapping
        nameWithType: AmbiguousTimeException.EarlierMapping
        qualifiedName: NodaTime.AmbiguousTimeException.EarlierMapping
    isDefinition: true
    commentId: Overload:NodaTime.AmbiguousTimeException.EarlierMapping
  NodaTime.AmbiguousTimeException.LaterMapping*:
    name:
      CSharp:
      - id: NodaTime.AmbiguousTimeException.LaterMapping*
        name: LaterMapping
        nameWithType: AmbiguousTimeException.LaterMapping
        qualifiedName: NodaTime.AmbiguousTimeException.LaterMapping
      VB:
      - id: NodaTime.AmbiguousTimeException.LaterMapping*
        name: LaterMapping
        nameWithType: AmbiguousTimeException.LaterMapping
        qualifiedName: NodaTime.AmbiguousTimeException.LaterMapping
    isDefinition: true
    commentId: Overload:NodaTime.AmbiguousTimeException.LaterMapping
  NodaTime.AmbiguousTimeException.#ctor*:
    name:
      CSharp:
      - id: NodaTime.AmbiguousTimeException.#ctor*
        name: AmbiguousTimeException
        nameWithType: AmbiguousTimeException.AmbiguousTimeException
        qualifiedName: NodaTime.AmbiguousTimeException.AmbiguousTimeException
      VB:
      - id: NodaTime.AmbiguousTimeException.#ctor*
        name: AmbiguousTimeException
        nameWithType: AmbiguousTimeException.AmbiguousTimeException
        qualifiedName: NodaTime.AmbiguousTimeException.AmbiguousTimeException
    isDefinition: true
    commentId: Overload:NodaTime.AmbiguousTimeException.#ctor
  NodaTime.AmbiguousTimeException:
    name:
      CSharp:
      - id: NodaTime.AmbiguousTimeException
        name: AmbiguousTimeException
        nameWithType: AmbiguousTimeException
        qualifiedName: NodaTime.AmbiguousTimeException
      VB:
      - id: NodaTime.AmbiguousTimeException
        name: AmbiguousTimeException
        nameWithType: AmbiguousTimeException
        qualifiedName: NodaTime.AmbiguousTimeException
    isDefinition: true
    commentId: T:NodaTime.AmbiguousTimeException
  System.SerializableAttribute:
    name:
      CSharp:
      - id: System.SerializableAttribute
        name: SerializableAttribute
        nameWithType: SerializableAttribute
        qualifiedName: System.SerializableAttribute
        isExternal: true
      VB:
      - id: System.SerializableAttribute
        name: SerializableAttribute
        nameWithType: SerializableAttribute
        qualifiedName: System.SerializableAttribute
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.SerializableAttribute
  System.SerializableAttribute.#ctor:
    name:
      CSharp:
      - id: System.SerializableAttribute.#ctor
        name: SerializableAttribute
        nameWithType: SerializableAttribute.SerializableAttribute
        qualifiedName: System.SerializableAttribute.SerializableAttribute
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.SerializableAttribute.#ctor
        name: SerializableAttribute
        nameWithType: SerializableAttribute.SerializableAttribute
        qualifiedName: System.SerializableAttribute.SerializableAttribute
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.SerializableAttribute
    commentId: M:System.SerializableAttribute.#ctor
  NodaTime.TimeZones.TzdbDateTimeZoneSource:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource
        name: TzdbDateTimeZoneSource
        nameWithType: TzdbDateTimeZoneSource
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource
        name: TzdbDateTimeZoneSource
        nameWithType: TzdbDateTimeZoneSource
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource
    isDefinition: true
    parent: NodaTime.TimeZones
    commentId: T:NodaTime.TimeZones.TzdbDateTimeZoneSource
  NodaTime.TimeZones.TzdbDateTimeZoneSource.Default:
    commentId: P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Default
  NodaTime.IDateTimeZoneProvider:
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider
        name: IDateTimeZoneProvider
        nameWithType: IDateTimeZoneProvider
        qualifiedName: NodaTime.IDateTimeZoneProvider
      VB:
      - id: NodaTime.IDateTimeZoneProvider
        name: IDateTimeZoneProvider
        nameWithType: IDateTimeZoneProvider
        qualifiedName: NodaTime.IDateTimeZoneProvider
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.IDateTimeZoneProvider
  NodaTime.DateTimeZoneProviders.Tzdb*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZoneProviders.Tzdb*
        name: Tzdb
        nameWithType: DateTimeZoneProviders.Tzdb
        qualifiedName: NodaTime.DateTimeZoneProviders.Tzdb
      VB:
      - id: NodaTime.DateTimeZoneProviders.Tzdb*
        name: Tzdb
        nameWithType: DateTimeZoneProviders.Tzdb
        qualifiedName: NodaTime.DateTimeZoneProviders.Tzdb
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZoneProviders.Tzdb
  NodaTime.DateTimeZoneProviders.Tzdb:
    commentId: P:NodaTime.DateTimeZoneProviders.Tzdb
  NodaTime.DateTimeZoneProviders.Default*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZoneProviders.Default*
        name: Default
        nameWithType: DateTimeZoneProviders.Default
        qualifiedName: NodaTime.DateTimeZoneProviders.Default
      VB:
      - id: NodaTime.DateTimeZoneProviders.Default*
        name: Default
        nameWithType: DateTimeZoneProviders.Default
        qualifiedName: NodaTime.DateTimeZoneProviders.Default
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZoneProviders.Default
  System.ObsoleteAttribute:
    name:
      CSharp:
      - id: System.ObsoleteAttribute
        name: ObsoleteAttribute
        nameWithType: ObsoleteAttribute
        qualifiedName: System.ObsoleteAttribute
        isExternal: true
      VB:
      - id: System.ObsoleteAttribute
        name: ObsoleteAttribute
        nameWithType: ObsoleteAttribute
        qualifiedName: System.ObsoleteAttribute
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.ObsoleteAttribute
  System.ObsoleteAttribute.#ctor(System.String):
    name:
      CSharp:
      - id: System.ObsoleteAttribute.#ctor(System.String)
        name: ObsoleteAttribute
        nameWithType: ObsoleteAttribute.ObsoleteAttribute
        qualifiedName: System.ObsoleteAttribute.ObsoleteAttribute
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.ObsoleteAttribute.#ctor(System.String)
        name: ObsoleteAttribute
        nameWithType: ObsoleteAttribute.ObsoleteAttribute
        qualifiedName: System.ObsoleteAttribute.ObsoleteAttribute
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.ObsoleteAttribute
    commentId: M:System.ObsoleteAttribute.#ctor(System.String)
  NodaTime.TimeZones.BclDateTimeZoneSource:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource
        name: BclDateTimeZoneSource
        nameWithType: BclDateTimeZoneSource
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource
        name: BclDateTimeZoneSource
        nameWithType: BclDateTimeZoneSource
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource
    isDefinition: true
    commentId: T:NodaTime.TimeZones.BclDateTimeZoneSource
  NodaTime.DateTimeZoneProviders.Bcl*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZoneProviders.Bcl*
        name: Bcl
        nameWithType: DateTimeZoneProviders.Bcl
        qualifiedName: NodaTime.DateTimeZoneProviders.Bcl
      VB:
      - id: NodaTime.DateTimeZoneProviders.Bcl*
        name: Bcl
        nameWithType: DateTimeZoneProviders.Bcl
        qualifiedName: NodaTime.DateTimeZoneProviders.Bcl
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZoneProviders.Bcl
  NodaTime.DateTimeZoneProviders.Serialization*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZoneProviders.Serialization*
        name: Serialization
        nameWithType: DateTimeZoneProviders.Serialization
        qualifiedName: NodaTime.DateTimeZoneProviders.Serialization
      VB:
      - id: NodaTime.DateTimeZoneProviders.Serialization*
        name: Serialization
        nameWithType: DateTimeZoneProviders.Serialization
        qualifiedName: NodaTime.DateTimeZoneProviders.Serialization
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZoneProviders.Serialization
  NodaTime.DateTimeZoneProviders:
    name:
      CSharp:
      - id: NodaTime.DateTimeZoneProviders
        name: DateTimeZoneProviders
        nameWithType: DateTimeZoneProviders
        qualifiedName: NodaTime.DateTimeZoneProviders
      VB:
      - id: NodaTime.DateTimeZoneProviders
        name: DateTimeZoneProviders
        nameWithType: DateTimeZoneProviders
        qualifiedName: NodaTime.DateTimeZoneProviders
    isDefinition: true
    commentId: T:NodaTime.DateTimeZoneProviders
  System.DateTimeOffset:
    name:
      CSharp:
      - id: System.DateTimeOffset
        name: DateTimeOffset
        nameWithType: DateTimeOffset
        qualifiedName: System.DateTimeOffset
        isExternal: true
      VB:
      - id: System.DateTimeOffset
        name: DateTimeOffset
        nameWithType: DateTimeOffset
        qualifiedName: System.DateTimeOffset
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.DateTimeOffset
  System.ValueType:
    name:
      CSharp:
      - id: System.ValueType
        name: ValueType
        nameWithType: ValueType
        qualifiedName: System.ValueType
        isExternal: true
      VB:
      - id: System.ValueType
        name: ValueType
        nameWithType: ValueType
        qualifiedName: System.ValueType
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.ValueType
  System.IEquatable`1:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.IEquatable`1
  System.IEquatable{NodaTime.OffsetDateTime}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.OffsetDateTime}
  System.IFormattable:
    name:
      CSharp:
      - id: System.IFormattable
        name: IFormattable
        nameWithType: IFormattable
        qualifiedName: System.IFormattable
        isExternal: true
      VB:
      - id: System.IFormattable
        name: IFormattable
        nameWithType: IFormattable
        qualifiedName: System.IFormattable
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.IFormattable
  System.Xml.Serialization:
    name:
      CSharp:
      - name: System.Xml.Serialization
        nameWithType: System.Xml.Serialization
        qualifiedName: System.Xml.Serialization
      VB:
      - name: System.Xml.Serialization
        nameWithType: System.Xml.Serialization
        qualifiedName: System.Xml.Serialization
    isDefinition: true
    commentId: N:System.Xml.Serialization
  System.Xml.Serialization.IXmlSerializable:
    name:
      CSharp:
      - id: System.Xml.Serialization.IXmlSerializable
        name: IXmlSerializable
        nameWithType: IXmlSerializable
        qualifiedName: System.Xml.Serialization.IXmlSerializable
        isExternal: true
      VB:
      - id: System.Xml.Serialization.IXmlSerializable
        name: IXmlSerializable
        nameWithType: IXmlSerializable
        qualifiedName: System.Xml.Serialization.IXmlSerializable
        isExternal: true
    isDefinition: true
    parent: System.Xml.Serialization
    commentId: T:System.Xml.Serialization.IXmlSerializable
  NodaTime.Offset:
    name:
      CSharp:
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      VB:
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.Offset
  NodaTime.OffsetDateTime.#ctor*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.#ctor*
        name: OffsetDateTime
        nameWithType: OffsetDateTime.OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime.OffsetDateTime
      VB:
      - id: NodaTime.OffsetDateTime.#ctor*
        name: OffsetDateTime
        nameWithType: OffsetDateTime.OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime.OffsetDateTime
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.#ctor
  NodaTime.OffsetDateTime.Calendar*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Calendar*
        name: Calendar
        nameWithType: OffsetDateTime.Calendar
        qualifiedName: NodaTime.OffsetDateTime.Calendar
      VB:
      - id: NodaTime.OffsetDateTime.Calendar*
        name: Calendar
        nameWithType: OffsetDateTime.Calendar
        qualifiedName: NodaTime.OffsetDateTime.Calendar
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Calendar
  NodaTime.OffsetDateTime.Year*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Year*
        name: Year
        nameWithType: OffsetDateTime.Year
        qualifiedName: NodaTime.OffsetDateTime.Year
      VB:
      - id: NodaTime.OffsetDateTime.Year*
        name: Year
        nameWithType: OffsetDateTime.Year
        qualifiedName: NodaTime.OffsetDateTime.Year
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Year
  NodaTime.OffsetDateTime.Month*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Month*
        name: Month
        nameWithType: OffsetDateTime.Month
        qualifiedName: NodaTime.OffsetDateTime.Month
      VB:
      - id: NodaTime.OffsetDateTime.Month*
        name: Month
        nameWithType: OffsetDateTime.Month
        qualifiedName: NodaTime.OffsetDateTime.Month
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Month
  NodaTime.OffsetDateTime.Day*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Day*
        name: Day
        nameWithType: OffsetDateTime.Day
        qualifiedName: NodaTime.OffsetDateTime.Day
      VB:
      - id: NodaTime.OffsetDateTime.Day*
        name: Day
        nameWithType: OffsetDateTime.Day
        qualifiedName: NodaTime.OffsetDateTime.Day
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Day
  NodaTime.OffsetDateTime.DayOfWeek:
    commentId: P:NodaTime.OffsetDateTime.DayOfWeek
  System.InvalidOperationException:
    commentId: T:System.InvalidOperationException
  NodaTime.OffsetDateTime.IsoDayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.IsoDayOfWeek*
        name: IsoDayOfWeek
        nameWithType: OffsetDateTime.IsoDayOfWeek
        qualifiedName: NodaTime.OffsetDateTime.IsoDayOfWeek
      VB:
      - id: NodaTime.OffsetDateTime.IsoDayOfWeek*
        name: IsoDayOfWeek
        nameWithType: OffsetDateTime.IsoDayOfWeek
        qualifiedName: NodaTime.OffsetDateTime.IsoDayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.IsoDayOfWeek
  NodaTime.OffsetDateTime.IsoDayOfWeek:
    commentId: P:NodaTime.OffsetDateTime.IsoDayOfWeek
  NodaTime.OffsetDateTime.DayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.DayOfWeek*
        name: DayOfWeek
        nameWithType: OffsetDateTime.DayOfWeek
        qualifiedName: NodaTime.OffsetDateTime.DayOfWeek
      VB:
      - id: NodaTime.OffsetDateTime.DayOfWeek*
        name: DayOfWeek
        nameWithType: OffsetDateTime.DayOfWeek
        qualifiedName: NodaTime.OffsetDateTime.DayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.DayOfWeek
  NodaTime.OffsetDateTime.WeekOfWeekYear:
    commentId: P:NodaTime.OffsetDateTime.WeekOfWeekYear
  NodaTime.OffsetDateTime.WeekYear*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.WeekYear*
        name: WeekYear
        nameWithType: OffsetDateTime.WeekYear
        qualifiedName: NodaTime.OffsetDateTime.WeekYear
      VB:
      - id: NodaTime.OffsetDateTime.WeekYear*
        name: WeekYear
        nameWithType: OffsetDateTime.WeekYear
        qualifiedName: NodaTime.OffsetDateTime.WeekYear
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.WeekYear
  NodaTime.OffsetDateTime.WeekYear:
    commentId: P:NodaTime.OffsetDateTime.WeekYear
  NodaTime.OffsetDateTime.WeekOfWeekYear*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.WeekOfWeekYear*
        name: WeekOfWeekYear
        nameWithType: OffsetDateTime.WeekOfWeekYear
        qualifiedName: NodaTime.OffsetDateTime.WeekOfWeekYear
      VB:
      - id: NodaTime.OffsetDateTime.WeekOfWeekYear*
        name: WeekOfWeekYear
        nameWithType: OffsetDateTime.WeekOfWeekYear
        qualifiedName: NodaTime.OffsetDateTime.WeekOfWeekYear
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.WeekOfWeekYear
  NodaTime.OffsetDateTime.YearOfCentury*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.YearOfCentury*
        name: YearOfCentury
        nameWithType: OffsetDateTime.YearOfCentury
        qualifiedName: NodaTime.OffsetDateTime.YearOfCentury
      VB:
      - id: NodaTime.OffsetDateTime.YearOfCentury*
        name: YearOfCentury
        nameWithType: OffsetDateTime.YearOfCentury
        qualifiedName: NodaTime.OffsetDateTime.YearOfCentury
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.YearOfCentury
  NodaTime.OffsetDateTime.YearOfEra*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.YearOfEra*
        name: YearOfEra
        nameWithType: OffsetDateTime.YearOfEra
        qualifiedName: NodaTime.OffsetDateTime.YearOfEra
      VB:
      - id: NodaTime.OffsetDateTime.YearOfEra*
        name: YearOfEra
        nameWithType: OffsetDateTime.YearOfEra
        qualifiedName: NodaTime.OffsetDateTime.YearOfEra
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.YearOfEra
  NodaTime.OffsetDateTime.Era*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Era*
        name: Era
        nameWithType: OffsetDateTime.Era
        qualifiedName: NodaTime.OffsetDateTime.Era
      VB:
      - id: NodaTime.OffsetDateTime.Era*
        name: Era
        nameWithType: OffsetDateTime.Era
        qualifiedName: NodaTime.OffsetDateTime.Era
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Era
  NodaTime.OffsetDateTime.DayOfYear*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.DayOfYear*
        name: DayOfYear
        nameWithType: OffsetDateTime.DayOfYear
        qualifiedName: NodaTime.OffsetDateTime.DayOfYear
      VB:
      - id: NodaTime.OffsetDateTime.DayOfYear*
        name: DayOfYear
        nameWithType: OffsetDateTime.DayOfYear
        qualifiedName: NodaTime.OffsetDateTime.DayOfYear
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.DayOfYear
  NodaTime.OffsetDateTime.Hour*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Hour*
        name: Hour
        nameWithType: OffsetDateTime.Hour
        qualifiedName: NodaTime.OffsetDateTime.Hour
      VB:
      - id: NodaTime.OffsetDateTime.Hour*
        name: Hour
        nameWithType: OffsetDateTime.Hour
        qualifiedName: NodaTime.OffsetDateTime.Hour
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Hour
  NodaTime.OffsetDateTime.ClockHourOfHalfDay*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.ClockHourOfHalfDay*
        name: ClockHourOfHalfDay
        nameWithType: OffsetDateTime.ClockHourOfHalfDay
        qualifiedName: NodaTime.OffsetDateTime.ClockHourOfHalfDay
      VB:
      - id: NodaTime.OffsetDateTime.ClockHourOfHalfDay*
        name: ClockHourOfHalfDay
        nameWithType: OffsetDateTime.ClockHourOfHalfDay
        qualifiedName: NodaTime.OffsetDateTime.ClockHourOfHalfDay
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.ClockHourOfHalfDay
  NodaTime.OffsetDateTime.Minute*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Minute*
        name: Minute
        nameWithType: OffsetDateTime.Minute
        qualifiedName: NodaTime.OffsetDateTime.Minute
      VB:
      - id: NodaTime.OffsetDateTime.Minute*
        name: Minute
        nameWithType: OffsetDateTime.Minute
        qualifiedName: NodaTime.OffsetDateTime.Minute
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Minute
  NodaTime.OffsetDateTime.Second*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Second*
        name: Second
        nameWithType: OffsetDateTime.Second
        qualifiedName: NodaTime.OffsetDateTime.Second
      VB:
      - id: NodaTime.OffsetDateTime.Second*
        name: Second
        nameWithType: OffsetDateTime.Second
        qualifiedName: NodaTime.OffsetDateTime.Second
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Second
  NodaTime.OffsetDateTime.Millisecond*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Millisecond*
        name: Millisecond
        nameWithType: OffsetDateTime.Millisecond
        qualifiedName: NodaTime.OffsetDateTime.Millisecond
      VB:
      - id: NodaTime.OffsetDateTime.Millisecond*
        name: Millisecond
        nameWithType: OffsetDateTime.Millisecond
        qualifiedName: NodaTime.OffsetDateTime.Millisecond
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Millisecond
  NodaTime.OffsetDateTime.TickOfSecond*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.TickOfSecond*
        name: TickOfSecond
        nameWithType: OffsetDateTime.TickOfSecond
        qualifiedName: NodaTime.OffsetDateTime.TickOfSecond
      VB:
      - id: NodaTime.OffsetDateTime.TickOfSecond*
        name: TickOfSecond
        nameWithType: OffsetDateTime.TickOfSecond
        qualifiedName: NodaTime.OffsetDateTime.TickOfSecond
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.TickOfSecond
  System.Int64:
    name:
      CSharp:
      - id: System.Int64
        name: Int64
        nameWithType: Int64
        qualifiedName: System.Int64
        isExternal: true
      VB:
      - id: System.Int64
        name: Int64
        nameWithType: Int64
        qualifiedName: System.Int64
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Int64
  NodaTime.OffsetDateTime.TickOfDay*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.TickOfDay*
        name: TickOfDay
        nameWithType: OffsetDateTime.TickOfDay
        qualifiedName: NodaTime.OffsetDateTime.TickOfDay
      VB:
      - id: NodaTime.OffsetDateTime.TickOfDay*
        name: TickOfDay
        nameWithType: OffsetDateTime.TickOfDay
        qualifiedName: NodaTime.OffsetDateTime.TickOfDay
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.TickOfDay
  NodaTime.OffsetDateTime.LocalDateTime*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.LocalDateTime*
        name: LocalDateTime
        nameWithType: OffsetDateTime.LocalDateTime
        qualifiedName: NodaTime.OffsetDateTime.LocalDateTime
      VB:
      - id: NodaTime.OffsetDateTime.LocalDateTime*
        name: LocalDateTime
        nameWithType: OffsetDateTime.LocalDateTime
        qualifiedName: NodaTime.OffsetDateTime.LocalDateTime
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.LocalDateTime
  NodaTime.LocalDate:
    name:
      CSharp:
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      VB:
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.LocalDate
  NodaTime.OffsetDateTime.Date*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Date*
        name: Date
        nameWithType: OffsetDateTime.Date
        qualifiedName: NodaTime.OffsetDateTime.Date
      VB:
      - id: NodaTime.OffsetDateTime.Date*
        name: Date
        nameWithType: OffsetDateTime.Date
        qualifiedName: NodaTime.OffsetDateTime.Date
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Date
  NodaTime.LocalTime:
    name:
      CSharp:
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      VB:
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.LocalTime
  NodaTime.OffsetDateTime.TimeOfDay*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.TimeOfDay*
        name: TimeOfDay
        nameWithType: OffsetDateTime.TimeOfDay
        qualifiedName: NodaTime.OffsetDateTime.TimeOfDay
      VB:
      - id: NodaTime.OffsetDateTime.TimeOfDay*
        name: TimeOfDay
        nameWithType: OffsetDateTime.TimeOfDay
        qualifiedName: NodaTime.OffsetDateTime.TimeOfDay
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.TimeOfDay
  NodaTime.OffsetDateTime.Offset*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Offset*
        name: Offset
        nameWithType: OffsetDateTime.Offset
        qualifiedName: NodaTime.OffsetDateTime.Offset
      VB:
      - id: NodaTime.OffsetDateTime.Offset*
        name: Offset
        nameWithType: OffsetDateTime.Offset
        qualifiedName: NodaTime.OffsetDateTime.Offset
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Offset
  NodaTime.Instant:
    name:
      CSharp:
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      VB:
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.Instant
  NodaTime.OffsetDateTime.ToInstant*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.ToInstant*
        name: ToInstant
        nameWithType: OffsetDateTime.ToInstant
        qualifiedName: NodaTime.OffsetDateTime.ToInstant
      VB:
      - id: NodaTime.OffsetDateTime.ToInstant*
        name: ToInstant
        nameWithType: OffsetDateTime.ToInstant
        qualifiedName: NodaTime.OffsetDateTime.ToInstant
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.ToInstant
  NodaTime.OffsetDateTime.InFixedZone*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.InFixedZone*
        name: InFixedZone
        nameWithType: OffsetDateTime.InFixedZone
        qualifiedName: NodaTime.OffsetDateTime.InFixedZone
      VB:
      - id: NodaTime.OffsetDateTime.InFixedZone*
        name: InFixedZone
        nameWithType: OffsetDateTime.InFixedZone
        qualifiedName: NodaTime.OffsetDateTime.InFixedZone
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.InFixedZone
  System.DateTime:
    name:
      CSharp:
      - id: System.DateTime
        name: DateTime
        nameWithType: DateTime
        qualifiedName: System.DateTime
        isExternal: true
      VB:
      - id: System.DateTime
        name: DateTime
        nameWithType: DateTime
        qualifiedName: System.DateTime
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.DateTime
  NodaTime.OffsetDateTime.ToDateTimeOffset*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.ToDateTimeOffset*
        name: ToDateTimeOffset
        nameWithType: OffsetDateTime.ToDateTimeOffset
        qualifiedName: NodaTime.OffsetDateTime.ToDateTimeOffset
      VB:
      - id: NodaTime.OffsetDateTime.ToDateTimeOffset*
        name: ToDateTimeOffset
        nameWithType: OffsetDateTime.ToDateTimeOffset
        qualifiedName: NodaTime.OffsetDateTime.ToDateTimeOffset
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.ToDateTimeOffset
  NodaTime.OffsetDateTime:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      VB:
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.OffsetDateTime
  NodaTime.OffsetDateTime.LocalDateTime:
    commentId: P:NodaTime.OffsetDateTime.LocalDateTime
  NodaTime.OffsetDateTime.Offset:
    commentId: P:NodaTime.OffsetDateTime.Offset
  NodaTime.OffsetDateTime.FromDateTimeOffset*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.FromDateTimeOffset*
        name: FromDateTimeOffset
        nameWithType: OffsetDateTime.FromDateTimeOffset
        qualifiedName: NodaTime.OffsetDateTime.FromDateTimeOffset
      VB:
      - id: NodaTime.OffsetDateTime.FromDateTimeOffset*
        name: FromDateTimeOffset
        nameWithType: OffsetDateTime.FromDateTimeOffset
        qualifiedName: NodaTime.OffsetDateTime.FromDateTimeOffset
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.FromDateTimeOffset
  NodaTime.OffsetDateTime.WithCalendar*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.WithCalendar*
        name: WithCalendar
        nameWithType: OffsetDateTime.WithCalendar
        qualifiedName: NodaTime.OffsetDateTime.WithCalendar
      VB:
      - id: NodaTime.OffsetDateTime.WithCalendar*
        name: WithCalendar
        nameWithType: OffsetDateTime.WithCalendar
        qualifiedName: NodaTime.OffsetDateTime.WithCalendar
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.WithCalendar
  System.ValueType.GetHashCode:
    name:
      CSharp:
      - id: System.ValueType.GetHashCode
        name: GetHashCode
        nameWithType: ValueType.GetHashCode
        qualifiedName: System.ValueType.GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.ValueType.GetHashCode
        name: GetHashCode
        nameWithType: ValueType.GetHashCode
        qualifiedName: System.ValueType.GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.ValueType
    commentId: M:System.ValueType.GetHashCode
  NodaTime.OffsetDateTime.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.GetHashCode*
        name: GetHashCode
        nameWithType: OffsetDateTime.GetHashCode
        qualifiedName: NodaTime.OffsetDateTime.GetHashCode
      VB:
      - id: NodaTime.OffsetDateTime.GetHashCode*
        name: GetHashCode
        nameWithType: OffsetDateTime.GetHashCode
        qualifiedName: NodaTime.OffsetDateTime.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.GetHashCode
  System.ValueType.Equals(System.Object):
    name:
      CSharp:
      - id: System.ValueType.Equals(System.Object)
        name: Equals
        nameWithType: ValueType.Equals
        qualifiedName: System.ValueType.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.ValueType.Equals(System.Object)
        name: Equals
        nameWithType: ValueType.Equals
        qualifiedName: System.ValueType.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.ValueType
    commentId: M:System.ValueType.Equals(System.Object)
  NodaTime.OffsetDateTime.Equals*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Equals*
        name: Equals
        nameWithType: OffsetDateTime.Equals
        qualifiedName: NodaTime.OffsetDateTime.Equals
      VB:
      - id: NodaTime.OffsetDateTime.Equals*
        name: Equals
        nameWithType: OffsetDateTime.Equals
        qualifiedName: NodaTime.OffsetDateTime.Equals
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Equals
  System.IEquatable`1.Equals(`0):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<T>.Equals
        qualifiedName: System.IEquatable<T>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of T).Equals
        qualifiedName: System.IEquatable(Of T).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.IEquatable`1.Equals(`0)
  System.IEquatable{NodaTime.OffsetDateTime}.Equals(NodaTime.OffsetDateTime):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<OffsetDateTime>.Equals
        qualifiedName: System.IEquatable<NodaTime.OffsetDateTime>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of OffsetDateTime).Equals
        qualifiedName: System.IEquatable(Of NodaTime.OffsetDateTime).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.OffsetDateTime}
    commentId: M:System.IEquatable{NodaTime.OffsetDateTime}.Equals(NodaTime.OffsetDateTime)
  System.ValueType.ToString:
    name:
      CSharp:
      - id: System.ValueType.ToString
        name: ToString
        nameWithType: ValueType.ToString
        qualifiedName: System.ValueType.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.ValueType.ToString
        name: ToString
        nameWithType: ValueType.ToString
        qualifiedName: System.ValueType.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.ValueType
    commentId: M:System.ValueType.ToString
  NodaTime.OffsetDateTime.ToString*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.ToString*
        name: ToString
        nameWithType: OffsetDateTime.ToString
        qualifiedName: NodaTime.OffsetDateTime.ToString
      VB:
      - id: NodaTime.OffsetDateTime.ToString*
        name: ToString
        nameWithType: OffsetDateTime.ToString
        qualifiedName: NodaTime.OffsetDateTime.ToString
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.ToString
  System.IFormatProvider:
    name:
      CSharp:
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      VB:
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.IFormatProvider
  System.IFormattable.ToString(System.String,System.IFormatProvider):
    name:
      CSharp:
      - id: System.IFormattable.ToString(System.String,System.IFormatProvider)
        name: ToString
        nameWithType: IFormattable.ToString
        qualifiedName: System.IFormattable.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IFormattable.ToString(System.String,System.IFormatProvider)
        name: ToString
        nameWithType: IFormattable.ToString
        qualifiedName: System.IFormattable.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.IFormattable
    commentId: M:System.IFormattable.ToString(System.String,System.IFormatProvider)
  NodaTime.OffsetDateTime.op_Equality*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.op_Equality*
        name: Equality
        nameWithType: OffsetDateTime.Equality
        qualifiedName: NodaTime.OffsetDateTime.Equality
      VB:
      - id: NodaTime.OffsetDateTime.op_Equality*
        name: Equality
        nameWithType: OffsetDateTime.Equality
        qualifiedName: NodaTime.OffsetDateTime.Equality
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.op_Equality
  NodaTime.OffsetDateTime.op_Inequality*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.op_Inequality*
        name: Inequality
        nameWithType: OffsetDateTime.Inequality
        qualifiedName: NodaTime.OffsetDateTime.Inequality
      VB:
      - id: NodaTime.OffsetDateTime.op_Inequality*
        name: Inequality
        nameWithType: OffsetDateTime.Inequality
        qualifiedName: NodaTime.OffsetDateTime.Inequality
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.op_Inequality
  System.Xml.Schema:
    name:
      CSharp:
      - name: System.Xml.Schema
        nameWithType: System.Xml.Schema
        qualifiedName: System.Xml.Schema
      VB:
      - name: System.Xml.Schema
        nameWithType: System.Xml.Schema
        qualifiedName: System.Xml.Schema
    isDefinition: true
    commentId: N:System.Xml.Schema
  System.Xml.Schema.XmlSchema:
    name:
      CSharp:
      - id: System.Xml.Schema.XmlSchema
        name: XmlSchema
        nameWithType: XmlSchema
        qualifiedName: System.Xml.Schema.XmlSchema
        isExternal: true
      VB:
      - id: System.Xml.Schema.XmlSchema
        name: XmlSchema
        nameWithType: XmlSchema
        qualifiedName: System.Xml.Schema.XmlSchema
        isExternal: true
    isDefinition: true
    parent: System.Xml.Schema
    commentId: T:System.Xml.Schema.XmlSchema
  NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: IXmlSerializable.GetSchema
        nameWithType: OffsetDateTime.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema
      VB:
      - id: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: System.Xml.Serialization.IXmlSerializable.GetSchema
        nameWithType: OffsetDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema
  System.Xml.Serialization.IXmlSerializable.GetSchema:
    name:
      CSharp:
      - id: System.Xml.Serialization.IXmlSerializable.GetSchema
        name: GetSchema
        nameWithType: IXmlSerializable.GetSchema
        qualifiedName: System.Xml.Serialization.IXmlSerializable.GetSchema
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Xml.Serialization.IXmlSerializable.GetSchema
        name: GetSchema
        nameWithType: IXmlSerializable.GetSchema
        qualifiedName: System.Xml.Serialization.IXmlSerializable.GetSchema
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Xml.Serialization.IXmlSerializable
    commentId: M:System.Xml.Serialization.IXmlSerializable.GetSchema
  System.Xml:
    name:
      CSharp:
      - name: System.Xml
        nameWithType: System.Xml
        qualifiedName: System.Xml
      VB:
      - name: System.Xml
        nameWithType: System.Xml
        qualifiedName: System.Xml
    isDefinition: true
    commentId: N:System.Xml
  System.Xml.XmlReader:
    name:
      CSharp:
      - id: System.Xml.XmlReader
        name: XmlReader
        nameWithType: XmlReader
        qualifiedName: System.Xml.XmlReader
        isExternal: true
      VB:
      - id: System.Xml.XmlReader
        name: XmlReader
        nameWithType: XmlReader
        qualifiedName: System.Xml.XmlReader
        isExternal: true
    isDefinition: true
    parent: System.Xml
    commentId: T:System.Xml.XmlReader
  NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: IXmlSerializable.ReadXml
        nameWithType: OffsetDateTime.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml
      VB:
      - id: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: System.Xml.Serialization.IXmlSerializable.ReadXml
        nameWithType: OffsetDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml
  System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader):
    name:
      CSharp:
      - id: System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        name: ReadXml
        nameWithType: IXmlSerializable.ReadXml
        qualifiedName: System.Xml.Serialization.IXmlSerializable.ReadXml
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Xml.XmlReader
        name: XmlReader
        nameWithType: XmlReader
        qualifiedName: System.Xml.XmlReader
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
        name: ReadXml
        nameWithType: IXmlSerializable.ReadXml
        qualifiedName: System.Xml.Serialization.IXmlSerializable.ReadXml
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Xml.XmlReader
        name: XmlReader
        nameWithType: XmlReader
        qualifiedName: System.Xml.XmlReader
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Xml.Serialization.IXmlSerializable
    commentId: M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)
  System.Xml.XmlWriter:
    name:
      CSharp:
      - id: System.Xml.XmlWriter
        name: XmlWriter
        nameWithType: XmlWriter
        qualifiedName: System.Xml.XmlWriter
        isExternal: true
      VB:
      - id: System.Xml.XmlWriter
        name: XmlWriter
        nameWithType: XmlWriter
        qualifiedName: System.Xml.XmlWriter
        isExternal: true
    isDefinition: true
    parent: System.Xml
    commentId: T:System.Xml.XmlWriter
  NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: IXmlSerializable.WriteXml
        nameWithType: OffsetDateTime.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml
      VB:
      - id: NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: System.Xml.Serialization.IXmlSerializable.WriteXml
        nameWithType: OffsetDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.OffsetDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml
  System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter):
    name:
      CSharp:
      - id: System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        name: WriteXml
        nameWithType: IXmlSerializable.WriteXml
        qualifiedName: System.Xml.Serialization.IXmlSerializable.WriteXml
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Xml.XmlWriter
        name: XmlWriter
        nameWithType: XmlWriter
        qualifiedName: System.Xml.XmlWriter
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
        name: WriteXml
        nameWithType: IXmlSerializable.WriteXml
        qualifiedName: System.Xml.Serialization.IXmlSerializable.WriteXml
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Xml.XmlWriter
        name: XmlWriter
        nameWithType: XmlWriter
        qualifiedName: System.Xml.XmlWriter
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Xml.Serialization.IXmlSerializable
    commentId: M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)
  ? System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  : name:
      CSharp:
      - id: System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        name: GetObjectData
        nameWithType: ISerializable.GetObjectData
        qualifiedName: System.Runtime.Serialization.ISerializable.GetObjectData
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        name: GetObjectData
        nameWithType: ISerializable.GetObjectData
        qualifiedName: System.Runtime.Serialization.ISerializable.GetObjectData
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Runtime.Serialization.ISerializable
    commentId: M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  System.Runtime.Serialization.SerializationInfo:
    name:
      CSharp:
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
      VB:
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
    isDefinition: true
    parent: System.Runtime.Serialization
    commentId: T:System.Runtime.Serialization.SerializationInfo
  System.Runtime.Serialization.StreamingContext:
    name:
      CSharp:
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
      VB:
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
    isDefinition: true
    parent: System.Runtime.Serialization
    commentId: T:System.Runtime.Serialization.StreamingContext
  NodaTime.OffsetDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: ISerializable.GetObjectData
        nameWithType: OffsetDateTime.ISerializable.GetObjectData
        qualifiedName: NodaTime.OffsetDateTime.System.Runtime.Serialization.ISerializable.GetObjectData
      VB:
      - id: NodaTime.OffsetDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: System.Runtime.Serialization.ISerializable.GetObjectData
        nameWithType: OffsetDateTime.System.Runtime.Serialization.ISerializable.GetObjectData
        qualifiedName: NodaTime.OffsetDateTime.System.Runtime.Serialization.ISerializable.GetObjectData
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.System#Runtime#Serialization#ISerializable#GetObjectData
  System.Collections.Generic.IEqualityComparer`1:
    name:
      CSharp:
      - id: System.Collections.Generic.IEqualityComparer`1
        name: IEqualityComparer
        nameWithType: IEqualityComparer
        qualifiedName: System.Collections.Generic.IEqualityComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IEqualityComparer`1
        name: IEqualityComparer
        nameWithType: IEqualityComparer
        qualifiedName: System.Collections.Generic.IEqualityComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.Generic.IEqualityComparer`1
  System.Collections.Generic.IComparer`1:
    name:
      CSharp:
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.Generic.IComparer`1
  System.Collections.Generic.IComparer{NodaTime.OffsetDateTime}:
    name:
      CSharp:
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IComparer`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IComparer{NodaTime.OffsetDateTime}
  NodaTime.OffsetDateTime.Comparer:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Comparer
        name: OffsetDateTime.Comparer
        nameWithType: OffsetDateTime.Comparer
        qualifiedName: NodaTime.OffsetDateTime.Comparer
      VB:
      - id: NodaTime.OffsetDateTime.Comparer
        name: OffsetDateTime.Comparer
        nameWithType: OffsetDateTime.Comparer
        qualifiedName: NodaTime.OffsetDateTime.Comparer
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.OffsetDateTime.Comparer
  NodaTime.OffsetDateTime.Comparer.Local*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Comparer.Local*
        name: Local
        nameWithType: OffsetDateTime.Comparer.Local
        qualifiedName: NodaTime.OffsetDateTime.Comparer.Local
      VB:
      - id: NodaTime.OffsetDateTime.Comparer.Local*
        name: Local
        nameWithType: OffsetDateTime.Comparer.Local
        qualifiedName: NodaTime.OffsetDateTime.Comparer.Local
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Comparer.Local
  NodaTime.OffsetDateTime.Comparer.Instant*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Comparer.Instant*
        name: Instant
        nameWithType: OffsetDateTime.Comparer.Instant
        qualifiedName: NodaTime.OffsetDateTime.Comparer.Instant
      VB:
      - id: NodaTime.OffsetDateTime.Comparer.Instant*
        name: Instant
        nameWithType: OffsetDateTime.Comparer.Instant
        qualifiedName: NodaTime.OffsetDateTime.Comparer.Instant
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Comparer.Instant
  NodaTime.OffsetDateTime.Comparer.Compare*:
    name:
      CSharp:
      - id: NodaTime.OffsetDateTime.Comparer.Compare*
        name: Compare
        nameWithType: OffsetDateTime.Comparer.Compare
        qualifiedName: NodaTime.OffsetDateTime.Comparer.Compare
      VB:
      - id: NodaTime.OffsetDateTime.Comparer.Compare*
        name: Compare
        nameWithType: OffsetDateTime.Comparer.Compare
        qualifiedName: NodaTime.OffsetDateTime.Comparer.Compare
    isDefinition: true
    commentId: Overload:NodaTime.OffsetDateTime.Comparer.Compare
  System.Collections.Generic.IComparer`1.Compare(`0,`0):
    name:
      CSharp:
      - id: System.Collections.Generic.IComparer`1.Compare(`0,`0)
        name: Compare
        nameWithType: IComparer<T>.Compare
        qualifiedName: System.Collections.Generic.IComparer<T>.Compare
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.IComparer`1.Compare(`0,`0)
        name: Compare
        nameWithType: IComparer(Of T).Compare
        qualifiedName: System.Collections.Generic.IComparer(Of T).Compare
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.IComparer`1.Compare(`0,`0)
  System.Collections.Generic.IComparer{NodaTime.OffsetDateTime}.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime):
    name:
      CSharp:
      - id: System.Collections.Generic.IComparer`1.Compare(`0,`0)
        name: Compare
        nameWithType: IComparer<OffsetDateTime>.Compare
        qualifiedName: System.Collections.Generic.IComparer<NodaTime.OffsetDateTime>.Compare
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.IComparer`1.Compare(`0,`0)
        name: Compare
        nameWithType: IComparer(Of OffsetDateTime).Compare
        qualifiedName: System.Collections.Generic.IComparer(Of NodaTime.OffsetDateTime).Compare
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IComparer`1.Compare(`0,`0)
    parent: System.Collections.Generic.IComparer{NodaTime.OffsetDateTime}
    commentId: M:System.Collections.Generic.IComparer{NodaTime.OffsetDateTime}.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)
  NodaTime.TimeZones.IDateTimeZoneSource:
    name:
      CSharp:
      - id: NodaTime.TimeZones.IDateTimeZoneSource
        name: IDateTimeZoneSource
        nameWithType: IDateTimeZoneSource
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource
      VB:
      - id: NodaTime.TimeZones.IDateTimeZoneSource
        name: IDateTimeZoneSource
        nameWithType: IDateTimeZoneSource
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource
    isDefinition: true
    parent: NodaTime.TimeZones
    commentId: T:NodaTime.TimeZones.IDateTimeZoneSource
  NodaTime.TimeZones.DateTimeZoneCache:
    name:
      CSharp:
      - id: NodaTime.TimeZones.DateTimeZoneCache
        name: DateTimeZoneCache
        nameWithType: DateTimeZoneCache
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache
      VB:
      - id: NodaTime.TimeZones.DateTimeZoneCache
        name: DateTimeZoneCache
        nameWithType: DateTimeZoneCache
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache
    isDefinition: true
    commentId: T:NodaTime.TimeZones.DateTimeZoneCache
  NodaTime.IDateTimeZoneProvider.VersionId*:
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider.VersionId*
        name: VersionId
        nameWithType: IDateTimeZoneProvider.VersionId
        qualifiedName: NodaTime.IDateTimeZoneProvider.VersionId
      VB:
      - id: NodaTime.IDateTimeZoneProvider.VersionId*
        name: VersionId
        nameWithType: IDateTimeZoneProvider.VersionId
        qualifiedName: NodaTime.IDateTimeZoneProvider.VersionId
    isDefinition: true
    commentId: Overload:NodaTime.IDateTimeZoneProvider.VersionId
  System.Collections.ObjectModel.ReadOnlyCollection`1:
    name:
      CSharp:
      - id: System.Collections.ObjectModel.ReadOnlyCollection`1
        name: ReadOnlyCollection
        nameWithType: ReadOnlyCollection
        qualifiedName: System.Collections.ObjectModel.ReadOnlyCollection
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.ObjectModel.ReadOnlyCollection`1
        name: ReadOnlyCollection
        nameWithType: ReadOnlyCollection
        qualifiedName: System.Collections.ObjectModel.ReadOnlyCollection
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.ObjectModel.ReadOnlyCollection`1
  System.Collections.ObjectModel:
    name:
      CSharp:
      - name: System.Collections.ObjectModel
        nameWithType: System.Collections.ObjectModel
        qualifiedName: System.Collections.ObjectModel
      VB:
      - name: System.Collections.ObjectModel
        nameWithType: System.Collections.ObjectModel
        qualifiedName: System.Collections.ObjectModel
    isDefinition: true
    commentId: N:System.Collections.ObjectModel
  System.Collections.ObjectModel.ReadOnlyCollection{System.String}:
    name:
      CSharp:
      - id: System.Collections.ObjectModel.ReadOnlyCollection`1
        name: ReadOnlyCollection
        nameWithType: ReadOnlyCollection
        qualifiedName: System.Collections.ObjectModel.ReadOnlyCollection
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.ObjectModel.ReadOnlyCollection`1
        name: ReadOnlyCollection
        nameWithType: ReadOnlyCollection
        qualifiedName: System.Collections.ObjectModel.ReadOnlyCollection
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.ObjectModel.ReadOnlyCollection`1
    parent: System.Collections.ObjectModel
    commentId: T:System.Collections.ObjectModel.ReadOnlyCollection{System.String}
  NodaTime.IDateTimeZoneProvider.Ids*:
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider.Ids*
        name: Ids
        nameWithType: IDateTimeZoneProvider.Ids
        qualifiedName: NodaTime.IDateTimeZoneProvider.Ids
      VB:
      - id: NodaTime.IDateTimeZoneProvider.Ids*
        name: Ids
        nameWithType: IDateTimeZoneProvider.Ids
        qualifiedName: NodaTime.IDateTimeZoneProvider.Ids
    isDefinition: true
    commentId: Overload:NodaTime.IDateTimeZoneProvider.Ids
  NodaTime.TimeZones.DateTimeZoneNotFoundException:
    name:
      CSharp:
      - id: NodaTime.TimeZones.DateTimeZoneNotFoundException
        name: DateTimeZoneNotFoundException
        nameWithType: DateTimeZoneNotFoundException
        qualifiedName: NodaTime.TimeZones.DateTimeZoneNotFoundException
      VB:
      - id: NodaTime.TimeZones.DateTimeZoneNotFoundException
        name: DateTimeZoneNotFoundException
        nameWithType: DateTimeZoneNotFoundException
        qualifiedName: NodaTime.TimeZones.DateTimeZoneNotFoundException
    isDefinition: true
    commentId: T:NodaTime.TimeZones.DateTimeZoneNotFoundException
  NodaTime.TimeZones.BclDateTimeZone:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZone
        name: BclDateTimeZone
        nameWithType: BclDateTimeZone
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZone
        name: BclDateTimeZone
        nameWithType: BclDateTimeZone
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone
    isDefinition: true
    parent: NodaTime.TimeZones
    commentId: T:NodaTime.TimeZones.BclDateTimeZone
  NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault:
    commentId: M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault
  System.TimeZoneInfo:
    name:
      CSharp:
      - id: System.TimeZoneInfo
        name: TimeZoneInfo
        nameWithType: TimeZoneInfo
        qualifiedName: System.TimeZoneInfo
        isExternal: true
      VB:
      - id: System.TimeZoneInfo
        name: TimeZoneInfo
        nameWithType: TimeZoneInfo
        qualifiedName: System.TimeZoneInfo
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.TimeZoneInfo
  NodaTime.IDateTimeZoneProvider.GetSystemDefault*:
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider.GetSystemDefault*
        name: GetSystemDefault
        nameWithType: IDateTimeZoneProvider.GetSystemDefault
        qualifiedName: NodaTime.IDateTimeZoneProvider.GetSystemDefault
      VB:
      - id: NodaTime.IDateTimeZoneProvider.GetSystemDefault*
        name: GetSystemDefault
        nameWithType: IDateTimeZoneProvider.GetSystemDefault
        qualifiedName: NodaTime.IDateTimeZoneProvider.GetSystemDefault
    isDefinition: true
    commentId: Overload:NodaTime.IDateTimeZoneProvider.GetSystemDefault
  NodaTime.DateTimeZone.ForOffset(NodaTime.Offset):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)
        name: ForOffset
        nameWithType: DateTimeZone.ForOffset
        qualifiedName: NodaTime.DateTimeZone.ForOffset
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)
        name: ForOffset
        nameWithType: DateTimeZone.ForOffset
        qualifiedName: NodaTime.DateTimeZone.ForOffset
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)
  NodaTime.IDateTimeZoneProvider.GetZoneOrNull*:
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider.GetZoneOrNull*
        name: GetZoneOrNull
        nameWithType: IDateTimeZoneProvider.GetZoneOrNull
        qualifiedName: NodaTime.IDateTimeZoneProvider.GetZoneOrNull
      VB:
      - id: NodaTime.IDateTimeZoneProvider.GetZoneOrNull*
        name: GetZoneOrNull
        nameWithType: IDateTimeZoneProvider.GetZoneOrNull
        qualifiedName: NodaTime.IDateTimeZoneProvider.GetZoneOrNull
    isDefinition: true
    commentId: Overload:NodaTime.IDateTimeZoneProvider.GetZoneOrNull
  NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String):
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)
        name: GetZoneOrNull
        nameWithType: IDateTimeZoneProvider.GetZoneOrNull
        qualifiedName: NodaTime.IDateTimeZoneProvider.GetZoneOrNull
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)
        name: GetZoneOrNull
        nameWithType: IDateTimeZoneProvider.GetZoneOrNull
        qualifiedName: NodaTime.IDateTimeZoneProvider.GetZoneOrNull
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.IDateTimeZoneProvider
    commentId: M:NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)
  NodaTime.IDateTimeZoneProvider.Item*:
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider.Item*
        name: Item
        nameWithType: IDateTimeZoneProvider.Item
        qualifiedName: NodaTime.IDateTimeZoneProvider.Item
      VB:
      - id: NodaTime.IDateTimeZoneProvider.Item*
        name: Item
        nameWithType: IDateTimeZoneProvider.Item
        qualifiedName: NodaTime.IDateTimeZoneProvider.Item
    isDefinition: true
    commentId: Overload:NodaTime.IDateTimeZoneProvider.Item
  NodaTime.Period:
    name:
      CSharp:
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      VB:
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.Period
  NodaTime.PeriodBuilder.Build:
    commentId: M:NodaTime.PeriodBuilder.Build
  NodaTime.PeriodBuilder.Years*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Years*
        name: Years
        nameWithType: PeriodBuilder.Years
        qualifiedName: NodaTime.PeriodBuilder.Years
      VB:
      - id: NodaTime.PeriodBuilder.Years*
        name: Years
        nameWithType: PeriodBuilder.Years
        qualifiedName: NodaTime.PeriodBuilder.Years
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Years
  NodaTime.PeriodBuilder.Months*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Months*
        name: Months
        nameWithType: PeriodBuilder.Months
        qualifiedName: NodaTime.PeriodBuilder.Months
      VB:
      - id: NodaTime.PeriodBuilder.Months*
        name: Months
        nameWithType: PeriodBuilder.Months
        qualifiedName: NodaTime.PeriodBuilder.Months
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Months
  NodaTime.PeriodBuilder.Weeks*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Weeks*
        name: Weeks
        nameWithType: PeriodBuilder.Weeks
        qualifiedName: NodaTime.PeriodBuilder.Weeks
      VB:
      - id: NodaTime.PeriodBuilder.Weeks*
        name: Weeks
        nameWithType: PeriodBuilder.Weeks
        qualifiedName: NodaTime.PeriodBuilder.Weeks
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Weeks
  NodaTime.PeriodBuilder.Days*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Days*
        name: Days
        nameWithType: PeriodBuilder.Days
        qualifiedName: NodaTime.PeriodBuilder.Days
      VB:
      - id: NodaTime.PeriodBuilder.Days*
        name: Days
        nameWithType: PeriodBuilder.Days
        qualifiedName: NodaTime.PeriodBuilder.Days
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Days
  NodaTime.PeriodBuilder.Hours*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Hours*
        name: Hours
        nameWithType: PeriodBuilder.Hours
        qualifiedName: NodaTime.PeriodBuilder.Hours
      VB:
      - id: NodaTime.PeriodBuilder.Hours*
        name: Hours
        nameWithType: PeriodBuilder.Hours
        qualifiedName: NodaTime.PeriodBuilder.Hours
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Hours
  NodaTime.PeriodBuilder.Minutes*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Minutes*
        name: Minutes
        nameWithType: PeriodBuilder.Minutes
        qualifiedName: NodaTime.PeriodBuilder.Minutes
      VB:
      - id: NodaTime.PeriodBuilder.Minutes*
        name: Minutes
        nameWithType: PeriodBuilder.Minutes
        qualifiedName: NodaTime.PeriodBuilder.Minutes
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Minutes
  NodaTime.PeriodBuilder.Seconds*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Seconds*
        name: Seconds
        nameWithType: PeriodBuilder.Seconds
        qualifiedName: NodaTime.PeriodBuilder.Seconds
      VB:
      - id: NodaTime.PeriodBuilder.Seconds*
        name: Seconds
        nameWithType: PeriodBuilder.Seconds
        qualifiedName: NodaTime.PeriodBuilder.Seconds
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Seconds
  NodaTime.PeriodBuilder.Milliseconds*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Milliseconds*
        name: Milliseconds
        nameWithType: PeriodBuilder.Milliseconds
        qualifiedName: NodaTime.PeriodBuilder.Milliseconds
      VB:
      - id: NodaTime.PeriodBuilder.Milliseconds*
        name: Milliseconds
        nameWithType: PeriodBuilder.Milliseconds
        qualifiedName: NodaTime.PeriodBuilder.Milliseconds
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Milliseconds
  NodaTime.PeriodBuilder.Ticks*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Ticks*
        name: Ticks
        nameWithType: PeriodBuilder.Ticks
        qualifiedName: NodaTime.PeriodBuilder.Ticks
      VB:
      - id: NodaTime.PeriodBuilder.Ticks*
        name: Ticks
        nameWithType: PeriodBuilder.Ticks
        qualifiedName: NodaTime.PeriodBuilder.Ticks
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Ticks
  NodaTime.PeriodBuilder.#ctor*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.#ctor*
        name: PeriodBuilder
        nameWithType: PeriodBuilder.PeriodBuilder
        qualifiedName: NodaTime.PeriodBuilder.PeriodBuilder
      VB:
      - id: NodaTime.PeriodBuilder.#ctor*
        name: PeriodBuilder
        nameWithType: PeriodBuilder.PeriodBuilder
        qualifiedName: NodaTime.PeriodBuilder.PeriodBuilder
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.#ctor
  NodaTime.Period.ToBuilder:
    commentId: M:NodaTime.Period.ToBuilder
  NodaTime.PeriodUnits:
    name:
      CSharp:
      - id: NodaTime.PeriodUnits
        name: PeriodUnits
        nameWithType: PeriodUnits
        qualifiedName: NodaTime.PeriodUnits
      VB:
      - id: NodaTime.PeriodUnits
        name: PeriodUnits
        nameWithType: PeriodUnits
        qualifiedName: NodaTime.PeriodUnits
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.PeriodUnits
  NodaTime.PeriodBuilder.Item*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Item*
        name: Item
        nameWithType: PeriodBuilder.Item
        qualifiedName: NodaTime.PeriodBuilder.Item
      VB:
      - id: NodaTime.PeriodBuilder.Item*
        name: Item
        nameWithType: PeriodBuilder.Item
        qualifiedName: NodaTime.PeriodBuilder.Item
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Item
  NodaTime.PeriodBuilder.Build*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.Build*
        name: Build
        nameWithType: PeriodBuilder.Build
        qualifiedName: NodaTime.PeriodBuilder.Build
      VB:
      - id: NodaTime.PeriodBuilder.Build*
        name: Build
        nameWithType: PeriodBuilder.Build
        qualifiedName: NodaTime.PeriodBuilder.Build
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.Build
  NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#GetSchema*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: IXmlSerializable.GetSchema
        nameWithType: PeriodBuilder.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.GetSchema
      VB:
      - id: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: System.Xml.Serialization.IXmlSerializable.GetSchema
        nameWithType: PeriodBuilder.System.Xml.Serialization.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.GetSchema
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#GetSchema
  NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#ReadXml*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: IXmlSerializable.ReadXml
        nameWithType: PeriodBuilder.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.ReadXml
      VB:
      - id: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: System.Xml.Serialization.IXmlSerializable.ReadXml
        nameWithType: PeriodBuilder.System.Xml.Serialization.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.ReadXml
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#ReadXml
  NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#WriteXml*:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: IXmlSerializable.WriteXml
        nameWithType: PeriodBuilder.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.WriteXml
      VB:
      - id: NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: System.Xml.Serialization.IXmlSerializable.WriteXml
        nameWithType: PeriodBuilder.System.Xml.Serialization.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.PeriodBuilder.System.Xml.Serialization.IXmlSerializable.WriteXml
    isDefinition: true
    commentId: Overload:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#WriteXml
  NodaTime.PeriodBuilder:
    name:
      CSharp:
      - id: NodaTime.PeriodBuilder
        name: PeriodBuilder
        nameWithType: PeriodBuilder
        qualifiedName: NodaTime.PeriodBuilder
      VB:
      - id: NodaTime.PeriodBuilder
        name: PeriodBuilder
        nameWithType: PeriodBuilder
        qualifiedName: NodaTime.PeriodBuilder
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.PeriodBuilder
  NodaTime.PeriodUnits.Years:
    commentId: F:NodaTime.PeriodUnits.Years
  NodaTime.PeriodUnits.Months:
    commentId: F:NodaTime.PeriodUnits.Months
  NodaTime.PeriodUnits.Weeks:
    commentId: F:NodaTime.PeriodUnits.Weeks
  NodaTime.PeriodUnits.Days:
    commentId: F:NodaTime.PeriodUnits.Days
  NodaTime.PeriodUnits.Hours:
    commentId: F:NodaTime.PeriodUnits.Hours
  NodaTime.PeriodUnits.Minutes:
    commentId: F:NodaTime.PeriodUnits.Minutes
  NodaTime.PeriodUnits.Seconds:
    commentId: F:NodaTime.PeriodUnits.Seconds
  System.FlagsAttribute:
    name:
      CSharp:
      - id: System.FlagsAttribute
        name: FlagsAttribute
        nameWithType: FlagsAttribute
        qualifiedName: System.FlagsAttribute
        isExternal: true
      VB:
      - id: System.FlagsAttribute
        name: FlagsAttribute
        nameWithType: FlagsAttribute
        qualifiedName: System.FlagsAttribute
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.FlagsAttribute
  System.FlagsAttribute.#ctor:
    name:
      CSharp:
      - id: System.FlagsAttribute.#ctor
        name: FlagsAttribute
        nameWithType: FlagsAttribute.FlagsAttribute
        qualifiedName: System.FlagsAttribute.FlagsAttribute
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.FlagsAttribute.#ctor
        name: FlagsAttribute
        nameWithType: FlagsAttribute.FlagsAttribute
        qualifiedName: System.FlagsAttribute.FlagsAttribute
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.FlagsAttribute
    commentId: M:System.FlagsAttribute.#ctor
  NodaTime.IClock:
    name:
      CSharp:
      - id: NodaTime.IClock
        name: IClock
        nameWithType: IClock
        qualifiedName: NodaTime.IClock
      VB:
      - id: NodaTime.IClock
        name: IClock
        nameWithType: IClock
        qualifiedName: NodaTime.IClock
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.IClock
  System.DateTime.UtcNow:
    commentId: P:System.DateTime.UtcNow
  NodaTime.SystemClock:
    name:
      CSharp:
      - id: NodaTime.SystemClock
        name: SystemClock
        nameWithType: SystemClock
        qualifiedName: NodaTime.SystemClock
      VB:
      - id: NodaTime.SystemClock
        name: SystemClock
        nameWithType: SystemClock
        qualifiedName: NodaTime.SystemClock
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.SystemClock
  NodaTime.Testing.FakeClock:
    commentId: T:NodaTime.Testing.FakeClock
  NodaTime.IClock.Now*:
    name:
      CSharp:
      - id: NodaTime.IClock.Now*
        name: Now
        nameWithType: IClock.Now
        qualifiedName: NodaTime.IClock.Now
      VB:
      - id: NodaTime.IClock.Now*
        name: Now
        nameWithType: IClock.Now
        qualifiedName: NodaTime.IClock.Now
    isDefinition: true
    commentId: Overload:NodaTime.IClock.Now
  NodaTime.LocalDate.Equals(NodaTime.LocalDate):
    commentId: M:NodaTime.LocalDate.Equals(NodaTime.LocalDate)
  NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate):
    commentId: M:NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate)
  NodaTime.LocalDate.CompareTo(NodaTime.LocalDate):
    commentId: M:NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)
  System.IComparable`1:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.IComparable`1
  System.IEquatable{NodaTime.LocalDate}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.LocalDate}
  System.IComparable{NodaTime.LocalDate}:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1
    parent: System
    commentId: T:System.IComparable{NodaTime.LocalDate}
  System.IComparable:
    name:
      CSharp:
      - id: System.IComparable
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      VB:
      - id: System.IComparable
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.IComparable
  NodaTime.LocalDate.#ctor*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.#ctor*
        name: LocalDate
        nameWithType: LocalDate.LocalDate
        qualifiedName: NodaTime.LocalDate.LocalDate
      VB:
      - id: NodaTime.LocalDate.#ctor*
        name: LocalDate
        nameWithType: LocalDate.LocalDate
        qualifiedName: NodaTime.LocalDate.LocalDate
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.#ctor
  NodaTime.LocalDate.Calendar*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Calendar*
        name: Calendar
        nameWithType: LocalDate.Calendar
        qualifiedName: NodaTime.LocalDate.Calendar
      VB:
      - id: NodaTime.LocalDate.Calendar*
        name: Calendar
        nameWithType: LocalDate.Calendar
        qualifiedName: NodaTime.LocalDate.Calendar
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Calendar
  NodaTime.LocalDate.Year*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Year*
        name: Year
        nameWithType: LocalDate.Year
        qualifiedName: NodaTime.LocalDate.Year
      VB:
      - id: NodaTime.LocalDate.Year*
        name: Year
        nameWithType: LocalDate.Year
        qualifiedName: NodaTime.LocalDate.Year
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Year
  NodaTime.LocalDate.Month*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Month*
        name: Month
        nameWithType: LocalDate.Month
        qualifiedName: NodaTime.LocalDate.Month
      VB:
      - id: NodaTime.LocalDate.Month*
        name: Month
        nameWithType: LocalDate.Month
        qualifiedName: NodaTime.LocalDate.Month
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Month
  NodaTime.LocalDate.Day*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Day*
        name: Day
        nameWithType: LocalDate.Day
        qualifiedName: NodaTime.LocalDate.Day
      VB:
      - id: NodaTime.LocalDate.Day*
        name: Day
        nameWithType: LocalDate.Day
        qualifiedName: NodaTime.LocalDate.Day
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Day
  NodaTime.LocalDate.DayOfWeek:
    commentId: P:NodaTime.LocalDate.DayOfWeek
  NodaTime.LocalDate.IsoDayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.IsoDayOfWeek*
        name: IsoDayOfWeek
        nameWithType: LocalDate.IsoDayOfWeek
        qualifiedName: NodaTime.LocalDate.IsoDayOfWeek
      VB:
      - id: NodaTime.LocalDate.IsoDayOfWeek*
        name: IsoDayOfWeek
        nameWithType: LocalDate.IsoDayOfWeek
        qualifiedName: NodaTime.LocalDate.IsoDayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.IsoDayOfWeek
  NodaTime.LocalDate.IsoDayOfWeek:
    commentId: P:NodaTime.LocalDate.IsoDayOfWeek
  NodaTime.LocalDate.DayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.DayOfWeek*
        name: DayOfWeek
        nameWithType: LocalDate.DayOfWeek
        qualifiedName: NodaTime.LocalDate.DayOfWeek
      VB:
      - id: NodaTime.LocalDate.DayOfWeek*
        name: DayOfWeek
        nameWithType: LocalDate.DayOfWeek
        qualifiedName: NodaTime.LocalDate.DayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.DayOfWeek
  NodaTime.LocalDate.WeekOfWeekYear:
    commentId: P:NodaTime.LocalDate.WeekOfWeekYear
  NodaTime.LocalDate.WeekYear*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.WeekYear*
        name: WeekYear
        nameWithType: LocalDate.WeekYear
        qualifiedName: NodaTime.LocalDate.WeekYear
      VB:
      - id: NodaTime.LocalDate.WeekYear*
        name: WeekYear
        nameWithType: LocalDate.WeekYear
        qualifiedName: NodaTime.LocalDate.WeekYear
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.WeekYear
  NodaTime.LocalDate.WeekYear:
    commentId: P:NodaTime.LocalDate.WeekYear
  NodaTime.LocalDate.WeekOfWeekYear*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.WeekOfWeekYear*
        name: WeekOfWeekYear
        nameWithType: LocalDate.WeekOfWeekYear
        qualifiedName: NodaTime.LocalDate.WeekOfWeekYear
      VB:
      - id: NodaTime.LocalDate.WeekOfWeekYear*
        name: WeekOfWeekYear
        nameWithType: LocalDate.WeekOfWeekYear
        qualifiedName: NodaTime.LocalDate.WeekOfWeekYear
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.WeekOfWeekYear
  NodaTime.LocalDate.YearOfCentury*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.YearOfCentury*
        name: YearOfCentury
        nameWithType: LocalDate.YearOfCentury
        qualifiedName: NodaTime.LocalDate.YearOfCentury
      VB:
      - id: NodaTime.LocalDate.YearOfCentury*
        name: YearOfCentury
        nameWithType: LocalDate.YearOfCentury
        qualifiedName: NodaTime.LocalDate.YearOfCentury
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.YearOfCentury
  NodaTime.LocalDate.YearOfEra*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.YearOfEra*
        name: YearOfEra
        nameWithType: LocalDate.YearOfEra
        qualifiedName: NodaTime.LocalDate.YearOfEra
      VB:
      - id: NodaTime.LocalDate.YearOfEra*
        name: YearOfEra
        nameWithType: LocalDate.YearOfEra
        qualifiedName: NodaTime.LocalDate.YearOfEra
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.YearOfEra
  NodaTime.LocalDate.Era*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Era*
        name: Era
        nameWithType: LocalDate.Era
        qualifiedName: NodaTime.LocalDate.Era
      VB:
      - id: NodaTime.LocalDate.Era*
        name: Era
        nameWithType: LocalDate.Era
        qualifiedName: NodaTime.LocalDate.Era
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Era
  NodaTime.LocalDate.DayOfYear*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.DayOfYear*
        name: DayOfYear
        nameWithType: LocalDate.DayOfYear
        qualifiedName: NodaTime.LocalDate.DayOfYear
      VB:
      - id: NodaTime.LocalDate.DayOfYear*
        name: DayOfYear
        nameWithType: LocalDate.DayOfYear
        qualifiedName: NodaTime.LocalDate.DayOfYear
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.DayOfYear
  NodaTime.LocalDate.AtMidnight*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.AtMidnight*
        name: AtMidnight
        nameWithType: LocalDate.AtMidnight
        qualifiedName: NodaTime.LocalDate.AtMidnight
      VB:
      - id: NodaTime.LocalDate.AtMidnight*
        name: AtMidnight
        nameWithType: LocalDate.AtMidnight
        qualifiedName: NodaTime.LocalDate.AtMidnight
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.AtMidnight
  NodaTime.LocalDate.FromWeekYearWeekAndDay*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.FromWeekYearWeekAndDay*
        name: FromWeekYearWeekAndDay
        nameWithType: LocalDate.FromWeekYearWeekAndDay
        qualifiedName: NodaTime.LocalDate.FromWeekYearWeekAndDay
      VB:
      - id: NodaTime.LocalDate.FromWeekYearWeekAndDay*
        name: FromWeekYearWeekAndDay
        nameWithType: LocalDate.FromWeekYearWeekAndDay
        qualifiedName: NodaTime.LocalDate.FromWeekYearWeekAndDay
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.FromWeekYearWeekAndDay
  NodaTime.LocalDate.op_Addition*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.op_Addition*
        name: Addition
        nameWithType: LocalDate.Addition
        qualifiedName: NodaTime.LocalDate.Addition
      VB:
      - id: NodaTime.LocalDate.op_Addition*
        name: Addition
        nameWithType: LocalDate.Addition
        qualifiedName: NodaTime.LocalDate.Addition
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.op_Addition
  NodaTime.LocalDate.Add*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Add*
        name: Add
        nameWithType: LocalDate.Add
        qualifiedName: NodaTime.LocalDate.Add
      VB:
      - id: NodaTime.LocalDate.Add*
        name: Add
        nameWithType: LocalDate.Add
        qualifiedName: NodaTime.LocalDate.Add
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Add
  NodaTime.LocalDate.Plus*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Plus*
        name: Plus
        nameWithType: LocalDate.Plus
        qualifiedName: NodaTime.LocalDate.Plus
      VB:
      - id: NodaTime.LocalDate.Plus*
        name: Plus
        nameWithType: LocalDate.Plus
        qualifiedName: NodaTime.LocalDate.Plus
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Plus
  NodaTime.LocalDate.op_Subtraction*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.op_Subtraction*
        name: Subtraction
        nameWithType: LocalDate.Subtraction
        qualifiedName: NodaTime.LocalDate.Subtraction
      VB:
      - id: NodaTime.LocalDate.op_Subtraction*
        name: Subtraction
        nameWithType: LocalDate.Subtraction
        qualifiedName: NodaTime.LocalDate.Subtraction
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.op_Subtraction
  NodaTime.LocalDate.Subtract*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Subtract*
        name: Subtract
        nameWithType: LocalDate.Subtract
        qualifiedName: NodaTime.LocalDate.Subtract
      VB:
      - id: NodaTime.LocalDate.Subtract*
        name: Subtract
        nameWithType: LocalDate.Subtract
        qualifiedName: NodaTime.LocalDate.Subtract
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Subtract
  NodaTime.LocalDate.Minus*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Minus*
        name: Minus
        nameWithType: LocalDate.Minus
        qualifiedName: NodaTime.LocalDate.Minus
      VB:
      - id: NodaTime.LocalDate.Minus*
        name: Minus
        nameWithType: LocalDate.Minus
        qualifiedName: NodaTime.LocalDate.Minus
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Minus
  NodaTime.LocalDate.op_Equality*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.op_Equality*
        name: Equality
        nameWithType: LocalDate.Equality
        qualifiedName: NodaTime.LocalDate.Equality
      VB:
      - id: NodaTime.LocalDate.op_Equality*
        name: Equality
        nameWithType: LocalDate.Equality
        qualifiedName: NodaTime.LocalDate.Equality
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.op_Equality
  NodaTime.LocalDate.op_Inequality*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.op_Inequality*
        name: Inequality
        nameWithType: LocalDate.Inequality
        qualifiedName: NodaTime.LocalDate.Inequality
      VB:
      - id: NodaTime.LocalDate.op_Inequality*
        name: Inequality
        nameWithType: LocalDate.Inequality
        qualifiedName: NodaTime.LocalDate.Inequality
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.op_Inequality
  NodaTime.LocalDate.op_LessThan*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.op_LessThan*
        name: LessThan
        nameWithType: LocalDate.LessThan
        qualifiedName: NodaTime.LocalDate.LessThan
      VB:
      - id: NodaTime.LocalDate.op_LessThan*
        name: LessThan
        nameWithType: LocalDate.LessThan
        qualifiedName: NodaTime.LocalDate.LessThan
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.op_LessThan
  NodaTime.LocalDate.op_LessThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: LocalDate.LessThanOrEqual
        qualifiedName: NodaTime.LocalDate.LessThanOrEqual
      VB:
      - id: NodaTime.LocalDate.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: LocalDate.LessThanOrEqual
        qualifiedName: NodaTime.LocalDate.LessThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.op_LessThanOrEqual
  NodaTime.LocalDate.op_GreaterThan*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.op_GreaterThan*
        name: GreaterThan
        nameWithType: LocalDate.GreaterThan
        qualifiedName: NodaTime.LocalDate.GreaterThan
      VB:
      - id: NodaTime.LocalDate.op_GreaterThan*
        name: GreaterThan
        nameWithType: LocalDate.GreaterThan
        qualifiedName: NodaTime.LocalDate.GreaterThan
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.op_GreaterThan
  NodaTime.LocalDate.op_GreaterThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: LocalDate.GreaterThanOrEqual
        qualifiedName: NodaTime.LocalDate.GreaterThanOrEqual
      VB:
      - id: NodaTime.LocalDate.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: LocalDate.GreaterThanOrEqual
        qualifiedName: NodaTime.LocalDate.GreaterThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.op_GreaterThanOrEqual
  NodaTime.LocalDate.CompareTo*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.CompareTo*
        name: CompareTo
        nameWithType: LocalDate.CompareTo
        qualifiedName: NodaTime.LocalDate.CompareTo
      VB:
      - id: NodaTime.LocalDate.CompareTo*
        name: CompareTo
        nameWithType: LocalDate.CompareTo
        qualifiedName: NodaTime.LocalDate.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.CompareTo
  System.IComparable`1.CompareTo(`0):
    name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<T>.CompareTo
        qualifiedName: System.IComparable<T>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of T).CompareTo
        qualifiedName: System.IComparable(Of T).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.IComparable`1.CompareTo(`0)
  System.IComparable{NodaTime.LocalDate}.CompareTo(NodaTime.LocalDate):
    name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<LocalDate>.CompareTo
        qualifiedName: System.IComparable<NodaTime.LocalDate>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of LocalDate).CompareTo
        qualifiedName: System.IComparable(Of NodaTime.LocalDate).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1.CompareTo(`0)
    parent: System.IComparable{NodaTime.LocalDate}
    commentId: M:System.IComparable{NodaTime.LocalDate}.CompareTo(NodaTime.LocalDate)
  System.IComparable.CompareTo(System.Object):
    name:
      CSharp:
      - id: System.IComparable.CompareTo(System.Object)
        name: CompareTo
        nameWithType: IComparable.CompareTo
        qualifiedName: System.IComparable.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable.CompareTo(System.Object)
        name: CompareTo
        nameWithType: IComparable.CompareTo
        qualifiedName: System.IComparable.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.IComparable
    commentId: M:System.IComparable.CompareTo(System.Object)
  NodaTime.LocalDate.System#IComparable#CompareTo*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.System#IComparable#CompareTo*
        name: IComparable.CompareTo
        nameWithType: LocalDate.IComparable.CompareTo
        qualifiedName: NodaTime.LocalDate.System.IComparable.CompareTo
      VB:
      - id: NodaTime.LocalDate.System#IComparable#CompareTo*
        name: System.IComparable.CompareTo
        nameWithType: LocalDate.System.IComparable.CompareTo
        qualifiedName: NodaTime.LocalDate.System.IComparable.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.System#IComparable#CompareTo
  NodaTime.LocalDate.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.GetHashCode*
        name: GetHashCode
        nameWithType: LocalDate.GetHashCode
        qualifiedName: NodaTime.LocalDate.GetHashCode
      VB:
      - id: NodaTime.LocalDate.GetHashCode*
        name: GetHashCode
        nameWithType: LocalDate.GetHashCode
        qualifiedName: NodaTime.LocalDate.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.GetHashCode
  NodaTime.LocalDate.Equals*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Equals*
        name: Equals
        nameWithType: LocalDate.Equals
        qualifiedName: NodaTime.LocalDate.Equals
      VB:
      - id: NodaTime.LocalDate.Equals*
        name: Equals
        nameWithType: LocalDate.Equals
        qualifiedName: NodaTime.LocalDate.Equals
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Equals
  System.IEquatable{NodaTime.LocalDate}.Equals(NodaTime.LocalDate):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<LocalDate>.Equals
        qualifiedName: System.IEquatable<NodaTime.LocalDate>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of LocalDate).Equals
        qualifiedName: System.IEquatable(Of NodaTime.LocalDate).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.LocalDate}
    commentId: M:System.IEquatable{NodaTime.LocalDate}.Equals(NodaTime.LocalDate)
  NodaTime.LocalDate.WithCalendar*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.WithCalendar*
        name: WithCalendar
        nameWithType: LocalDate.WithCalendar
        qualifiedName: NodaTime.LocalDate.WithCalendar
      VB:
      - id: NodaTime.LocalDate.WithCalendar*
        name: WithCalendar
        nameWithType: LocalDate.WithCalendar
        qualifiedName: NodaTime.LocalDate.WithCalendar
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.WithCalendar
  NodaTime.LocalDate.PlusYears*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.PlusYears*
        name: PlusYears
        nameWithType: LocalDate.PlusYears
        qualifiedName: NodaTime.LocalDate.PlusYears
      VB:
      - id: NodaTime.LocalDate.PlusYears*
        name: PlusYears
        nameWithType: LocalDate.PlusYears
        qualifiedName: NodaTime.LocalDate.PlusYears
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.PlusYears
  NodaTime.LocalDate.PlusMonths*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.PlusMonths*
        name: PlusMonths
        nameWithType: LocalDate.PlusMonths
        qualifiedName: NodaTime.LocalDate.PlusMonths
      VB:
      - id: NodaTime.LocalDate.PlusMonths*
        name: PlusMonths
        nameWithType: LocalDate.PlusMonths
        qualifiedName: NodaTime.LocalDate.PlusMonths
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.PlusMonths
  NodaTime.LocalDate.PlusDays*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.PlusDays*
        name: PlusDays
        nameWithType: LocalDate.PlusDays
        qualifiedName: NodaTime.LocalDate.PlusDays
      VB:
      - id: NodaTime.LocalDate.PlusDays*
        name: PlusDays
        nameWithType: LocalDate.PlusDays
        qualifiedName: NodaTime.LocalDate.PlusDays
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.PlusDays
  NodaTime.LocalDate.PlusWeeks*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.PlusWeeks*
        name: PlusWeeks
        nameWithType: LocalDate.PlusWeeks
        qualifiedName: NodaTime.LocalDate.PlusWeeks
      VB:
      - id: NodaTime.LocalDate.PlusWeeks*
        name: PlusWeeks
        nameWithType: LocalDate.PlusWeeks
        qualifiedName: NodaTime.LocalDate.PlusWeeks
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.PlusWeeks
  NodaTime.LocalDate.Next*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Next*
        name: Next
        nameWithType: LocalDate.Next
        qualifiedName: NodaTime.LocalDate.Next
      VB:
      - id: NodaTime.LocalDate.Next*
        name: Next
        nameWithType: LocalDate.Next
        qualifiedName: NodaTime.LocalDate.Next
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Next
  NodaTime.LocalDate.Previous*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.Previous*
        name: Previous
        nameWithType: LocalDate.Previous
        qualifiedName: NodaTime.LocalDate.Previous
      VB:
      - id: NodaTime.LocalDate.Previous*
        name: Previous
        nameWithType: LocalDate.Previous
        qualifiedName: NodaTime.LocalDate.Previous
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.Previous
  NodaTime.LocalDate.ToString*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.ToString*
        name: ToString
        nameWithType: LocalDate.ToString
        qualifiedName: NodaTime.LocalDate.ToString
      VB:
      - id: NodaTime.LocalDate.ToString*
        name: ToString
        nameWithType: LocalDate.ToString
        qualifiedName: NodaTime.LocalDate.ToString
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.ToString
  NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#GetSchema*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: IXmlSerializable.GetSchema
        nameWithType: LocalDate.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.GetSchema
      VB:
      - id: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: System.Xml.Serialization.IXmlSerializable.GetSchema
        nameWithType: LocalDate.System.Xml.Serialization.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.GetSchema
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#GetSchema
  NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#ReadXml*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: IXmlSerializable.ReadXml
        nameWithType: LocalDate.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.ReadXml
      VB:
      - id: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: System.Xml.Serialization.IXmlSerializable.ReadXml
        nameWithType: LocalDate.System.Xml.Serialization.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.ReadXml
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#ReadXml
  NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#WriteXml*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: IXmlSerializable.WriteXml
        nameWithType: LocalDate.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.WriteXml
      VB:
      - id: NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: System.Xml.Serialization.IXmlSerializable.WriteXml
        nameWithType: LocalDate.System.Xml.Serialization.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.LocalDate.System.Xml.Serialization.IXmlSerializable.WriteXml
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#WriteXml
  NodaTime.LocalDate.System#Runtime#Serialization#ISerializable#GetObjectData*:
    name:
      CSharp:
      - id: NodaTime.LocalDate.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: ISerializable.GetObjectData
        nameWithType: LocalDate.ISerializable.GetObjectData
        qualifiedName: NodaTime.LocalDate.System.Runtime.Serialization.ISerializable.GetObjectData
      VB:
      - id: NodaTime.LocalDate.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: System.Runtime.Serialization.ISerializable.GetObjectData
        nameWithType: LocalDate.System.Runtime.Serialization.ISerializable.GetObjectData
        qualifiedName: NodaTime.LocalDate.System.Runtime.Serialization.ISerializable.GetObjectData
    isDefinition: true
    commentId: Overload:NodaTime.LocalDate.System#Runtime#Serialization#ISerializable#GetObjectData
  System.IEquatable{NodaTime.LocalTime}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.LocalTime}
  System.IComparable{NodaTime.LocalTime}:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1
    parent: System
    commentId: T:System.IComparable{NodaTime.LocalTime}
  NodaTime.LocalTime.#ctor*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.#ctor*
        name: LocalTime
        nameWithType: LocalTime.LocalTime
        qualifiedName: NodaTime.LocalTime.LocalTime
      VB:
      - id: NodaTime.LocalTime.#ctor*
        name: LocalTime
        nameWithType: LocalTime.LocalTime
        qualifiedName: NodaTime.LocalTime.LocalTime
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.#ctor
  NodaTime.LocalTime.FromHourMinuteSecondTick*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.FromHourMinuteSecondTick*
        name: FromHourMinuteSecondTick
        nameWithType: LocalTime.FromHourMinuteSecondTick
        qualifiedName: NodaTime.LocalTime.FromHourMinuteSecondTick
      VB:
      - id: NodaTime.LocalTime.FromHourMinuteSecondTick*
        name: FromHourMinuteSecondTick
        nameWithType: LocalTime.FromHourMinuteSecondTick
        qualifiedName: NodaTime.LocalTime.FromHourMinuteSecondTick
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.FromHourMinuteSecondTick
  NodaTime.LocalTime.FromTicksSinceMidnight*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.FromTicksSinceMidnight*
        name: FromTicksSinceMidnight
        nameWithType: LocalTime.FromTicksSinceMidnight
        qualifiedName: NodaTime.LocalTime.FromTicksSinceMidnight
      VB:
      - id: NodaTime.LocalTime.FromTicksSinceMidnight*
        name: FromTicksSinceMidnight
        nameWithType: LocalTime.FromTicksSinceMidnight
        qualifiedName: NodaTime.LocalTime.FromTicksSinceMidnight
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.FromTicksSinceMidnight
  NodaTime.LocalTime.FromMillisecondsSinceMidnight*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.FromMillisecondsSinceMidnight*
        name: FromMillisecondsSinceMidnight
        nameWithType: LocalTime.FromMillisecondsSinceMidnight
        qualifiedName: NodaTime.LocalTime.FromMillisecondsSinceMidnight
      VB:
      - id: NodaTime.LocalTime.FromMillisecondsSinceMidnight*
        name: FromMillisecondsSinceMidnight
        nameWithType: LocalTime.FromMillisecondsSinceMidnight
        qualifiedName: NodaTime.LocalTime.FromMillisecondsSinceMidnight
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.FromMillisecondsSinceMidnight
  NodaTime.LocalTime.FromSecondsSinceMidnight*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.FromSecondsSinceMidnight*
        name: FromSecondsSinceMidnight
        nameWithType: LocalTime.FromSecondsSinceMidnight
        qualifiedName: NodaTime.LocalTime.FromSecondsSinceMidnight
      VB:
      - id: NodaTime.LocalTime.FromSecondsSinceMidnight*
        name: FromSecondsSinceMidnight
        nameWithType: LocalTime.FromSecondsSinceMidnight
        qualifiedName: NodaTime.LocalTime.FromSecondsSinceMidnight
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.FromSecondsSinceMidnight
  NodaTime.LocalTime.Hour*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.Hour*
        name: Hour
        nameWithType: LocalTime.Hour
        qualifiedName: NodaTime.LocalTime.Hour
      VB:
      - id: NodaTime.LocalTime.Hour*
        name: Hour
        nameWithType: LocalTime.Hour
        qualifiedName: NodaTime.LocalTime.Hour
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.Hour
  NodaTime.LocalTime.ClockHourOfHalfDay*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.ClockHourOfHalfDay*
        name: ClockHourOfHalfDay
        nameWithType: LocalTime.ClockHourOfHalfDay
        qualifiedName: NodaTime.LocalTime.ClockHourOfHalfDay
      VB:
      - id: NodaTime.LocalTime.ClockHourOfHalfDay*
        name: ClockHourOfHalfDay
        nameWithType: LocalTime.ClockHourOfHalfDay
        qualifiedName: NodaTime.LocalTime.ClockHourOfHalfDay
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.ClockHourOfHalfDay
  NodaTime.LocalTime.Minute*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.Minute*
        name: Minute
        nameWithType: LocalTime.Minute
        qualifiedName: NodaTime.LocalTime.Minute
      VB:
      - id: NodaTime.LocalTime.Minute*
        name: Minute
        nameWithType: LocalTime.Minute
        qualifiedName: NodaTime.LocalTime.Minute
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.Minute
  NodaTime.LocalTime.Second*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.Second*
        name: Second
        nameWithType: LocalTime.Second
        qualifiedName: NodaTime.LocalTime.Second
      VB:
      - id: NodaTime.LocalTime.Second*
        name: Second
        nameWithType: LocalTime.Second
        qualifiedName: NodaTime.LocalTime.Second
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.Second
  NodaTime.LocalTime.Millisecond*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.Millisecond*
        name: Millisecond
        nameWithType: LocalTime.Millisecond
        qualifiedName: NodaTime.LocalTime.Millisecond
      VB:
      - id: NodaTime.LocalTime.Millisecond*
        name: Millisecond
        nameWithType: LocalTime.Millisecond
        qualifiedName: NodaTime.LocalTime.Millisecond
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.Millisecond
  NodaTime.LocalTime.TickOfSecond*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.TickOfSecond*
        name: TickOfSecond
        nameWithType: LocalTime.TickOfSecond
        qualifiedName: NodaTime.LocalTime.TickOfSecond
      VB:
      - id: NodaTime.LocalTime.TickOfSecond*
        name: TickOfSecond
        nameWithType: LocalTime.TickOfSecond
        qualifiedName: NodaTime.LocalTime.TickOfSecond
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.TickOfSecond
  NodaTime.LocalTime.TickOfDay*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.TickOfDay*
        name: TickOfDay
        nameWithType: LocalTime.TickOfDay
        qualifiedName: NodaTime.LocalTime.TickOfDay
      VB:
      - id: NodaTime.LocalTime.TickOfDay*
        name: TickOfDay
        nameWithType: LocalTime.TickOfDay
        qualifiedName: NodaTime.LocalTime.TickOfDay
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.TickOfDay
  NodaTime.LocalTime.LocalDateTime*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.LocalDateTime*
        name: LocalDateTime
        nameWithType: LocalTime.LocalDateTime
        qualifiedName: NodaTime.LocalTime.LocalDateTime
      VB:
      - id: NodaTime.LocalTime.LocalDateTime*
        name: LocalDateTime
        nameWithType: LocalTime.LocalDateTime
        qualifiedName: NodaTime.LocalTime.LocalDateTime
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.LocalDateTime
  NodaTime.LocalTime.op_Addition*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.op_Addition*
        name: Addition
        nameWithType: LocalTime.Addition
        qualifiedName: NodaTime.LocalTime.Addition
      VB:
      - id: NodaTime.LocalTime.op_Addition*
        name: Addition
        nameWithType: LocalTime.Addition
        qualifiedName: NodaTime.LocalTime.Addition
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.op_Addition
  NodaTime.LocalTime.Add*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.Add*
        name: Add
        nameWithType: LocalTime.Add
        qualifiedName: NodaTime.LocalTime.Add
      VB:
      - id: NodaTime.LocalTime.Add*
        name: Add
        nameWithType: LocalTime.Add
        qualifiedName: NodaTime.LocalTime.Add
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.Add
  NodaTime.LocalTime.Plus*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.Plus*
        name: Plus
        nameWithType: LocalTime.Plus
        qualifiedName: NodaTime.LocalTime.Plus
      VB:
      - id: NodaTime.LocalTime.Plus*
        name: Plus
        nameWithType: LocalTime.Plus
        qualifiedName: NodaTime.LocalTime.Plus
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.Plus
  NodaTime.LocalTime.op_Subtraction*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.op_Subtraction*
        name: Subtraction
        nameWithType: LocalTime.Subtraction
        qualifiedName: NodaTime.LocalTime.Subtraction
      VB:
      - id: NodaTime.LocalTime.op_Subtraction*
        name: Subtraction
        nameWithType: LocalTime.Subtraction
        qualifiedName: NodaTime.LocalTime.Subtraction
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.op_Subtraction
  NodaTime.LocalTime.Subtract*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.Subtract*
        name: Subtract
        nameWithType: LocalTime.Subtract
        qualifiedName: NodaTime.LocalTime.Subtract
      VB:
      - id: NodaTime.LocalTime.Subtract*
        name: Subtract
        nameWithType: LocalTime.Subtract
        qualifiedName: NodaTime.LocalTime.Subtract
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.Subtract
  NodaTime.LocalTime.Minus*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.Minus*
        name: Minus
        nameWithType: LocalTime.Minus
        qualifiedName: NodaTime.LocalTime.Minus
      VB:
      - id: NodaTime.LocalTime.Minus*
        name: Minus
        nameWithType: LocalTime.Minus
        qualifiedName: NodaTime.LocalTime.Minus
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.Minus
  NodaTime.LocalTime.op_Equality*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.op_Equality*
        name: Equality
        nameWithType: LocalTime.Equality
        qualifiedName: NodaTime.LocalTime.Equality
      VB:
      - id: NodaTime.LocalTime.op_Equality*
        name: Equality
        nameWithType: LocalTime.Equality
        qualifiedName: NodaTime.LocalTime.Equality
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.op_Equality
  NodaTime.LocalTime.op_Inequality*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.op_Inequality*
        name: Inequality
        nameWithType: LocalTime.Inequality
        qualifiedName: NodaTime.LocalTime.Inequality
      VB:
      - id: NodaTime.LocalTime.op_Inequality*
        name: Inequality
        nameWithType: LocalTime.Inequality
        qualifiedName: NodaTime.LocalTime.Inequality
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.op_Inequality
  NodaTime.LocalTime.op_LessThan*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.op_LessThan*
        name: LessThan
        nameWithType: LocalTime.LessThan
        qualifiedName: NodaTime.LocalTime.LessThan
      VB:
      - id: NodaTime.LocalTime.op_LessThan*
        name: LessThan
        nameWithType: LocalTime.LessThan
        qualifiedName: NodaTime.LocalTime.LessThan
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.op_LessThan
  NodaTime.LocalTime.op_LessThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: LocalTime.LessThanOrEqual
        qualifiedName: NodaTime.LocalTime.LessThanOrEqual
      VB:
      - id: NodaTime.LocalTime.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: LocalTime.LessThanOrEqual
        qualifiedName: NodaTime.LocalTime.LessThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.op_LessThanOrEqual
  NodaTime.LocalTime.op_GreaterThan*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.op_GreaterThan*
        name: GreaterThan
        nameWithType: LocalTime.GreaterThan
        qualifiedName: NodaTime.LocalTime.GreaterThan
      VB:
      - id: NodaTime.LocalTime.op_GreaterThan*
        name: GreaterThan
        nameWithType: LocalTime.GreaterThan
        qualifiedName: NodaTime.LocalTime.GreaterThan
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.op_GreaterThan
  NodaTime.LocalTime.op_GreaterThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: LocalTime.GreaterThanOrEqual
        qualifiedName: NodaTime.LocalTime.GreaterThanOrEqual
      VB:
      - id: NodaTime.LocalTime.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: LocalTime.GreaterThanOrEqual
        qualifiedName: NodaTime.LocalTime.GreaterThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.op_GreaterThanOrEqual
  NodaTime.LocalTime.CompareTo*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.CompareTo*
        name: CompareTo
        nameWithType: LocalTime.CompareTo
        qualifiedName: NodaTime.LocalTime.CompareTo
      VB:
      - id: NodaTime.LocalTime.CompareTo*
        name: CompareTo
        nameWithType: LocalTime.CompareTo
        qualifiedName: NodaTime.LocalTime.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.CompareTo
  System.IComparable{NodaTime.LocalTime}.CompareTo(NodaTime.LocalTime):
    name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<LocalTime>.CompareTo
        qualifiedName: System.IComparable<NodaTime.LocalTime>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of LocalTime).CompareTo
        qualifiedName: System.IComparable(Of NodaTime.LocalTime).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1.CompareTo(`0)
    parent: System.IComparable{NodaTime.LocalTime}
    commentId: M:System.IComparable{NodaTime.LocalTime}.CompareTo(NodaTime.LocalTime)
  NodaTime.LocalTime.CompareTo(NodaTime.LocalTime):
    commentId: M:NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)
  NodaTime.LocalTime.System#IComparable#CompareTo*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.System#IComparable#CompareTo*
        name: IComparable.CompareTo
        nameWithType: LocalTime.IComparable.CompareTo
        qualifiedName: NodaTime.LocalTime.System.IComparable.CompareTo
      VB:
      - id: NodaTime.LocalTime.System#IComparable#CompareTo*
        name: System.IComparable.CompareTo
        nameWithType: LocalTime.System.IComparable.CompareTo
        qualifiedName: NodaTime.LocalTime.System.IComparable.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.System#IComparable#CompareTo
  NodaTime.LocalTime.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.GetHashCode*
        name: GetHashCode
        nameWithType: LocalTime.GetHashCode
        qualifiedName: NodaTime.LocalTime.GetHashCode
      VB:
      - id: NodaTime.LocalTime.GetHashCode*
        name: GetHashCode
        nameWithType: LocalTime.GetHashCode
        qualifiedName: NodaTime.LocalTime.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.GetHashCode
  NodaTime.LocalTime.Equals*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.Equals*
        name: Equals
        nameWithType: LocalTime.Equals
        qualifiedName: NodaTime.LocalTime.Equals
      VB:
      - id: NodaTime.LocalTime.Equals*
        name: Equals
        nameWithType: LocalTime.Equals
        qualifiedName: NodaTime.LocalTime.Equals
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.Equals
  System.IEquatable{NodaTime.LocalTime}.Equals(NodaTime.LocalTime):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<LocalTime>.Equals
        qualifiedName: System.IEquatable<NodaTime.LocalTime>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of LocalTime).Equals
        qualifiedName: System.IEquatable(Of NodaTime.LocalTime).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.LocalTime}
    commentId: M:System.IEquatable{NodaTime.LocalTime}.Equals(NodaTime.LocalTime)
  NodaTime.LocalTime.PlusHours*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.PlusHours*
        name: PlusHours
        nameWithType: LocalTime.PlusHours
        qualifiedName: NodaTime.LocalTime.PlusHours
      VB:
      - id: NodaTime.LocalTime.PlusHours*
        name: PlusHours
        nameWithType: LocalTime.PlusHours
        qualifiedName: NodaTime.LocalTime.PlusHours
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.PlusHours
  NodaTime.LocalTime.PlusMinutes*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.PlusMinutes*
        name: PlusMinutes
        nameWithType: LocalTime.PlusMinutes
        qualifiedName: NodaTime.LocalTime.PlusMinutes
      VB:
      - id: NodaTime.LocalTime.PlusMinutes*
        name: PlusMinutes
        nameWithType: LocalTime.PlusMinutes
        qualifiedName: NodaTime.LocalTime.PlusMinutes
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.PlusMinutes
  NodaTime.LocalTime.PlusSeconds*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.PlusSeconds*
        name: PlusSeconds
        nameWithType: LocalTime.PlusSeconds
        qualifiedName: NodaTime.LocalTime.PlusSeconds
      VB:
      - id: NodaTime.LocalTime.PlusSeconds*
        name: PlusSeconds
        nameWithType: LocalTime.PlusSeconds
        qualifiedName: NodaTime.LocalTime.PlusSeconds
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.PlusSeconds
  NodaTime.LocalTime.PlusMilliseconds*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.PlusMilliseconds*
        name: PlusMilliseconds
        nameWithType: LocalTime.PlusMilliseconds
        qualifiedName: NodaTime.LocalTime.PlusMilliseconds
      VB:
      - id: NodaTime.LocalTime.PlusMilliseconds*
        name: PlusMilliseconds
        nameWithType: LocalTime.PlusMilliseconds
        qualifiedName: NodaTime.LocalTime.PlusMilliseconds
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.PlusMilliseconds
  NodaTime.LocalTime.PlusTicks*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.PlusTicks*
        name: PlusTicks
        nameWithType: LocalTime.PlusTicks
        qualifiedName: NodaTime.LocalTime.PlusTicks
      VB:
      - id: NodaTime.LocalTime.PlusTicks*
        name: PlusTicks
        nameWithType: LocalTime.PlusTicks
        qualifiedName: NodaTime.LocalTime.PlusTicks
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.PlusTicks
  NodaTime.LocalTime.ToString*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.ToString*
        name: ToString
        nameWithType: LocalTime.ToString
        qualifiedName: NodaTime.LocalTime.ToString
      VB:
      - id: NodaTime.LocalTime.ToString*
        name: ToString
        nameWithType: LocalTime.ToString
        qualifiedName: NodaTime.LocalTime.ToString
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.ToString
  NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#GetSchema*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: IXmlSerializable.GetSchema
        nameWithType: LocalTime.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.GetSchema
      VB:
      - id: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: System.Xml.Serialization.IXmlSerializable.GetSchema
        nameWithType: LocalTime.System.Xml.Serialization.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.GetSchema
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#GetSchema
  NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#ReadXml*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: IXmlSerializable.ReadXml
        nameWithType: LocalTime.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.ReadXml
      VB:
      - id: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: System.Xml.Serialization.IXmlSerializable.ReadXml
        nameWithType: LocalTime.System.Xml.Serialization.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.ReadXml
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#ReadXml
  NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#WriteXml*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: IXmlSerializable.WriteXml
        nameWithType: LocalTime.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.WriteXml
      VB:
      - id: NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: System.Xml.Serialization.IXmlSerializable.WriteXml
        nameWithType: LocalTime.System.Xml.Serialization.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.LocalTime.System.Xml.Serialization.IXmlSerializable.WriteXml
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#WriteXml
  NodaTime.LocalTime.System#Runtime#Serialization#ISerializable#GetObjectData*:
    name:
      CSharp:
      - id: NodaTime.LocalTime.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: ISerializable.GetObjectData
        nameWithType: LocalTime.ISerializable.GetObjectData
        qualifiedName: NodaTime.LocalTime.System.Runtime.Serialization.ISerializable.GetObjectData
      VB:
      - id: NodaTime.LocalTime.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: System.Runtime.Serialization.ISerializable.GetObjectData
        nameWithType: LocalTime.System.Runtime.Serialization.ISerializable.GetObjectData
        qualifiedName: NodaTime.LocalTime.System.Runtime.Serialization.ISerializable.GetObjectData
    isDefinition: true
    commentId: Overload:NodaTime.LocalTime.System#Runtime#Serialization#ISerializable#GetObjectData
  System.IEquatable{NodaTime.Offset}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.Offset}
  System.IComparable{NodaTime.Offset}:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1
    parent: System
    commentId: T:System.IComparable{NodaTime.Offset}
  NodaTime.Offset.Milliseconds*:
    name:
      CSharp:
      - id: NodaTime.Offset.Milliseconds*
        name: Milliseconds
        nameWithType: Offset.Milliseconds
        qualifiedName: NodaTime.Offset.Milliseconds
      VB:
      - id: NodaTime.Offset.Milliseconds*
        name: Milliseconds
        nameWithType: Offset.Milliseconds
        qualifiedName: NodaTime.Offset.Milliseconds
    isDefinition: true
    commentId: Overload:NodaTime.Offset.Milliseconds
  NodaTime.Offset.Ticks*:
    name:
      CSharp:
      - id: NodaTime.Offset.Ticks*
        name: Ticks
        nameWithType: Offset.Ticks
        qualifiedName: NodaTime.Offset.Ticks
      VB:
      - id: NodaTime.Offset.Ticks*
        name: Ticks
        nameWithType: Offset.Ticks
        qualifiedName: NodaTime.Offset.Ticks
    isDefinition: true
    commentId: Overload:NodaTime.Offset.Ticks
  NodaTime.Offset.Max*:
    name:
      CSharp:
      - id: NodaTime.Offset.Max*
        name: Max
        nameWithType: Offset.Max
        qualifiedName: NodaTime.Offset.Max
      VB:
      - id: NodaTime.Offset.Max*
        name: Max
        nameWithType: Offset.Max
        qualifiedName: NodaTime.Offset.Max
    isDefinition: true
    commentId: Overload:NodaTime.Offset.Max
  NodaTime.Offset.Min*:
    name:
      CSharp:
      - id: NodaTime.Offset.Min*
        name: Min
        nameWithType: Offset.Min
        qualifiedName: NodaTime.Offset.Min
      VB:
      - id: NodaTime.Offset.Min*
        name: Min
        nameWithType: Offset.Min
        qualifiedName: NodaTime.Offset.Min
    isDefinition: true
    commentId: Overload:NodaTime.Offset.Min
  NodaTime.Offset.op_UnaryNegation*:
    name:
      CSharp:
      - id: NodaTime.Offset.op_UnaryNegation*
        name: UnaryNegation
        nameWithType: Offset.UnaryNegation
        qualifiedName: NodaTime.Offset.UnaryNegation
      VB:
      - id: NodaTime.Offset.op_UnaryNegation*
        name: UnaryNegation
        nameWithType: Offset.UnaryNegation
        qualifiedName: NodaTime.Offset.UnaryNegation
    isDefinition: true
    commentId: Overload:NodaTime.Offset.op_UnaryNegation
  NodaTime.Offset.Negate*:
    name:
      CSharp:
      - id: NodaTime.Offset.Negate*
        name: Negate
        nameWithType: Offset.Negate
        qualifiedName: NodaTime.Offset.Negate
      VB:
      - id: NodaTime.Offset.Negate*
        name: Negate
        nameWithType: Offset.Negate
        qualifiedName: NodaTime.Offset.Negate
    isDefinition: true
    commentId: Overload:NodaTime.Offset.Negate
  NodaTime.Offset.Plus(NodaTime.Offset):
    commentId: M:NodaTime.Offset.Plus(NodaTime.Offset)
  NodaTime.Offset.op_UnaryPlus*:
    name:
      CSharp:
      - id: NodaTime.Offset.op_UnaryPlus*
        name: UnaryPlus
        nameWithType: Offset.UnaryPlus
        qualifiedName: NodaTime.Offset.UnaryPlus
      VB:
      - id: NodaTime.Offset.op_UnaryPlus*
        name: UnaryPlus
        nameWithType: Offset.UnaryPlus
        qualifiedName: NodaTime.Offset.UnaryPlus
    isDefinition: true
    commentId: Overload:NodaTime.Offset.op_UnaryPlus
  NodaTime.Offset.op_Addition*:
    name:
      CSharp:
      - id: NodaTime.Offset.op_Addition*
        name: Addition
        nameWithType: Offset.Addition
        qualifiedName: NodaTime.Offset.Addition
      VB:
      - id: NodaTime.Offset.op_Addition*
        name: Addition
        nameWithType: Offset.Addition
        qualifiedName: NodaTime.Offset.Addition
    isDefinition: true
    commentId: Overload:NodaTime.Offset.op_Addition
  NodaTime.Offset.Add*:
    name:
      CSharp:
      - id: NodaTime.Offset.Add*
        name: Add
        nameWithType: Offset.Add
        qualifiedName: NodaTime.Offset.Add
      VB:
      - id: NodaTime.Offset.Add*
        name: Add
        nameWithType: Offset.Add
        qualifiedName: NodaTime.Offset.Add
    isDefinition: true
    commentId: Overload:NodaTime.Offset.Add
  NodaTime.Offset.Plus*:
    name:
      CSharp:
      - id: NodaTime.Offset.Plus*
        name: Plus
        nameWithType: Offset.Plus
        qualifiedName: NodaTime.Offset.Plus
      VB:
      - id: NodaTime.Offset.Plus*
        name: Plus
        nameWithType: Offset.Plus
        qualifiedName: NodaTime.Offset.Plus
    isDefinition: true
    commentId: Overload:NodaTime.Offset.Plus
  NodaTime.Offset.op_Subtraction*:
    name:
      CSharp:
      - id: NodaTime.Offset.op_Subtraction*
        name: Subtraction
        nameWithType: Offset.Subtraction
        qualifiedName: NodaTime.Offset.Subtraction
      VB:
      - id: NodaTime.Offset.op_Subtraction*
        name: Subtraction
        nameWithType: Offset.Subtraction
        qualifiedName: NodaTime.Offset.Subtraction
    isDefinition: true
    commentId: Overload:NodaTime.Offset.op_Subtraction
  NodaTime.Offset.Subtract*:
    name:
      CSharp:
      - id: NodaTime.Offset.Subtract*
        name: Subtract
        nameWithType: Offset.Subtract
        qualifiedName: NodaTime.Offset.Subtract
      VB:
      - id: NodaTime.Offset.Subtract*
        name: Subtract
        nameWithType: Offset.Subtract
        qualifiedName: NodaTime.Offset.Subtract
    isDefinition: true
    commentId: Overload:NodaTime.Offset.Subtract
  NodaTime.Offset.Minus*:
    name:
      CSharp:
      - id: NodaTime.Offset.Minus*
        name: Minus
        nameWithType: Offset.Minus
        qualifiedName: NodaTime.Offset.Minus
      VB:
      - id: NodaTime.Offset.Minus*
        name: Minus
        nameWithType: Offset.Minus
        qualifiedName: NodaTime.Offset.Minus
    isDefinition: true
    commentId: Overload:NodaTime.Offset.Minus
  NodaTime.Offset.op_Equality*:
    name:
      CSharp:
      - id: NodaTime.Offset.op_Equality*
        name: Equality
        nameWithType: Offset.Equality
        qualifiedName: NodaTime.Offset.Equality
      VB:
      - id: NodaTime.Offset.op_Equality*
        name: Equality
        nameWithType: Offset.Equality
        qualifiedName: NodaTime.Offset.Equality
    isDefinition: true
    commentId: Overload:NodaTime.Offset.op_Equality
  NodaTime.Offset.op_Inequality*:
    name:
      CSharp:
      - id: NodaTime.Offset.op_Inequality*
        name: Inequality
        nameWithType: Offset.Inequality
        qualifiedName: NodaTime.Offset.Inequality
      VB:
      - id: NodaTime.Offset.op_Inequality*
        name: Inequality
        nameWithType: Offset.Inequality
        qualifiedName: NodaTime.Offset.Inequality
    isDefinition: true
    commentId: Overload:NodaTime.Offset.op_Inequality
  NodaTime.Offset.op_LessThan*:
    name:
      CSharp:
      - id: NodaTime.Offset.op_LessThan*
        name: LessThan
        nameWithType: Offset.LessThan
        qualifiedName: NodaTime.Offset.LessThan
      VB:
      - id: NodaTime.Offset.op_LessThan*
        name: LessThan
        nameWithType: Offset.LessThan
        qualifiedName: NodaTime.Offset.LessThan
    isDefinition: true
    commentId: Overload:NodaTime.Offset.op_LessThan
  NodaTime.Offset.op_LessThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.Offset.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: Offset.LessThanOrEqual
        qualifiedName: NodaTime.Offset.LessThanOrEqual
      VB:
      - id: NodaTime.Offset.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: Offset.LessThanOrEqual
        qualifiedName: NodaTime.Offset.LessThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.Offset.op_LessThanOrEqual
  NodaTime.Offset.op_GreaterThan*:
    name:
      CSharp:
      - id: NodaTime.Offset.op_GreaterThan*
        name: GreaterThan
        nameWithType: Offset.GreaterThan
        qualifiedName: NodaTime.Offset.GreaterThan
      VB:
      - id: NodaTime.Offset.op_GreaterThan*
        name: GreaterThan
        nameWithType: Offset.GreaterThan
        qualifiedName: NodaTime.Offset.GreaterThan
    isDefinition: true
    commentId: Overload:NodaTime.Offset.op_GreaterThan
  NodaTime.Offset.op_GreaterThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.Offset.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: Offset.GreaterThanOrEqual
        qualifiedName: NodaTime.Offset.GreaterThanOrEqual
      VB:
      - id: NodaTime.Offset.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: Offset.GreaterThanOrEqual
        qualifiedName: NodaTime.Offset.GreaterThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.Offset.op_GreaterThanOrEqual
  NodaTime.Offset.CompareTo*:
    name:
      CSharp:
      - id: NodaTime.Offset.CompareTo*
        name: CompareTo
        nameWithType: Offset.CompareTo
        qualifiedName: NodaTime.Offset.CompareTo
      VB:
      - id: NodaTime.Offset.CompareTo*
        name: CompareTo
        nameWithType: Offset.CompareTo
        qualifiedName: NodaTime.Offset.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.Offset.CompareTo
  System.IComparable{NodaTime.Offset}.CompareTo(NodaTime.Offset):
    name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<Offset>.CompareTo
        qualifiedName: System.IComparable<NodaTime.Offset>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of Offset).CompareTo
        qualifiedName: System.IComparable(Of NodaTime.Offset).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1.CompareTo(`0)
    parent: System.IComparable{NodaTime.Offset}
    commentId: M:System.IComparable{NodaTime.Offset}.CompareTo(NodaTime.Offset)
  NodaTime.Offset.CompareTo(NodaTime.Offset):
    commentId: M:NodaTime.Offset.CompareTo(NodaTime.Offset)
  NodaTime.Offset.System#IComparable#CompareTo*:
    name:
      CSharp:
      - id: NodaTime.Offset.System#IComparable#CompareTo*
        name: IComparable.CompareTo
        nameWithType: Offset.IComparable.CompareTo
        qualifiedName: NodaTime.Offset.System.IComparable.CompareTo
      VB:
      - id: NodaTime.Offset.System#IComparable#CompareTo*
        name: System.IComparable.CompareTo
        nameWithType: Offset.System.IComparable.CompareTo
        qualifiedName: NodaTime.Offset.System.IComparable.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.Offset.System#IComparable#CompareTo
  NodaTime.Offset.Equals*:
    name:
      CSharp:
      - id: NodaTime.Offset.Equals*
        name: Equals
        nameWithType: Offset.Equals
        qualifiedName: NodaTime.Offset.Equals
      VB:
      - id: NodaTime.Offset.Equals*
        name: Equals
        nameWithType: Offset.Equals
        qualifiedName: NodaTime.Offset.Equals
    isDefinition: true
    commentId: Overload:NodaTime.Offset.Equals
  System.IEquatable{NodaTime.Offset}.Equals(NodaTime.Offset):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<Offset>.Equals
        qualifiedName: System.IEquatable<NodaTime.Offset>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of Offset).Equals
        qualifiedName: System.IEquatable(Of NodaTime.Offset).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.Offset}
    commentId: M:System.IEquatable{NodaTime.Offset}.Equals(NodaTime.Offset)
  NodaTime.Offset.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.Offset.GetHashCode*
        name: GetHashCode
        nameWithType: Offset.GetHashCode
        qualifiedName: NodaTime.Offset.GetHashCode
      VB:
      - id: NodaTime.Offset.GetHashCode*
        name: GetHashCode
        nameWithType: Offset.GetHashCode
        qualifiedName: NodaTime.Offset.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.Offset.GetHashCode
  NodaTime.Offset.ToString*:
    name:
      CSharp:
      - id: NodaTime.Offset.ToString*
        name: ToString
        nameWithType: Offset.ToString
        qualifiedName: NodaTime.Offset.ToString
      VB:
      - id: NodaTime.Offset.ToString*
        name: ToString
        nameWithType: Offset.ToString
        qualifiedName: NodaTime.Offset.ToString
    isDefinition: true
    commentId: Overload:NodaTime.Offset.ToString
  NodaTime.Offset.FromMilliseconds*:
    name:
      CSharp:
      - id: NodaTime.Offset.FromMilliseconds*
        name: FromMilliseconds
        nameWithType: Offset.FromMilliseconds
        qualifiedName: NodaTime.Offset.FromMilliseconds
      VB:
      - id: NodaTime.Offset.FromMilliseconds*
        name: FromMilliseconds
        nameWithType: Offset.FromMilliseconds
        qualifiedName: NodaTime.Offset.FromMilliseconds
    isDefinition: true
    commentId: Overload:NodaTime.Offset.FromMilliseconds
  NodaTime.Offset.FromTicks*:
    name:
      CSharp:
      - id: NodaTime.Offset.FromTicks*
        name: FromTicks
        nameWithType: Offset.FromTicks
        qualifiedName: NodaTime.Offset.FromTicks
      VB:
      - id: NodaTime.Offset.FromTicks*
        name: FromTicks
        nameWithType: Offset.FromTicks
        qualifiedName: NodaTime.Offset.FromTicks
    isDefinition: true
    commentId: Overload:NodaTime.Offset.FromTicks
  NodaTime.Offset.FromHours*:
    name:
      CSharp:
      - id: NodaTime.Offset.FromHours*
        name: FromHours
        nameWithType: Offset.FromHours
        qualifiedName: NodaTime.Offset.FromHours
      VB:
      - id: NodaTime.Offset.FromHours*
        name: FromHours
        nameWithType: Offset.FromHours
        qualifiedName: NodaTime.Offset.FromHours
    isDefinition: true
    commentId: Overload:NodaTime.Offset.FromHours
  NodaTime.Offset.FromHoursAndMinutes*:
    name:
      CSharp:
      - id: NodaTime.Offset.FromHoursAndMinutes*
        name: FromHoursAndMinutes
        nameWithType: Offset.FromHoursAndMinutes
        qualifiedName: NodaTime.Offset.FromHoursAndMinutes
      VB:
      - id: NodaTime.Offset.FromHoursAndMinutes*
        name: FromHoursAndMinutes
        nameWithType: Offset.FromHoursAndMinutes
        qualifiedName: NodaTime.Offset.FromHoursAndMinutes
    isDefinition: true
    commentId: Overload:NodaTime.Offset.FromHoursAndMinutes
  System.TimeSpan:
    name:
      CSharp:
      - id: System.TimeSpan
        name: TimeSpan
        nameWithType: TimeSpan
        qualifiedName: System.TimeSpan
        isExternal: true
      VB:
      - id: System.TimeSpan
        name: TimeSpan
        nameWithType: TimeSpan
        qualifiedName: System.TimeSpan
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.TimeSpan
  NodaTime.Offset.ToTimeSpan*:
    name:
      CSharp:
      - id: NodaTime.Offset.ToTimeSpan*
        name: ToTimeSpan
        nameWithType: Offset.ToTimeSpan
        qualifiedName: NodaTime.Offset.ToTimeSpan
      VB:
      - id: NodaTime.Offset.ToTimeSpan*
        name: ToTimeSpan
        nameWithType: Offset.ToTimeSpan
        qualifiedName: NodaTime.Offset.ToTimeSpan
    isDefinition: true
    commentId: Overload:NodaTime.Offset.ToTimeSpan
  NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#GetSchema*:
    name:
      CSharp:
      - id: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: IXmlSerializable.GetSchema
        nameWithType: Offset.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.GetSchema
      VB:
      - id: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: System.Xml.Serialization.IXmlSerializable.GetSchema
        nameWithType: Offset.System.Xml.Serialization.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.GetSchema
    isDefinition: true
    commentId: Overload:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#GetSchema
  NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#ReadXml*:
    name:
      CSharp:
      - id: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: IXmlSerializable.ReadXml
        nameWithType: Offset.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.ReadXml
      VB:
      - id: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: System.Xml.Serialization.IXmlSerializable.ReadXml
        nameWithType: Offset.System.Xml.Serialization.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.ReadXml
    isDefinition: true
    commentId: Overload:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#ReadXml
  NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#WriteXml*:
    name:
      CSharp:
      - id: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: IXmlSerializable.WriteXml
        nameWithType: Offset.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.WriteXml
      VB:
      - id: NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: System.Xml.Serialization.IXmlSerializable.WriteXml
        nameWithType: Offset.System.Xml.Serialization.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.Offset.System.Xml.Serialization.IXmlSerializable.WriteXml
    isDefinition: true
    commentId: Overload:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#WriteXml
  NodaTime.Offset.System#Runtime#Serialization#ISerializable#GetObjectData*:
    name:
      CSharp:
      - id: NodaTime.Offset.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: ISerializable.GetObjectData
        nameWithType: Offset.ISerializable.GetObjectData
        qualifiedName: NodaTime.Offset.System.Runtime.Serialization.ISerializable.GetObjectData
      VB:
      - id: NodaTime.Offset.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: System.Runtime.Serialization.ISerializable.GetObjectData
        nameWithType: Offset.System.Runtime.Serialization.ISerializable.GetObjectData
        qualifiedName: NodaTime.Offset.System.Runtime.Serialization.ISerializable.GetObjectData
    isDefinition: true
    commentId: Overload:NodaTime.Offset.System#Runtime#Serialization#ISerializable#GetObjectData
  NodaTime.Period.Years:
    commentId: P:NodaTime.Period.Years
  NodaTime.Period.Months:
    commentId: P:NodaTime.Period.Months
  NodaTime.Period.Normalize:
    commentId: M:NodaTime.Period.Normalize
  NodaTime.Duration:
    name:
      CSharp:
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      VB:
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.Duration
  System.IEquatable{NodaTime.Period}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.Period}
  System.Collections.Generic.IEqualityComparer{NodaTime.Period}:
    name:
      CSharp:
      - id: System.Collections.Generic.IEqualityComparer`1
        name: IEqualityComparer
        nameWithType: IEqualityComparer
        qualifiedName: System.Collections.Generic.IEqualityComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IEqualityComparer`1
        name: IEqualityComparer
        nameWithType: IEqualityComparer
        qualifiedName: System.Collections.Generic.IEqualityComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IEqualityComparer`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IEqualityComparer{NodaTime.Period}
  NodaTime.Period.NormalizingEqualityComparer*:
    name:
      CSharp:
      - id: NodaTime.Period.NormalizingEqualityComparer*
        name: NormalizingEqualityComparer
        nameWithType: Period.NormalizingEqualityComparer
        qualifiedName: NodaTime.Period.NormalizingEqualityComparer
      VB:
      - id: NodaTime.Period.NormalizingEqualityComparer*
        name: NormalizingEqualityComparer
        nameWithType: Period.NormalizingEqualityComparer
        qualifiedName: NodaTime.Period.NormalizingEqualityComparer
    isDefinition: true
    commentId: Overload:NodaTime.Period.NormalizingEqualityComparer
  NodaTime.Period.FromYears*:
    name:
      CSharp:
      - id: NodaTime.Period.FromYears*
        name: FromYears
        nameWithType: Period.FromYears
        qualifiedName: NodaTime.Period.FromYears
      VB:
      - id: NodaTime.Period.FromYears*
        name: FromYears
        nameWithType: Period.FromYears
        qualifiedName: NodaTime.Period.FromYears
    isDefinition: true
    commentId: Overload:NodaTime.Period.FromYears
  NodaTime.Period.FromWeeks*:
    name:
      CSharp:
      - id: NodaTime.Period.FromWeeks*
        name: FromWeeks
        nameWithType: Period.FromWeeks
        qualifiedName: NodaTime.Period.FromWeeks
      VB:
      - id: NodaTime.Period.FromWeeks*
        name: FromWeeks
        nameWithType: Period.FromWeeks
        qualifiedName: NodaTime.Period.FromWeeks
    isDefinition: true
    commentId: Overload:NodaTime.Period.FromWeeks
  NodaTime.Period.FromMonths*:
    name:
      CSharp:
      - id: NodaTime.Period.FromMonths*
        name: FromMonths
        nameWithType: Period.FromMonths
        qualifiedName: NodaTime.Period.FromMonths
      VB:
      - id: NodaTime.Period.FromMonths*
        name: FromMonths
        nameWithType: Period.FromMonths
        qualifiedName: NodaTime.Period.FromMonths
    isDefinition: true
    commentId: Overload:NodaTime.Period.FromMonths
  NodaTime.Period.FromDays*:
    name:
      CSharp:
      - id: NodaTime.Period.FromDays*
        name: FromDays
        nameWithType: Period.FromDays
        qualifiedName: NodaTime.Period.FromDays
      VB:
      - id: NodaTime.Period.FromDays*
        name: FromDays
        nameWithType: Period.FromDays
        qualifiedName: NodaTime.Period.FromDays
    isDefinition: true
    commentId: Overload:NodaTime.Period.FromDays
  NodaTime.Period.FromHours*:
    name:
      CSharp:
      - id: NodaTime.Period.FromHours*
        name: FromHours
        nameWithType: Period.FromHours
        qualifiedName: NodaTime.Period.FromHours
      VB:
      - id: NodaTime.Period.FromHours*
        name: FromHours
        nameWithType: Period.FromHours
        qualifiedName: NodaTime.Period.FromHours
    isDefinition: true
    commentId: Overload:NodaTime.Period.FromHours
  NodaTime.Period.FromMinutes*:
    name:
      CSharp:
      - id: NodaTime.Period.FromMinutes*
        name: FromMinutes
        nameWithType: Period.FromMinutes
        qualifiedName: NodaTime.Period.FromMinutes
      VB:
      - id: NodaTime.Period.FromMinutes*
        name: FromMinutes
        nameWithType: Period.FromMinutes
        qualifiedName: NodaTime.Period.FromMinutes
    isDefinition: true
    commentId: Overload:NodaTime.Period.FromMinutes
  NodaTime.Period.FromSeconds*:
    name:
      CSharp:
      - id: NodaTime.Period.FromSeconds*
        name: FromSeconds
        nameWithType: Period.FromSeconds
        qualifiedName: NodaTime.Period.FromSeconds
      VB:
      - id: NodaTime.Period.FromSeconds*
        name: FromSeconds
        nameWithType: Period.FromSeconds
        qualifiedName: NodaTime.Period.FromSeconds
    isDefinition: true
    commentId: Overload:NodaTime.Period.FromSeconds
  NodaTime.Period.FromMillseconds*:
    name:
      CSharp:
      - id: NodaTime.Period.FromMillseconds*
        name: FromMillseconds
        nameWithType: Period.FromMillseconds
        qualifiedName: NodaTime.Period.FromMillseconds
      VB:
      - id: NodaTime.Period.FromMillseconds*
        name: FromMillseconds
        nameWithType: Period.FromMillseconds
        qualifiedName: NodaTime.Period.FromMillseconds
    isDefinition: true
    commentId: Overload:NodaTime.Period.FromMillseconds
  NodaTime.Period.FromMilliseconds*:
    name:
      CSharp:
      - id: NodaTime.Period.FromMilliseconds*
        name: FromMilliseconds
        nameWithType: Period.FromMilliseconds
        qualifiedName: NodaTime.Period.FromMilliseconds
      VB:
      - id: NodaTime.Period.FromMilliseconds*
        name: FromMilliseconds
        nameWithType: Period.FromMilliseconds
        qualifiedName: NodaTime.Period.FromMilliseconds
    isDefinition: true
    commentId: Overload:NodaTime.Period.FromMilliseconds
  NodaTime.Period.FromTicks*:
    name:
      CSharp:
      - id: NodaTime.Period.FromTicks*
        name: FromTicks
        nameWithType: Period.FromTicks
        qualifiedName: NodaTime.Period.FromTicks
      VB:
      - id: NodaTime.Period.FromTicks*
        name: FromTicks
        nameWithType: Period.FromTicks
        qualifiedName: NodaTime.Period.FromTicks
    isDefinition: true
    commentId: Overload:NodaTime.Period.FromTicks
  NodaTime.Period.op_Addition*:
    name:
      CSharp:
      - id: NodaTime.Period.op_Addition*
        name: Addition
        nameWithType: Period.Addition
        qualifiedName: NodaTime.Period.Addition
      VB:
      - id: NodaTime.Period.op_Addition*
        name: Addition
        nameWithType: Period.Addition
        qualifiedName: NodaTime.Period.Addition
    isDefinition: true
    commentId: Overload:NodaTime.Period.op_Addition
  System.Collections.Generic.IComparer{NodaTime.Period}:
    name:
      CSharp:
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IComparer`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IComparer{NodaTime.Period}
  NodaTime.Period.CreateComparer*:
    name:
      CSharp:
      - id: NodaTime.Period.CreateComparer*
        name: CreateComparer
        nameWithType: Period.CreateComparer
        qualifiedName: NodaTime.Period.CreateComparer
      VB:
      - id: NodaTime.Period.CreateComparer*
        name: CreateComparer
        nameWithType: Period.CreateComparer
        qualifiedName: NodaTime.Period.CreateComparer
    isDefinition: true
    commentId: Overload:NodaTime.Period.CreateComparer
  NodaTime.Period.op_Subtraction*:
    name:
      CSharp:
      - id: NodaTime.Period.op_Subtraction*
        name: Subtraction
        nameWithType: Period.Subtraction
        qualifiedName: NodaTime.Period.Subtraction
      VB:
      - id: NodaTime.Period.op_Subtraction*
        name: Subtraction
        nameWithType: Period.Subtraction
        qualifiedName: NodaTime.Period.Subtraction
    isDefinition: true
    commentId: Overload:NodaTime.Period.op_Subtraction
  NodaTime.Period.Between*:
    name:
      CSharp:
      - id: NodaTime.Period.Between*
        name: Between
        nameWithType: Period.Between
        qualifiedName: NodaTime.Period.Between
      VB:
      - id: NodaTime.Period.Between*
        name: Between
        nameWithType: Period.Between
        qualifiedName: NodaTime.Period.Between
    isDefinition: true
    commentId: Overload:NodaTime.Period.Between
  NodaTime.Period.HasTimeComponent*:
    name:
      CSharp:
      - id: NodaTime.Period.HasTimeComponent*
        name: HasTimeComponent
        nameWithType: Period.HasTimeComponent
        qualifiedName: NodaTime.Period.HasTimeComponent
      VB:
      - id: NodaTime.Period.HasTimeComponent*
        name: HasTimeComponent
        nameWithType: Period.HasTimeComponent
        qualifiedName: NodaTime.Period.HasTimeComponent
    isDefinition: true
    commentId: Overload:NodaTime.Period.HasTimeComponent
  NodaTime.Period.HasDateComponent*:
    name:
      CSharp:
      - id: NodaTime.Period.HasDateComponent*
        name: HasDateComponent
        nameWithType: Period.HasDateComponent
        qualifiedName: NodaTime.Period.HasDateComponent
      VB:
      - id: NodaTime.Period.HasDateComponent*
        name: HasDateComponent
        nameWithType: Period.HasDateComponent
        qualifiedName: NodaTime.Period.HasDateComponent
    isDefinition: true
    commentId: Overload:NodaTime.Period.HasDateComponent
  System.OverflowException:
    commentId: T:System.OverflowException
  NodaTime.Period.ToDuration*:
    name:
      CSharp:
      - id: NodaTime.Period.ToDuration*
        name: ToDuration
        nameWithType: Period.ToDuration
        qualifiedName: NodaTime.Period.ToDuration
      VB:
      - id: NodaTime.Period.ToDuration*
        name: ToDuration
        nameWithType: Period.ToDuration
        qualifiedName: NodaTime.Period.ToDuration
    isDefinition: true
    commentId: Overload:NodaTime.Period.ToDuration
  NodaTime.Period.ToBuilder*:
    name:
      CSharp:
      - id: NodaTime.Period.ToBuilder*
        name: ToBuilder
        nameWithType: Period.ToBuilder
        qualifiedName: NodaTime.Period.ToBuilder
      VB:
      - id: NodaTime.Period.ToBuilder*
        name: ToBuilder
        nameWithType: Period.ToBuilder
        qualifiedName: NodaTime.Period.ToBuilder
    isDefinition: true
    commentId: Overload:NodaTime.Period.ToBuilder
  System.Int64.MaxValue:
    commentId: F:System.Int64.MaxValue
  NodaTime.Period.NormalizingEqualityComparer:
    commentId: P:NodaTime.Period.NormalizingEqualityComparer
  NodaTime.Period.Normalize*:
    name:
      CSharp:
      - id: NodaTime.Period.Normalize*
        name: Normalize
        nameWithType: Period.Normalize
        qualifiedName: NodaTime.Period.Normalize
      VB:
      - id: NodaTime.Period.Normalize*
        name: Normalize
        nameWithType: Period.Normalize
        qualifiedName: NodaTime.Period.Normalize
    isDefinition: true
    commentId: Overload:NodaTime.Period.Normalize
  NodaTime.Period.Years*:
    name:
      CSharp:
      - id: NodaTime.Period.Years*
        name: Years
        nameWithType: Period.Years
        qualifiedName: NodaTime.Period.Years
      VB:
      - id: NodaTime.Period.Years*
        name: Years
        nameWithType: Period.Years
        qualifiedName: NodaTime.Period.Years
    isDefinition: true
    commentId: Overload:NodaTime.Period.Years
  NodaTime.Period.Months*:
    name:
      CSharp:
      - id: NodaTime.Period.Months*
        name: Months
        nameWithType: Period.Months
        qualifiedName: NodaTime.Period.Months
      VB:
      - id: NodaTime.Period.Months*
        name: Months
        nameWithType: Period.Months
        qualifiedName: NodaTime.Period.Months
    isDefinition: true
    commentId: Overload:NodaTime.Period.Months
  NodaTime.Period.Weeks*:
    name:
      CSharp:
      - id: NodaTime.Period.Weeks*
        name: Weeks
        nameWithType: Period.Weeks
        qualifiedName: NodaTime.Period.Weeks
      VB:
      - id: NodaTime.Period.Weeks*
        name: Weeks
        nameWithType: Period.Weeks
        qualifiedName: NodaTime.Period.Weeks
    isDefinition: true
    commentId: Overload:NodaTime.Period.Weeks
  NodaTime.Period.Days*:
    name:
      CSharp:
      - id: NodaTime.Period.Days*
        name: Days
        nameWithType: Period.Days
        qualifiedName: NodaTime.Period.Days
      VB:
      - id: NodaTime.Period.Days*
        name: Days
        nameWithType: Period.Days
        qualifiedName: NodaTime.Period.Days
    isDefinition: true
    commentId: Overload:NodaTime.Period.Days
  NodaTime.Period.Hours*:
    name:
      CSharp:
      - id: NodaTime.Period.Hours*
        name: Hours
        nameWithType: Period.Hours
        qualifiedName: NodaTime.Period.Hours
      VB:
      - id: NodaTime.Period.Hours*
        name: Hours
        nameWithType: Period.Hours
        qualifiedName: NodaTime.Period.Hours
    isDefinition: true
    commentId: Overload:NodaTime.Period.Hours
  NodaTime.Period.Minutes*:
    name:
      CSharp:
      - id: NodaTime.Period.Minutes*
        name: Minutes
        nameWithType: Period.Minutes
        qualifiedName: NodaTime.Period.Minutes
      VB:
      - id: NodaTime.Period.Minutes*
        name: Minutes
        nameWithType: Period.Minutes
        qualifiedName: NodaTime.Period.Minutes
    isDefinition: true
    commentId: Overload:NodaTime.Period.Minutes
  NodaTime.Period.Seconds*:
    name:
      CSharp:
      - id: NodaTime.Period.Seconds*
        name: Seconds
        nameWithType: Period.Seconds
        qualifiedName: NodaTime.Period.Seconds
      VB:
      - id: NodaTime.Period.Seconds*
        name: Seconds
        nameWithType: Period.Seconds
        qualifiedName: NodaTime.Period.Seconds
    isDefinition: true
    commentId: Overload:NodaTime.Period.Seconds
  NodaTime.Period.Milliseconds*:
    name:
      CSharp:
      - id: NodaTime.Period.Milliseconds*
        name: Milliseconds
        nameWithType: Period.Milliseconds
        qualifiedName: NodaTime.Period.Milliseconds
      VB:
      - id: NodaTime.Period.Milliseconds*
        name: Milliseconds
        nameWithType: Period.Milliseconds
        qualifiedName: NodaTime.Period.Milliseconds
    isDefinition: true
    commentId: Overload:NodaTime.Period.Milliseconds
  NodaTime.Period.Ticks*:
    name:
      CSharp:
      - id: NodaTime.Period.Ticks*
        name: Ticks
        nameWithType: Period.Ticks
        qualifiedName: NodaTime.Period.Ticks
      VB:
      - id: NodaTime.Period.Ticks*
        name: Ticks
        nameWithType: Period.Ticks
        qualifiedName: NodaTime.Period.Ticks
    isDefinition: true
    commentId: Overload:NodaTime.Period.Ticks
  NodaTime.Text.PeriodPattern.RoundtripPattern:
    commentId: F:NodaTime.Text.PeriodPattern.RoundtripPattern
  NodaTime.Period.ToString*:
    name:
      CSharp:
      - id: NodaTime.Period.ToString*
        name: ToString
        nameWithType: Period.ToString
        qualifiedName: NodaTime.Period.ToString
      VB:
      - id: NodaTime.Period.ToString*
        name: ToString
        nameWithType: Period.ToString
        qualifiedName: NodaTime.Period.ToString
    isDefinition: true
    commentId: Overload:NodaTime.Period.ToString
  NodaTime.Period.Equals(NodaTime.Period):
    commentId: M:NodaTime.Period.Equals(NodaTime.Period)
  NodaTime.Period.Equals*:
    name:
      CSharp:
      - id: NodaTime.Period.Equals*
        name: Equals
        nameWithType: Period.Equals
        qualifiedName: NodaTime.Period.Equals
      VB:
      - id: NodaTime.Period.Equals*
        name: Equals
        nameWithType: Period.Equals
        qualifiedName: NodaTime.Period.Equals
    isDefinition: true
    commentId: Overload:NodaTime.Period.Equals
  NodaTime.Period.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.Period.GetHashCode*
        name: GetHashCode
        nameWithType: Period.GetHashCode
        qualifiedName: NodaTime.Period.GetHashCode
      VB:
      - id: NodaTime.Period.GetHashCode*
        name: GetHashCode
        nameWithType: Period.GetHashCode
        qualifiedName: NodaTime.Period.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.Period.GetHashCode
  System.IEquatable{NodaTime.Period}.Equals(NodaTime.Period):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<Period>.Equals
        qualifiedName: System.IEquatable<NodaTime.Period>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of Period).Equals
        qualifiedName: System.IEquatable(Of NodaTime.Period).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.Period}
    commentId: M:System.IEquatable{NodaTime.Period}.Equals(NodaTime.Period)
  NodaTime.Period.System#Runtime#Serialization#ISerializable#GetObjectData*:
    name:
      CSharp:
      - id: NodaTime.Period.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: ISerializable.GetObjectData
        nameWithType: Period.ISerializable.GetObjectData
        qualifiedName: NodaTime.Period.System.Runtime.Serialization.ISerializable.GetObjectData
      VB:
      - id: NodaTime.Period.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: System.Runtime.Serialization.ISerializable.GetObjectData
        nameWithType: Period.System.Runtime.Serialization.ISerializable.GetObjectData
        qualifiedName: NodaTime.Period.System.Runtime.Serialization.ISerializable.GetObjectData
    isDefinition: true
    commentId: Overload:NodaTime.Period.System#Runtime#Serialization#ISerializable#GetObjectData
  NodaTime.SkippedTimeException.LocalDateTime*:
    name:
      CSharp:
      - id: NodaTime.SkippedTimeException.LocalDateTime*
        name: LocalDateTime
        nameWithType: SkippedTimeException.LocalDateTime
        qualifiedName: NodaTime.SkippedTimeException.LocalDateTime
      VB:
      - id: NodaTime.SkippedTimeException.LocalDateTime*
        name: LocalDateTime
        nameWithType: SkippedTimeException.LocalDateTime
        qualifiedName: NodaTime.SkippedTimeException.LocalDateTime
    isDefinition: true
    commentId: Overload:NodaTime.SkippedTimeException.LocalDateTime
  NodaTime.SkippedTimeException.Zone*:
    name:
      CSharp:
      - id: NodaTime.SkippedTimeException.Zone*
        name: Zone
        nameWithType: SkippedTimeException.Zone
        qualifiedName: NodaTime.SkippedTimeException.Zone
      VB:
      - id: NodaTime.SkippedTimeException.Zone*
        name: Zone
        nameWithType: SkippedTimeException.Zone
        qualifiedName: NodaTime.SkippedTimeException.Zone
    isDefinition: true
    commentId: Overload:NodaTime.SkippedTimeException.Zone
  NodaTime.SkippedTimeException.#ctor*:
    name:
      CSharp:
      - id: NodaTime.SkippedTimeException.#ctor*
        name: SkippedTimeException
        nameWithType: SkippedTimeException.SkippedTimeException
        qualifiedName: NodaTime.SkippedTimeException.SkippedTimeException
      VB:
      - id: NodaTime.SkippedTimeException.#ctor*
        name: SkippedTimeException
        nameWithType: SkippedTimeException.SkippedTimeException
        qualifiedName: NodaTime.SkippedTimeException.SkippedTimeException
    isDefinition: true
    commentId: Overload:NodaTime.SkippedTimeException.#ctor
  NodaTime.SkippedTimeException:
    name:
      CSharp:
      - id: NodaTime.SkippedTimeException
        name: SkippedTimeException
        nameWithType: SkippedTimeException
        qualifiedName: NodaTime.SkippedTimeException
      VB:
      - id: NodaTime.SkippedTimeException
        name: SkippedTimeException
        nameWithType: SkippedTimeException
        qualifiedName: NodaTime.SkippedTimeException
    isDefinition: true
    commentId: T:NodaTime.SkippedTimeException
  NodaTime.SystemClock.Now*:
    name:
      CSharp:
      - id: NodaTime.SystemClock.Now*
        name: Now
        nameWithType: SystemClock.Now
        qualifiedName: NodaTime.SystemClock.Now
      VB:
      - id: NodaTime.SystemClock.Now*
        name: Now
        nameWithType: SystemClock.Now
        qualifiedName: NodaTime.SystemClock.Now
    isDefinition: true
    commentId: Overload:NodaTime.SystemClock.Now
  NodaTime.IClock.Now:
    name:
      CSharp:
      - id: NodaTime.IClock.Now
        name: Now
        nameWithType: IClock.Now
        qualifiedName: NodaTime.IClock.Now
      VB:
      - id: NodaTime.IClock.Now
        name: Now
        nameWithType: IClock.Now
        qualifiedName: NodaTime.IClock.Now
    isDefinition: true
    parent: NodaTime.IClock
    commentId: P:NodaTime.IClock.Now
  NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime):
    commentId: M:NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)
  NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime):
    commentId: M:NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)
  NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime):
    commentId: M:NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)
  System.IEquatable{NodaTime.LocalDateTime}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.LocalDateTime}
  System.IComparable{NodaTime.LocalDateTime}:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1
    parent: System
    commentId: T:System.IComparable{NodaTime.LocalDateTime}
  NodaTime.LocalDateTime.#ctor*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.#ctor*
        name: LocalDateTime
        nameWithType: LocalDateTime.LocalDateTime
        qualifiedName: NodaTime.LocalDateTime.LocalDateTime
      VB:
      - id: NodaTime.LocalDateTime.#ctor*
        name: LocalDateTime
        nameWithType: LocalDateTime.LocalDateTime
        qualifiedName: NodaTime.LocalDateTime.LocalDateTime
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.#ctor
  NodaTime.LocalDateTime.Calendar*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Calendar*
        name: Calendar
        nameWithType: LocalDateTime.Calendar
        qualifiedName: NodaTime.LocalDateTime.Calendar
      VB:
      - id: NodaTime.LocalDateTime.Calendar*
        name: Calendar
        nameWithType: LocalDateTime.Calendar
        qualifiedName: NodaTime.LocalDateTime.Calendar
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Calendar
  NodaTime.LocalDateTime.CenturyOfEra*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.CenturyOfEra*
        name: CenturyOfEra
        nameWithType: LocalDateTime.CenturyOfEra
        qualifiedName: NodaTime.LocalDateTime.CenturyOfEra
      VB:
      - id: NodaTime.LocalDateTime.CenturyOfEra*
        name: CenturyOfEra
        nameWithType: LocalDateTime.CenturyOfEra
        qualifiedName: NodaTime.LocalDateTime.CenturyOfEra
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.CenturyOfEra
  NodaTime.LocalDateTime.Year*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Year*
        name: Year
        nameWithType: LocalDateTime.Year
        qualifiedName: NodaTime.LocalDateTime.Year
      VB:
      - id: NodaTime.LocalDateTime.Year*
        name: Year
        nameWithType: LocalDateTime.Year
        qualifiedName: NodaTime.LocalDateTime.Year
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Year
  NodaTime.LocalDateTime.YearOfCentury*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.YearOfCentury*
        name: YearOfCentury
        nameWithType: LocalDateTime.YearOfCentury
        qualifiedName: NodaTime.LocalDateTime.YearOfCentury
      VB:
      - id: NodaTime.LocalDateTime.YearOfCentury*
        name: YearOfCentury
        nameWithType: LocalDateTime.YearOfCentury
        qualifiedName: NodaTime.LocalDateTime.YearOfCentury
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.YearOfCentury
  NodaTime.LocalDateTime.YearOfEra*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.YearOfEra*
        name: YearOfEra
        nameWithType: LocalDateTime.YearOfEra
        qualifiedName: NodaTime.LocalDateTime.YearOfEra
      VB:
      - id: NodaTime.LocalDateTime.YearOfEra*
        name: YearOfEra
        nameWithType: LocalDateTime.YearOfEra
        qualifiedName: NodaTime.LocalDateTime.YearOfEra
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.YearOfEra
  NodaTime.LocalDateTime.Era*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Era*
        name: Era
        nameWithType: LocalDateTime.Era
        qualifiedName: NodaTime.LocalDateTime.Era
      VB:
      - id: NodaTime.LocalDateTime.Era*
        name: Era
        nameWithType: LocalDateTime.Era
        qualifiedName: NodaTime.LocalDateTime.Era
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Era
  NodaTime.LocalDateTime.WeekOfWeekYear:
    commentId: P:NodaTime.LocalDateTime.WeekOfWeekYear
  NodaTime.LocalDateTime.WeekYear*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.WeekYear*
        name: WeekYear
        nameWithType: LocalDateTime.WeekYear
        qualifiedName: NodaTime.LocalDateTime.WeekYear
      VB:
      - id: NodaTime.LocalDateTime.WeekYear*
        name: WeekYear
        nameWithType: LocalDateTime.WeekYear
        qualifiedName: NodaTime.LocalDateTime.WeekYear
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.WeekYear
  NodaTime.LocalDateTime.Month*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Month*
        name: Month
        nameWithType: LocalDateTime.Month
        qualifiedName: NodaTime.LocalDateTime.Month
      VB:
      - id: NodaTime.LocalDateTime.Month*
        name: Month
        nameWithType: LocalDateTime.Month
        qualifiedName: NodaTime.LocalDateTime.Month
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Month
  NodaTime.LocalDateTime.WeekYear:
    commentId: P:NodaTime.LocalDateTime.WeekYear
  NodaTime.LocalDateTime.WeekOfWeekYear*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.WeekOfWeekYear*
        name: WeekOfWeekYear
        nameWithType: LocalDateTime.WeekOfWeekYear
        qualifiedName: NodaTime.LocalDateTime.WeekOfWeekYear
      VB:
      - id: NodaTime.LocalDateTime.WeekOfWeekYear*
        name: WeekOfWeekYear
        nameWithType: LocalDateTime.WeekOfWeekYear
        qualifiedName: NodaTime.LocalDateTime.WeekOfWeekYear
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.WeekOfWeekYear
  NodaTime.LocalDateTime.DayOfYear*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.DayOfYear*
        name: DayOfYear
        nameWithType: LocalDateTime.DayOfYear
        qualifiedName: NodaTime.LocalDateTime.DayOfYear
      VB:
      - id: NodaTime.LocalDateTime.DayOfYear*
        name: DayOfYear
        nameWithType: LocalDateTime.DayOfYear
        qualifiedName: NodaTime.LocalDateTime.DayOfYear
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.DayOfYear
  NodaTime.LocalDateTime.Day*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Day*
        name: Day
        nameWithType: LocalDateTime.Day
        qualifiedName: NodaTime.LocalDateTime.Day
      VB:
      - id: NodaTime.LocalDateTime.Day*
        name: Day
        nameWithType: LocalDateTime.Day
        qualifiedName: NodaTime.LocalDateTime.Day
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Day
  NodaTime.LocalDateTime.DayOfWeek:
    commentId: P:NodaTime.LocalDateTime.DayOfWeek
  NodaTime.LocalDateTime.IsoDayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.IsoDayOfWeek*
        name: IsoDayOfWeek
        nameWithType: LocalDateTime.IsoDayOfWeek
        qualifiedName: NodaTime.LocalDateTime.IsoDayOfWeek
      VB:
      - id: NodaTime.LocalDateTime.IsoDayOfWeek*
        name: IsoDayOfWeek
        nameWithType: LocalDateTime.IsoDayOfWeek
        qualifiedName: NodaTime.LocalDateTime.IsoDayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.IsoDayOfWeek
  NodaTime.LocalDateTime.IsoDayOfWeek:
    commentId: P:NodaTime.LocalDateTime.IsoDayOfWeek
  NodaTime.LocalDateTime.DayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.DayOfWeek*
        name: DayOfWeek
        nameWithType: LocalDateTime.DayOfWeek
        qualifiedName: NodaTime.LocalDateTime.DayOfWeek
      VB:
      - id: NodaTime.LocalDateTime.DayOfWeek*
        name: DayOfWeek
        nameWithType: LocalDateTime.DayOfWeek
        qualifiedName: NodaTime.LocalDateTime.DayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.DayOfWeek
  NodaTime.LocalDateTime.Hour*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Hour*
        name: Hour
        nameWithType: LocalDateTime.Hour
        qualifiedName: NodaTime.LocalDateTime.Hour
      VB:
      - id: NodaTime.LocalDateTime.Hour*
        name: Hour
        nameWithType: LocalDateTime.Hour
        qualifiedName: NodaTime.LocalDateTime.Hour
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Hour
  NodaTime.LocalDateTime.ClockHourOfHalfDay*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.ClockHourOfHalfDay*
        name: ClockHourOfHalfDay
        nameWithType: LocalDateTime.ClockHourOfHalfDay
        qualifiedName: NodaTime.LocalDateTime.ClockHourOfHalfDay
      VB:
      - id: NodaTime.LocalDateTime.ClockHourOfHalfDay*
        name: ClockHourOfHalfDay
        nameWithType: LocalDateTime.ClockHourOfHalfDay
        qualifiedName: NodaTime.LocalDateTime.ClockHourOfHalfDay
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.ClockHourOfHalfDay
  NodaTime.LocalDateTime.Minute*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Minute*
        name: Minute
        nameWithType: LocalDateTime.Minute
        qualifiedName: NodaTime.LocalDateTime.Minute
      VB:
      - id: NodaTime.LocalDateTime.Minute*
        name: Minute
        nameWithType: LocalDateTime.Minute
        qualifiedName: NodaTime.LocalDateTime.Minute
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Minute
  NodaTime.LocalDateTime.Second*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Second*
        name: Second
        nameWithType: LocalDateTime.Second
        qualifiedName: NodaTime.LocalDateTime.Second
      VB:
      - id: NodaTime.LocalDateTime.Second*
        name: Second
        nameWithType: LocalDateTime.Second
        qualifiedName: NodaTime.LocalDateTime.Second
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Second
  NodaTime.LocalDateTime.Millisecond*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Millisecond*
        name: Millisecond
        nameWithType: LocalDateTime.Millisecond
        qualifiedName: NodaTime.LocalDateTime.Millisecond
      VB:
      - id: NodaTime.LocalDateTime.Millisecond*
        name: Millisecond
        nameWithType: LocalDateTime.Millisecond
        qualifiedName: NodaTime.LocalDateTime.Millisecond
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Millisecond
  NodaTime.LocalDateTime.TickOfSecond*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.TickOfSecond*
        name: TickOfSecond
        nameWithType: LocalDateTime.TickOfSecond
        qualifiedName: NodaTime.LocalDateTime.TickOfSecond
      VB:
      - id: NodaTime.LocalDateTime.TickOfSecond*
        name: TickOfSecond
        nameWithType: LocalDateTime.TickOfSecond
        qualifiedName: NodaTime.LocalDateTime.TickOfSecond
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.TickOfSecond
  NodaTime.LocalDateTime.TickOfDay*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.TickOfDay*
        name: TickOfDay
        nameWithType: LocalDateTime.TickOfDay
        qualifiedName: NodaTime.LocalDateTime.TickOfDay
      VB:
      - id: NodaTime.LocalDateTime.TickOfDay*
        name: TickOfDay
        nameWithType: LocalDateTime.TickOfDay
        qualifiedName: NodaTime.LocalDateTime.TickOfDay
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.TickOfDay
  NodaTime.LocalDateTime.TimeOfDay*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.TimeOfDay*
        name: TimeOfDay
        nameWithType: LocalDateTime.TimeOfDay
        qualifiedName: NodaTime.LocalDateTime.TimeOfDay
      VB:
      - id: NodaTime.LocalDateTime.TimeOfDay*
        name: TimeOfDay
        nameWithType: LocalDateTime.TimeOfDay
        qualifiedName: NodaTime.LocalDateTime.TimeOfDay
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.TimeOfDay
  NodaTime.LocalDateTime.Date*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Date*
        name: Date
        nameWithType: LocalDateTime.Date
        qualifiedName: NodaTime.LocalDateTime.Date
      VB:
      - id: NodaTime.LocalDateTime.Date*
        name: Date
        nameWithType: LocalDateTime.Date
        qualifiedName: NodaTime.LocalDateTime.Date
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Date
  System.DateTime.Kind:
    commentId: P:System.DateTime.Kind
  System.DateTimeKind.Unspecified:
    commentId: F:System.DateTimeKind.Unspecified
  System.DateTime.ToLocalTime:
    commentId: M:System.DateTime.ToLocalTime
  System.DateTime.ToUniversalTime:
    commentId: M:System.DateTime.ToUniversalTime
  NodaTime.LocalDateTime.ToDateTimeUnspecified*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.ToDateTimeUnspecified*
        name: ToDateTimeUnspecified
        nameWithType: LocalDateTime.ToDateTimeUnspecified
        qualifiedName: NodaTime.LocalDateTime.ToDateTimeUnspecified
      VB:
      - id: NodaTime.LocalDateTime.ToDateTimeUnspecified*
        name: ToDateTimeUnspecified
        nameWithType: LocalDateTime.ToDateTimeUnspecified
        qualifiedName: NodaTime.LocalDateTime.ToDateTimeUnspecified
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.ToDateTimeUnspecified
  System.DateTimeKind.Utc:
    commentId: F:System.DateTimeKind.Utc
  NodaTime.LocalDateTime.FromDateTime*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.FromDateTime*
        name: FromDateTime
        nameWithType: LocalDateTime.FromDateTime
        qualifiedName: NodaTime.LocalDateTime.FromDateTime
      VB:
      - id: NodaTime.LocalDateTime.FromDateTime*
        name: FromDateTime
        nameWithType: LocalDateTime.FromDateTime
        qualifiedName: NodaTime.LocalDateTime.FromDateTime
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.FromDateTime
  NodaTime.LocalDateTime.Equals*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Equals*
        name: Equals
        nameWithType: LocalDateTime.Equals
        qualifiedName: NodaTime.LocalDateTime.Equals
      VB:
      - id: NodaTime.LocalDateTime.Equals*
        name: Equals
        nameWithType: LocalDateTime.Equals
        qualifiedName: NodaTime.LocalDateTime.Equals
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Equals
  System.IEquatable{NodaTime.LocalDateTime}.Equals(NodaTime.LocalDateTime):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<LocalDateTime>.Equals
        qualifiedName: System.IEquatable<NodaTime.LocalDateTime>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of LocalDateTime).Equals
        qualifiedName: System.IEquatable(Of NodaTime.LocalDateTime).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.LocalDateTime}
    commentId: M:System.IEquatable{NodaTime.LocalDateTime}.Equals(NodaTime.LocalDateTime)
  NodaTime.LocalDateTime.op_Equality*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.op_Equality*
        name: Equality
        nameWithType: LocalDateTime.Equality
        qualifiedName: NodaTime.LocalDateTime.Equality
      VB:
      - id: NodaTime.LocalDateTime.op_Equality*
        name: Equality
        nameWithType: LocalDateTime.Equality
        qualifiedName: NodaTime.LocalDateTime.Equality
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.op_Equality
  NodaTime.LocalDateTime.op_Inequality*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.op_Inequality*
        name: Inequality
        nameWithType: LocalDateTime.Inequality
        qualifiedName: NodaTime.LocalDateTime.Inequality
      VB:
      - id: NodaTime.LocalDateTime.op_Inequality*
        name: Inequality
        nameWithType: LocalDateTime.Inequality
        qualifiedName: NodaTime.LocalDateTime.Inequality
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.op_Inequality
  NodaTime.LocalDateTime.op_LessThan*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.op_LessThan*
        name: LessThan
        nameWithType: LocalDateTime.LessThan
        qualifiedName: NodaTime.LocalDateTime.LessThan
      VB:
      - id: NodaTime.LocalDateTime.op_LessThan*
        name: LessThan
        nameWithType: LocalDateTime.LessThan
        qualifiedName: NodaTime.LocalDateTime.LessThan
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.op_LessThan
  NodaTime.LocalDateTime.op_LessThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: LocalDateTime.LessThanOrEqual
        qualifiedName: NodaTime.LocalDateTime.LessThanOrEqual
      VB:
      - id: NodaTime.LocalDateTime.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: LocalDateTime.LessThanOrEqual
        qualifiedName: NodaTime.LocalDateTime.LessThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.op_LessThanOrEqual
  NodaTime.LocalDateTime.op_GreaterThan*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.op_GreaterThan*
        name: GreaterThan
        nameWithType: LocalDateTime.GreaterThan
        qualifiedName: NodaTime.LocalDateTime.GreaterThan
      VB:
      - id: NodaTime.LocalDateTime.op_GreaterThan*
        name: GreaterThan
        nameWithType: LocalDateTime.GreaterThan
        qualifiedName: NodaTime.LocalDateTime.GreaterThan
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.op_GreaterThan
  NodaTime.LocalDateTime.op_GreaterThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: LocalDateTime.GreaterThanOrEqual
        qualifiedName: NodaTime.LocalDateTime.GreaterThanOrEqual
      VB:
      - id: NodaTime.LocalDateTime.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: LocalDateTime.GreaterThanOrEqual
        qualifiedName: NodaTime.LocalDateTime.GreaterThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.op_GreaterThanOrEqual
  NodaTime.LocalDateTime.CompareTo*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.CompareTo*
        name: CompareTo
        nameWithType: LocalDateTime.CompareTo
        qualifiedName: NodaTime.LocalDateTime.CompareTo
      VB:
      - id: NodaTime.LocalDateTime.CompareTo*
        name: CompareTo
        nameWithType: LocalDateTime.CompareTo
        qualifiedName: NodaTime.LocalDateTime.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.CompareTo
  System.IComparable{NodaTime.LocalDateTime}.CompareTo(NodaTime.LocalDateTime):
    name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<LocalDateTime>.CompareTo
        qualifiedName: System.IComparable<NodaTime.LocalDateTime>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of LocalDateTime).CompareTo
        qualifiedName: System.IComparable(Of NodaTime.LocalDateTime).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1.CompareTo(`0)
    parent: System.IComparable{NodaTime.LocalDateTime}
    commentId: M:System.IComparable{NodaTime.LocalDateTime}.CompareTo(NodaTime.LocalDateTime)
  NodaTime.LocalDateTime.System#IComparable#CompareTo*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.System#IComparable#CompareTo*
        name: IComparable.CompareTo
        nameWithType: LocalDateTime.IComparable.CompareTo
        qualifiedName: NodaTime.LocalDateTime.System.IComparable.CompareTo
      VB:
      - id: NodaTime.LocalDateTime.System#IComparable#CompareTo*
        name: System.IComparable.CompareTo
        nameWithType: LocalDateTime.System.IComparable.CompareTo
        qualifiedName: NodaTime.LocalDateTime.System.IComparable.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.System#IComparable#CompareTo
  NodaTime.LocalDateTime.Plus(NodaTime.Period):
    commentId: M:NodaTime.LocalDateTime.Plus(NodaTime.Period)
  NodaTime.LocalDateTime.op_Addition*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.op_Addition*
        name: Addition
        nameWithType: LocalDateTime.Addition
        qualifiedName: NodaTime.LocalDateTime.Addition
      VB:
      - id: NodaTime.LocalDateTime.op_Addition*
        name: Addition
        nameWithType: LocalDateTime.Addition
        qualifiedName: NodaTime.LocalDateTime.Addition
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.op_Addition
  NodaTime.LocalDateTime.Add*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Add*
        name: Add
        nameWithType: LocalDateTime.Add
        qualifiedName: NodaTime.LocalDateTime.Add
      VB:
      - id: NodaTime.LocalDateTime.Add*
        name: Add
        nameWithType: LocalDateTime.Add
        qualifiedName: NodaTime.LocalDateTime.Add
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Add
  NodaTime.LocalDateTime.Plus*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Plus*
        name: Plus
        nameWithType: LocalDateTime.Plus
        qualifiedName: NodaTime.LocalDateTime.Plus
      VB:
      - id: NodaTime.LocalDateTime.Plus*
        name: Plus
        nameWithType: LocalDateTime.Plus
        qualifiedName: NodaTime.LocalDateTime.Plus
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Plus
  NodaTime.LocalDateTime.Minus(NodaTime.Period):
    commentId: M:NodaTime.LocalDateTime.Minus(NodaTime.Period)
  NodaTime.LocalDateTime.op_Subtraction*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.op_Subtraction*
        name: Subtraction
        nameWithType: LocalDateTime.Subtraction
        qualifiedName: NodaTime.LocalDateTime.Subtraction
      VB:
      - id: NodaTime.LocalDateTime.op_Subtraction*
        name: Subtraction
        nameWithType: LocalDateTime.Subtraction
        qualifiedName: NodaTime.LocalDateTime.Subtraction
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.op_Subtraction
  NodaTime.LocalDateTime.Subtract*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Subtract*
        name: Subtract
        nameWithType: LocalDateTime.Subtract
        qualifiedName: NodaTime.LocalDateTime.Subtract
      VB:
      - id: NodaTime.LocalDateTime.Subtract*
        name: Subtract
        nameWithType: LocalDateTime.Subtract
        qualifiedName: NodaTime.LocalDateTime.Subtract
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Subtract
  NodaTime.LocalDateTime.Minus*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Minus*
        name: Minus
        nameWithType: LocalDateTime.Minus
        qualifiedName: NodaTime.LocalDateTime.Minus
      VB:
      - id: NodaTime.LocalDateTime.Minus*
        name: Minus
        nameWithType: LocalDateTime.Minus
        qualifiedName: NodaTime.LocalDateTime.Minus
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Minus
  NodaTime.LocalDateTime.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.GetHashCode*
        name: GetHashCode
        nameWithType: LocalDateTime.GetHashCode
        qualifiedName: NodaTime.LocalDateTime.GetHashCode
      VB:
      - id: NodaTime.LocalDateTime.GetHashCode*
        name: GetHashCode
        nameWithType: LocalDateTime.GetHashCode
        qualifiedName: NodaTime.LocalDateTime.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.GetHashCode
  NodaTime.LocalDateTime.WithCalendar*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.WithCalendar*
        name: WithCalendar
        nameWithType: LocalDateTime.WithCalendar
        qualifiedName: NodaTime.LocalDateTime.WithCalendar
      VB:
      - id: NodaTime.LocalDateTime.WithCalendar*
        name: WithCalendar
        nameWithType: LocalDateTime.WithCalendar
        qualifiedName: NodaTime.LocalDateTime.WithCalendar
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.WithCalendar
  NodaTime.LocalDateTime.PlusYears*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.PlusYears*
        name: PlusYears
        nameWithType: LocalDateTime.PlusYears
        qualifiedName: NodaTime.LocalDateTime.PlusYears
      VB:
      - id: NodaTime.LocalDateTime.PlusYears*
        name: PlusYears
        nameWithType: LocalDateTime.PlusYears
        qualifiedName: NodaTime.LocalDateTime.PlusYears
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.PlusYears
  NodaTime.LocalDateTime.PlusMonths*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.PlusMonths*
        name: PlusMonths
        nameWithType: LocalDateTime.PlusMonths
        qualifiedName: NodaTime.LocalDateTime.PlusMonths
      VB:
      - id: NodaTime.LocalDateTime.PlusMonths*
        name: PlusMonths
        nameWithType: LocalDateTime.PlusMonths
        qualifiedName: NodaTime.LocalDateTime.PlusMonths
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.PlusMonths
  NodaTime.LocalDateTime.PlusDays*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.PlusDays*
        name: PlusDays
        nameWithType: LocalDateTime.PlusDays
        qualifiedName: NodaTime.LocalDateTime.PlusDays
      VB:
      - id: NodaTime.LocalDateTime.PlusDays*
        name: PlusDays
        nameWithType: LocalDateTime.PlusDays
        qualifiedName: NodaTime.LocalDateTime.PlusDays
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.PlusDays
  NodaTime.LocalDateTime.PlusWeeks*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.PlusWeeks*
        name: PlusWeeks
        nameWithType: LocalDateTime.PlusWeeks
        qualifiedName: NodaTime.LocalDateTime.PlusWeeks
      VB:
      - id: NodaTime.LocalDateTime.PlusWeeks*
        name: PlusWeeks
        nameWithType: LocalDateTime.PlusWeeks
        qualifiedName: NodaTime.LocalDateTime.PlusWeeks
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.PlusWeeks
  NodaTime.LocalDateTime.PlusHours*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.PlusHours*
        name: PlusHours
        nameWithType: LocalDateTime.PlusHours
        qualifiedName: NodaTime.LocalDateTime.PlusHours
      VB:
      - id: NodaTime.LocalDateTime.PlusHours*
        name: PlusHours
        nameWithType: LocalDateTime.PlusHours
        qualifiedName: NodaTime.LocalDateTime.PlusHours
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.PlusHours
  NodaTime.LocalDateTime.PlusMinutes*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.PlusMinutes*
        name: PlusMinutes
        nameWithType: LocalDateTime.PlusMinutes
        qualifiedName: NodaTime.LocalDateTime.PlusMinutes
      VB:
      - id: NodaTime.LocalDateTime.PlusMinutes*
        name: PlusMinutes
        nameWithType: LocalDateTime.PlusMinutes
        qualifiedName: NodaTime.LocalDateTime.PlusMinutes
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.PlusMinutes
  NodaTime.LocalDateTime.PlusSeconds*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.PlusSeconds*
        name: PlusSeconds
        nameWithType: LocalDateTime.PlusSeconds
        qualifiedName: NodaTime.LocalDateTime.PlusSeconds
      VB:
      - id: NodaTime.LocalDateTime.PlusSeconds*
        name: PlusSeconds
        nameWithType: LocalDateTime.PlusSeconds
        qualifiedName: NodaTime.LocalDateTime.PlusSeconds
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.PlusSeconds
  NodaTime.LocalDateTime.PlusMilliseconds*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.PlusMilliseconds*
        name: PlusMilliseconds
        nameWithType: LocalDateTime.PlusMilliseconds
        qualifiedName: NodaTime.LocalDateTime.PlusMilliseconds
      VB:
      - id: NodaTime.LocalDateTime.PlusMilliseconds*
        name: PlusMilliseconds
        nameWithType: LocalDateTime.PlusMilliseconds
        qualifiedName: NodaTime.LocalDateTime.PlusMilliseconds
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.PlusMilliseconds
  NodaTime.LocalDateTime.PlusTicks*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.PlusTicks*
        name: PlusTicks
        nameWithType: LocalDateTime.PlusTicks
        qualifiedName: NodaTime.LocalDateTime.PlusTicks
      VB:
      - id: NodaTime.LocalDateTime.PlusTicks*
        name: PlusTicks
        nameWithType: LocalDateTime.PlusTicks
        qualifiedName: NodaTime.LocalDateTime.PlusTicks
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.PlusTicks
  NodaTime.LocalDateTime.Next*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Next*
        name: Next
        nameWithType: LocalDateTime.Next
        qualifiedName: NodaTime.LocalDateTime.Next
      VB:
      - id: NodaTime.LocalDateTime.Next*
        name: Next
        nameWithType: LocalDateTime.Next
        qualifiedName: NodaTime.LocalDateTime.Next
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Next
  NodaTime.LocalDateTime.Previous*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.Previous*
        name: Previous
        nameWithType: LocalDateTime.Previous
        qualifiedName: NodaTime.LocalDateTime.Previous
      VB:
      - id: NodaTime.LocalDateTime.Previous*
        name: Previous
        nameWithType: LocalDateTime.Previous
        qualifiedName: NodaTime.LocalDateTime.Previous
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.Previous
  NodaTime.LocalDateTime.WithOffset*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.WithOffset*
        name: WithOffset
        nameWithType: LocalDateTime.WithOffset
        qualifiedName: NodaTime.LocalDateTime.WithOffset
      VB:
      - id: NodaTime.LocalDateTime.WithOffset*
        name: WithOffset
        nameWithType: LocalDateTime.WithOffset
        qualifiedName: NodaTime.LocalDateTime.WithOffset
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.WithOffset
  NodaTime.DateTimeZone.Utc:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.Utc
        name: Utc
        nameWithType: DateTimeZone.Utc
        qualifiedName: NodaTime.DateTimeZone.Utc
      VB:
      - id: NodaTime.DateTimeZone.Utc
        name: Utc
        nameWithType: DateTimeZone.Utc
        qualifiedName: NodaTime.DateTimeZone.Utc
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: P:NodaTime.DateTimeZone.Utc
  NodaTime.LocalDateTime.InUtc*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.InUtc*
        name: InUtc
        nameWithType: LocalDateTime.InUtc
        qualifiedName: NodaTime.LocalDateTime.InUtc
      VB:
      - id: NodaTime.LocalDateTime.InUtc*
        name: InUtc
        nameWithType: LocalDateTime.InUtc
        qualifiedName: NodaTime.LocalDateTime.InUtc
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.InUtc
  NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)
        name: AtStrictly
        nameWithType: DateTimeZone.AtStrictly
        qualifiedName: NodaTime.DateTimeZone.AtStrictly
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)
        name: AtStrictly
        nameWithType: DateTimeZone.AtStrictly
        qualifiedName: NodaTime.DateTimeZone.AtStrictly
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)
  NodaTime.LocalDateTime.InZoneStrictly*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.InZoneStrictly*
        name: InZoneStrictly
        nameWithType: LocalDateTime.InZoneStrictly
        qualifiedName: NodaTime.LocalDateTime.InZoneStrictly
      VB:
      - id: NodaTime.LocalDateTime.InZoneStrictly*
        name: InZoneStrictly
        nameWithType: LocalDateTime.InZoneStrictly
        qualifiedName: NodaTime.LocalDateTime.InZoneStrictly
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.InZoneStrictly
  NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)
        name: AtLeniently
        nameWithType: DateTimeZone.AtLeniently
        qualifiedName: NodaTime.DateTimeZone.AtLeniently
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)
        name: AtLeniently
        nameWithType: DateTimeZone.AtLeniently
        qualifiedName: NodaTime.DateTimeZone.AtLeniently
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)
  NodaTime.LocalDateTime.InZoneLeniently*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.InZoneLeniently*
        name: InZoneLeniently
        nameWithType: LocalDateTime.InZoneLeniently
        qualifiedName: NodaTime.LocalDateTime.InZoneLeniently
      VB:
      - id: NodaTime.LocalDateTime.InZoneLeniently*
        name: InZoneLeniently
        nameWithType: LocalDateTime.InZoneLeniently
        qualifiedName: NodaTime.LocalDateTime.InZoneLeniently
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.InZoneLeniently
  NodaTime.TimeZones.ZoneLocalMappingResolver:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneLocalMappingResolver
        name: ZoneLocalMappingResolver
        nameWithType: ZoneLocalMappingResolver
        qualifiedName: NodaTime.TimeZones.ZoneLocalMappingResolver
      VB:
      - id: NodaTime.TimeZones.ZoneLocalMappingResolver
        name: ZoneLocalMappingResolver
        nameWithType: ZoneLocalMappingResolver
        qualifiedName: NodaTime.TimeZones.ZoneLocalMappingResolver
    isDefinition: true
    parent: NodaTime.TimeZones
    commentId: T:NodaTime.TimeZones.ZoneLocalMappingResolver
  NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)
        name: ResolveLocal
        nameWithType: DateTimeZone.ResolveLocal
        qualifiedName: NodaTime.DateTimeZone.ResolveLocal
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: NodaTime.TimeZones.ZoneLocalMappingResolver
        name: ZoneLocalMappingResolver
        nameWithType: ZoneLocalMappingResolver
        qualifiedName: NodaTime.TimeZones.ZoneLocalMappingResolver
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)
        name: ResolveLocal
        nameWithType: DateTimeZone.ResolveLocal
        qualifiedName: NodaTime.DateTimeZone.ResolveLocal
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: NodaTime.TimeZones.ZoneLocalMappingResolver
        name: ZoneLocalMappingResolver
        nameWithType: ZoneLocalMappingResolver
        qualifiedName: NodaTime.TimeZones.ZoneLocalMappingResolver
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)
  NodaTime.TimeZones:
    name:
      CSharp:
      - name: NodaTime.TimeZones
        nameWithType: NodaTime.TimeZones
        qualifiedName: NodaTime.TimeZones
      VB:
      - name: NodaTime.TimeZones
        nameWithType: NodaTime.TimeZones
        qualifiedName: NodaTime.TimeZones
    isDefinition: true
    commentId: N:NodaTime.TimeZones
  NodaTime.LocalDateTime.InZone*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.InZone*
        name: InZone
        nameWithType: LocalDateTime.InZone
        qualifiedName: NodaTime.LocalDateTime.InZone
      VB:
      - id: NodaTime.LocalDateTime.InZone*
        name: InZone
        nameWithType: LocalDateTime.InZone
        qualifiedName: NodaTime.LocalDateTime.InZone
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.InZone
  NodaTime.LocalDateTime.ToString*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.ToString*
        name: ToString
        nameWithType: LocalDateTime.ToString
        qualifiedName: NodaTime.LocalDateTime.ToString
      VB:
      - id: NodaTime.LocalDateTime.ToString*
        name: ToString
        nameWithType: LocalDateTime.ToString
        qualifiedName: NodaTime.LocalDateTime.ToString
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.ToString
  NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: IXmlSerializable.GetSchema
        nameWithType: LocalDateTime.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema
      VB:
      - id: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: System.Xml.Serialization.IXmlSerializable.GetSchema
        nameWithType: LocalDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema
  NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: IXmlSerializable.ReadXml
        nameWithType: LocalDateTime.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml
      VB:
      - id: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: System.Xml.Serialization.IXmlSerializable.ReadXml
        nameWithType: LocalDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml
  NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: IXmlSerializable.WriteXml
        nameWithType: LocalDateTime.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml
      VB:
      - id: NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: System.Xml.Serialization.IXmlSerializable.WriteXml
        nameWithType: LocalDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.LocalDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml
  NodaTime.LocalDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*:
    name:
      CSharp:
      - id: NodaTime.LocalDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: ISerializable.GetObjectData
        nameWithType: LocalDateTime.ISerializable.GetObjectData
        qualifiedName: NodaTime.LocalDateTime.System.Runtime.Serialization.ISerializable.GetObjectData
      VB:
      - id: NodaTime.LocalDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: System.Runtime.Serialization.ISerializable.GetObjectData
        nameWithType: LocalDateTime.System.Runtime.Serialization.ISerializable.GetObjectData
        qualifiedName: NodaTime.LocalDateTime.System.Runtime.Serialization.ISerializable.GetObjectData
    isDefinition: true
    commentId: Overload:NodaTime.LocalDateTime.System#Runtime#Serialization#ISerializable#GetObjectData
  NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)
        name: MapLocal
        nameWithType: DateTimeZone.MapLocal
        qualifiedName: NodaTime.DateTimeZone.MapLocal
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)
        name: MapLocal
        nameWithType: DateTimeZone.MapLocal
        qualifiedName: NodaTime.DateTimeZone.MapLocal
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)
  NodaTime.TimeZones.ZoneLocalMapping:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneLocalMapping
        name: ZoneLocalMapping
        nameWithType: ZoneLocalMapping
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping
      VB:
      - id: NodaTime.TimeZones.ZoneLocalMapping
        name: ZoneLocalMapping
        nameWithType: ZoneLocalMapping
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping
    isDefinition: true
    parent: NodaTime.TimeZones
    commentId: T:NodaTime.TimeZones.ZoneLocalMapping
  NodaTime.IDateTimeZoneProvider.GetSystemDefault:
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider.GetSystemDefault
        name: GetSystemDefault
        nameWithType: IDateTimeZoneProvider.GetSystemDefault
        qualifiedName: NodaTime.IDateTimeZoneProvider.GetSystemDefault
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.IDateTimeZoneProvider.GetSystemDefault
        name: GetSystemDefault
        nameWithType: IDateTimeZoneProvider.GetSystemDefault
        qualifiedName: NodaTime.IDateTimeZoneProvider.GetSystemDefault
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.IDateTimeZoneProvider
    commentId: M:NodaTime.IDateTimeZoneProvider.GetSystemDefault
  System.IEquatable{NodaTime.DateTimeZone}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.DateTimeZone}
  NodaTime.DateTimeZone.Utc*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.Utc*
        name: Utc
        nameWithType: DateTimeZone.Utc
        qualifiedName: NodaTime.DateTimeZone.Utc
      VB:
      - id: NodaTime.DateTimeZone.Utc*
        name: Utc
        nameWithType: DateTimeZone.Utc
        qualifiedName: NodaTime.DateTimeZone.Utc
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.Utc
  NodaTime.DateTimeZone.ForOffset*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.ForOffset*
        name: ForOffset
        nameWithType: DateTimeZone.ForOffset
        qualifiedName: NodaTime.DateTimeZone.ForOffset
      VB:
      - id: NodaTime.DateTimeZone.ForOffset*
        name: ForOffset
        nameWithType: DateTimeZone.ForOffset
        qualifiedName: NodaTime.DateTimeZone.ForOffset
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.ForOffset
  NodaTime.DateTimeZone.#ctor*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.#ctor*
        name: DateTimeZone
        nameWithType: DateTimeZone.DateTimeZone
        qualifiedName: NodaTime.DateTimeZone.DateTimeZone
      VB:
      - id: NodaTime.DateTimeZone.#ctor*
        name: DateTimeZone
        nameWithType: DateTimeZone.DateTimeZone
        qualifiedName: NodaTime.DateTimeZone.DateTimeZone
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.#ctor
  NodaTime.DateTimeZone.Id*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.Id*
        name: Id
        nameWithType: DateTimeZone.Id
        qualifiedName: NodaTime.DateTimeZone.Id
      VB:
      - id: NodaTime.DateTimeZone.Id*
        name: Id
        nameWithType: DateTimeZone.Id
        qualifiedName: NodaTime.DateTimeZone.Id
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.Id
  NodaTime.DateTimeZone.MinOffset*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.MinOffset*
        name: MinOffset
        nameWithType: DateTimeZone.MinOffset
        qualifiedName: NodaTime.DateTimeZone.MinOffset
      VB:
      - id: NodaTime.DateTimeZone.MinOffset*
        name: MinOffset
        nameWithType: DateTimeZone.MinOffset
        qualifiedName: NodaTime.DateTimeZone.MinOffset
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.MinOffset
  NodaTime.DateTimeZone.MaxOffset*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.MaxOffset*
        name: MaxOffset
        nameWithType: DateTimeZone.MaxOffset
        qualifiedName: NodaTime.DateTimeZone.MaxOffset
      VB:
      - id: NodaTime.DateTimeZone.MaxOffset*
        name: MaxOffset
        nameWithType: DateTimeZone.MaxOffset
        qualifiedName: NodaTime.DateTimeZone.MaxOffset
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.MaxOffset
  NodaTime.DateTimeZone.GetUtcOffset*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.GetUtcOffset*
        name: GetUtcOffset
        nameWithType: DateTimeZone.GetUtcOffset
        qualifiedName: NodaTime.DateTimeZone.GetUtcOffset
      VB:
      - id: NodaTime.DateTimeZone.GetUtcOffset*
        name: GetUtcOffset
        nameWithType: DateTimeZone.GetUtcOffset
        qualifiedName: NodaTime.DateTimeZone.GetUtcOffset
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.GetUtcOffset
  NodaTime.TimeZones.ZoneInterval:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval
        name: ZoneInterval
        nameWithType: ZoneInterval
        qualifiedName: NodaTime.TimeZones.ZoneInterval
      VB:
      - id: NodaTime.TimeZones.ZoneInterval
        name: ZoneInterval
        nameWithType: ZoneInterval
        qualifiedName: NodaTime.TimeZones.ZoneInterval
    isDefinition: true
    parent: NodaTime.TimeZones
    commentId: T:NodaTime.TimeZones.ZoneInterval
  NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)
        name: GetZoneIntervals
        nameWithType: DateTimeZone.GetZoneIntervals
        qualifiedName: NodaTime.DateTimeZone.GetZoneIntervals
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Interval
        name: Interval
        nameWithType: Interval
        qualifiedName: NodaTime.Interval
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)
        name: GetZoneIntervals
        nameWithType: DateTimeZone.GetZoneIntervals
        qualifiedName: NodaTime.DateTimeZone.GetZoneIntervals
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Interval
        name: Interval
        nameWithType: Interval
        qualifiedName: NodaTime.Interval
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)
  NodaTime.DateTimeZone.GetZoneInterval*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.GetZoneInterval*
        name: GetZoneInterval
        nameWithType: DateTimeZone.GetZoneInterval
        qualifiedName: NodaTime.DateTimeZone.GetZoneInterval
      VB:
      - id: NodaTime.DateTimeZone.GetZoneInterval*
        name: GetZoneInterval
        nameWithType: DateTimeZone.GetZoneInterval
        qualifiedName: NodaTime.DateTimeZone.GetZoneInterval
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.GetZoneInterval
  NodaTime.DateTimeZone.AtStartOfDay*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.AtStartOfDay*
        name: AtStartOfDay
        nameWithType: DateTimeZone.AtStartOfDay
        qualifiedName: NodaTime.DateTimeZone.AtStartOfDay
      VB:
      - id: NodaTime.DateTimeZone.AtStartOfDay*
        name: AtStartOfDay
        nameWithType: DateTimeZone.AtStartOfDay
        qualifiedName: NodaTime.DateTimeZone.AtStartOfDay
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.AtStartOfDay
  NodaTime.DateTimeZone.MapLocal*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.MapLocal*
        name: MapLocal
        nameWithType: DateTimeZone.MapLocal
        qualifiedName: NodaTime.DateTimeZone.MapLocal
      VB:
      - id: NodaTime.DateTimeZone.MapLocal*
        name: MapLocal
        nameWithType: DateTimeZone.MapLocal
        qualifiedName: NodaTime.DateTimeZone.MapLocal
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.MapLocal
  NodaTime.TimeZones.Resolvers:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Resolvers
        name: Resolvers
        nameWithType: Resolvers
        qualifiedName: NodaTime.TimeZones.Resolvers
      VB:
      - id: NodaTime.TimeZones.Resolvers
        name: Resolvers
        nameWithType: Resolvers
        qualifiedName: NodaTime.TimeZones.Resolvers
    isDefinition: true
    commentId: T:NodaTime.TimeZones.Resolvers
  NodaTime.DateTimeZone.ResolveLocal*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.ResolveLocal*
        name: ResolveLocal
        nameWithType: DateTimeZone.ResolveLocal
        qualifiedName: NodaTime.DateTimeZone.ResolveLocal
      VB:
      - id: NodaTime.DateTimeZone.ResolveLocal*
        name: ResolveLocal
        nameWithType: DateTimeZone.ResolveLocal
        qualifiedName: NodaTime.DateTimeZone.ResolveLocal
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.ResolveLocal
  NodaTime.DateTimeZone.AtStrictly*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.AtStrictly*
        name: AtStrictly
        nameWithType: DateTimeZone.AtStrictly
        qualifiedName: NodaTime.DateTimeZone.AtStrictly
      VB:
      - id: NodaTime.DateTimeZone.AtStrictly*
        name: AtStrictly
        nameWithType: DateTimeZone.AtStrictly
        qualifiedName: NodaTime.DateTimeZone.AtStrictly
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.AtStrictly
  NodaTime.DateTimeZone.AtLeniently*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.AtLeniently*
        name: AtLeniently
        nameWithType: DateTimeZone.AtLeniently
        qualifiedName: NodaTime.DateTimeZone.AtLeniently
      VB:
      - id: NodaTime.DateTimeZone.AtLeniently*
        name: AtLeniently
        nameWithType: DateTimeZone.AtLeniently
        qualifiedName: NodaTime.DateTimeZone.AtLeniently
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.AtLeniently
  NodaTime.DateTimeZone.ToString*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.ToString*
        name: ToString
        nameWithType: DateTimeZone.ToString
        qualifiedName: NodaTime.DateTimeZone.ToString
      VB:
      - id: NodaTime.DateTimeZone.ToString*
        name: ToString
        nameWithType: DateTimeZone.ToString
        qualifiedName: NodaTime.DateTimeZone.ToString
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.ToString
  NodaTime.DateTimeZone.Equals*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.Equals*
        name: Equals
        nameWithType: DateTimeZone.Equals
        qualifiedName: NodaTime.DateTimeZone.Equals
      VB:
      - id: NodaTime.DateTimeZone.Equals*
        name: Equals
        nameWithType: DateTimeZone.Equals
        qualifiedName: NodaTime.DateTimeZone.Equals
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.Equals
  NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
        name: EqualsImpl
        nameWithType: DateTimeZone.EqualsImpl
        qualifiedName: NodaTime.DateTimeZone.EqualsImpl
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
        name: EqualsImpl
        nameWithType: DateTimeZone.EqualsImpl
        qualifiedName: NodaTime.DateTimeZone.EqualsImpl
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)
  System.IEquatable{NodaTime.DateTimeZone}.Equals(NodaTime.DateTimeZone):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<DateTimeZone>.Equals
        qualifiedName: System.IEquatable<NodaTime.DateTimeZone>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of DateTimeZone).Equals
        qualifiedName: System.IEquatable(Of NodaTime.DateTimeZone).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.DateTimeZone}
    commentId: M:System.IEquatable{NodaTime.DateTimeZone}.Equals(NodaTime.DateTimeZone)
  NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)
        name: Equals
        nameWithType: DateTimeZone.Equals
        qualifiedName: NodaTime.DateTimeZone.Equals
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)
        name: Equals
        nameWithType: DateTimeZone.Equals
        qualifiedName: NodaTime.DateTimeZone.Equals
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)
  NodaTime.DateTimeZone.EqualsImpl*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.EqualsImpl*
        name: EqualsImpl
        nameWithType: DateTimeZone.EqualsImpl
        qualifiedName: NodaTime.DateTimeZone.EqualsImpl
      VB:
      - id: NodaTime.DateTimeZone.EqualsImpl*
        name: EqualsImpl
        nameWithType: DateTimeZone.EqualsImpl
        qualifiedName: NodaTime.DateTimeZone.EqualsImpl
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.EqualsImpl
  NodaTime.DateTimeZone.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.GetHashCode*
        name: GetHashCode
        nameWithType: DateTimeZone.GetHashCode
        qualifiedName: NodaTime.DateTimeZone.GetHashCode
      VB:
      - id: NodaTime.DateTimeZone.GetHashCode*
        name: GetHashCode
        nameWithType: DateTimeZone.GetHashCode
        qualifiedName: NodaTime.DateTimeZone.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.GetHashCode
  NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
        name: GetZoneInterval
        nameWithType: DateTimeZone.GetZoneInterval
        qualifiedName: NodaTime.DateTimeZone.GetZoneInterval
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
        name: GetZoneInterval
        nameWithType: DateTimeZone.GetZoneInterval
        qualifiedName: NodaTime.DateTimeZone.GetZoneInterval
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)
  System.Collections.Generic.IEnumerable{NodaTime.TimeZones.ZoneInterval}:
    name:
      CSharp:
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.TimeZones.ZoneInterval
        name: ZoneInterval
        nameWithType: ZoneInterval
        qualifiedName: NodaTime.TimeZones.ZoneInterval
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.TimeZones.ZoneInterval
        name: ZoneInterval
        nameWithType: ZoneInterval
        qualifiedName: NodaTime.TimeZones.ZoneInterval
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IEnumerable`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IEnumerable{NodaTime.TimeZones.ZoneInterval}
  NodaTime.DateTimeZone.GetZoneIntervals*:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.GetZoneIntervals*
        name: GetZoneIntervals
        nameWithType: DateTimeZone.GetZoneIntervals
        qualifiedName: NodaTime.DateTimeZone.GetZoneIntervals
      VB:
      - id: NodaTime.DateTimeZone.GetZoneIntervals*
        name: GetZoneIntervals
        nameWithType: DateTimeZone.GetZoneIntervals
        qualifiedName: NodaTime.DateTimeZone.GetZoneIntervals
    isDefinition: true
    commentId: Overload:NodaTime.DateTimeZone.GetZoneIntervals
  NodaTime.Interval:
    name:
      CSharp:
      - id: NodaTime.Interval
        name: Interval
        nameWithType: Interval
        qualifiedName: NodaTime.Interval
      VB:
      - id: NodaTime.Interval
        name: Interval
        nameWithType: Interval
        qualifiedName: NodaTime.Interval
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.Interval
  System.IEquatable{NodaTime.Duration}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.Duration}
  System.IComparable{NodaTime.Duration}:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1
    parent: System
    commentId: T:System.IComparable{NodaTime.Duration}
  NodaTime.Duration.Ticks*:
    name:
      CSharp:
      - id: NodaTime.Duration.Ticks*
        name: Ticks
        nameWithType: Duration.Ticks
        qualifiedName: NodaTime.Duration.Ticks
      VB:
      - id: NodaTime.Duration.Ticks*
        name: Ticks
        nameWithType: Duration.Ticks
        qualifiedName: NodaTime.Duration.Ticks
    isDefinition: true
    commentId: Overload:NodaTime.Duration.Ticks
  NodaTime.Duration.Equals*:
    name:
      CSharp:
      - id: NodaTime.Duration.Equals*
        name: Equals
        nameWithType: Duration.Equals
        qualifiedName: NodaTime.Duration.Equals
      VB:
      - id: NodaTime.Duration.Equals*
        name: Equals
        nameWithType: Duration.Equals
        qualifiedName: NodaTime.Duration.Equals
    isDefinition: true
    commentId: Overload:NodaTime.Duration.Equals
  NodaTime.Duration.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.Duration.GetHashCode*
        name: GetHashCode
        nameWithType: Duration.GetHashCode
        qualifiedName: NodaTime.Duration.GetHashCode
      VB:
      - id: NodaTime.Duration.GetHashCode*
        name: GetHashCode
        nameWithType: Duration.GetHashCode
        qualifiedName: NodaTime.Duration.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.Duration.GetHashCode
  NodaTime.Duration.ToString*:
    name:
      CSharp:
      - id: NodaTime.Duration.ToString*
        name: ToString
        nameWithType: Duration.ToString
        qualifiedName: NodaTime.Duration.ToString
      VB:
      - id: NodaTime.Duration.ToString*
        name: ToString
        nameWithType: Duration.ToString
        qualifiedName: NodaTime.Duration.ToString
    isDefinition: true
    commentId: Overload:NodaTime.Duration.ToString
  NodaTime.Duration.op_Addition*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_Addition*
        name: Addition
        nameWithType: Duration.Addition
        qualifiedName: NodaTime.Duration.Addition
      VB:
      - id: NodaTime.Duration.op_Addition*
        name: Addition
        nameWithType: Duration.Addition
        qualifiedName: NodaTime.Duration.Addition
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_Addition
  NodaTime.Duration.Add*:
    name:
      CSharp:
      - id: NodaTime.Duration.Add*
        name: Add
        nameWithType: Duration.Add
        qualifiedName: NodaTime.Duration.Add
      VB:
      - id: NodaTime.Duration.Add*
        name: Add
        nameWithType: Duration.Add
        qualifiedName: NodaTime.Duration.Add
    isDefinition: true
    commentId: Overload:NodaTime.Duration.Add
  NodaTime.Duration.Plus*:
    name:
      CSharp:
      - id: NodaTime.Duration.Plus*
        name: Plus
        nameWithType: Duration.Plus
        qualifiedName: NodaTime.Duration.Plus
      VB:
      - id: NodaTime.Duration.Plus*
        name: Plus
        nameWithType: Duration.Plus
        qualifiedName: NodaTime.Duration.Plus
    isDefinition: true
    commentId: Overload:NodaTime.Duration.Plus
  NodaTime.Duration.op_Subtraction*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_Subtraction*
        name: Subtraction
        nameWithType: Duration.Subtraction
        qualifiedName: NodaTime.Duration.Subtraction
      VB:
      - id: NodaTime.Duration.op_Subtraction*
        name: Subtraction
        nameWithType: Duration.Subtraction
        qualifiedName: NodaTime.Duration.Subtraction
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_Subtraction
  NodaTime.Duration.Subtract*:
    name:
      CSharp:
      - id: NodaTime.Duration.Subtract*
        name: Subtract
        nameWithType: Duration.Subtract
        qualifiedName: NodaTime.Duration.Subtract
      VB:
      - id: NodaTime.Duration.Subtract*
        name: Subtract
        nameWithType: Duration.Subtract
        qualifiedName: NodaTime.Duration.Subtract
    isDefinition: true
    commentId: Overload:NodaTime.Duration.Subtract
  NodaTime.Duration.Minus*:
    name:
      CSharp:
      - id: NodaTime.Duration.Minus*
        name: Minus
        nameWithType: Duration.Minus
        qualifiedName: NodaTime.Duration.Minus
      VB:
      - id: NodaTime.Duration.Minus*
        name: Minus
        nameWithType: Duration.Minus
        qualifiedName: NodaTime.Duration.Minus
    isDefinition: true
    commentId: Overload:NodaTime.Duration.Minus
  NodaTime.Duration.op_Division*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_Division*
        name: Division
        nameWithType: Duration.Division
        qualifiedName: NodaTime.Duration.Division
      VB:
      - id: NodaTime.Duration.op_Division*
        name: Division
        nameWithType: Duration.Division
        qualifiedName: NodaTime.Duration.Division
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_Division
  NodaTime.Duration.Divide*:
    name:
      CSharp:
      - id: NodaTime.Duration.Divide*
        name: Divide
        nameWithType: Duration.Divide
        qualifiedName: NodaTime.Duration.Divide
      VB:
      - id: NodaTime.Duration.Divide*
        name: Divide
        nameWithType: Duration.Divide
        qualifiedName: NodaTime.Duration.Divide
    isDefinition: true
    commentId: Overload:NodaTime.Duration.Divide
  NodaTime.Duration.op_Multiply*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_Multiply*
        name: Multiply
        nameWithType: Duration.Multiply
        qualifiedName: NodaTime.Duration.Multiply
      VB:
      - id: NodaTime.Duration.op_Multiply*
        name: Multiply
        nameWithType: Duration.Multiply
        qualifiedName: NodaTime.Duration.Multiply
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_Multiply
  NodaTime.Duration.Multiply*:
    name:
      CSharp:
      - id: NodaTime.Duration.Multiply*
        name: Multiply
        nameWithType: Duration.Multiply
        qualifiedName: NodaTime.Duration.Multiply
      VB:
      - id: NodaTime.Duration.Multiply*
        name: Multiply
        nameWithType: Duration.Multiply
        qualifiedName: NodaTime.Duration.Multiply
    isDefinition: true
    commentId: Overload:NodaTime.Duration.Multiply
  NodaTime.Duration.op_Equality*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_Equality*
        name: Equality
        nameWithType: Duration.Equality
        qualifiedName: NodaTime.Duration.Equality
      VB:
      - id: NodaTime.Duration.op_Equality*
        name: Equality
        nameWithType: Duration.Equality
        qualifiedName: NodaTime.Duration.Equality
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_Equality
  NodaTime.Duration.op_Inequality*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_Inequality*
        name: Inequality
        nameWithType: Duration.Inequality
        qualifiedName: NodaTime.Duration.Inequality
      VB:
      - id: NodaTime.Duration.op_Inequality*
        name: Inequality
        nameWithType: Duration.Inequality
        qualifiedName: NodaTime.Duration.Inequality
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_Inequality
  NodaTime.Duration.op_LessThan*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_LessThan*
        name: LessThan
        nameWithType: Duration.LessThan
        qualifiedName: NodaTime.Duration.LessThan
      VB:
      - id: NodaTime.Duration.op_LessThan*
        name: LessThan
        nameWithType: Duration.LessThan
        qualifiedName: NodaTime.Duration.LessThan
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_LessThan
  NodaTime.Duration.op_LessThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: Duration.LessThanOrEqual
        qualifiedName: NodaTime.Duration.LessThanOrEqual
      VB:
      - id: NodaTime.Duration.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: Duration.LessThanOrEqual
        qualifiedName: NodaTime.Duration.LessThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_LessThanOrEqual
  NodaTime.Duration.op_GreaterThan*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_GreaterThan*
        name: GreaterThan
        nameWithType: Duration.GreaterThan
        qualifiedName: NodaTime.Duration.GreaterThan
      VB:
      - id: NodaTime.Duration.op_GreaterThan*
        name: GreaterThan
        nameWithType: Duration.GreaterThan
        qualifiedName: NodaTime.Duration.GreaterThan
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_GreaterThan
  NodaTime.Duration.op_GreaterThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: Duration.GreaterThanOrEqual
        qualifiedName: NodaTime.Duration.GreaterThanOrEqual
      VB:
      - id: NodaTime.Duration.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: Duration.GreaterThanOrEqual
        qualifiedName: NodaTime.Duration.GreaterThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_GreaterThanOrEqual
  NodaTime.Duration.op_UnaryNegation*:
    name:
      CSharp:
      - id: NodaTime.Duration.op_UnaryNegation*
        name: UnaryNegation
        nameWithType: Duration.UnaryNegation
        qualifiedName: NodaTime.Duration.UnaryNegation
      VB:
      - id: NodaTime.Duration.op_UnaryNegation*
        name: UnaryNegation
        nameWithType: Duration.UnaryNegation
        qualifiedName: NodaTime.Duration.UnaryNegation
    isDefinition: true
    commentId: Overload:NodaTime.Duration.op_UnaryNegation
  NodaTime.Duration.Negate*:
    name:
      CSharp:
      - id: NodaTime.Duration.Negate*
        name: Negate
        nameWithType: Duration.Negate
        qualifiedName: NodaTime.Duration.Negate
      VB:
      - id: NodaTime.Duration.Negate*
        name: Negate
        nameWithType: Duration.Negate
        qualifiedName: NodaTime.Duration.Negate
    isDefinition: true
    commentId: Overload:NodaTime.Duration.Negate
  NodaTime.Duration.CompareTo*:
    name:
      CSharp:
      - id: NodaTime.Duration.CompareTo*
        name: CompareTo
        nameWithType: Duration.CompareTo
        qualifiedName: NodaTime.Duration.CompareTo
      VB:
      - id: NodaTime.Duration.CompareTo*
        name: CompareTo
        nameWithType: Duration.CompareTo
        qualifiedName: NodaTime.Duration.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.Duration.CompareTo
  System.IComparable{NodaTime.Duration}.CompareTo(NodaTime.Duration):
    name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<Duration>.CompareTo
        qualifiedName: System.IComparable<NodaTime.Duration>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of Duration).CompareTo
        qualifiedName: System.IComparable(Of NodaTime.Duration).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1.CompareTo(`0)
    parent: System.IComparable{NodaTime.Duration}
    commentId: M:System.IComparable{NodaTime.Duration}.CompareTo(NodaTime.Duration)
  NodaTime.Duration.CompareTo(NodaTime.Duration):
    commentId: M:NodaTime.Duration.CompareTo(NodaTime.Duration)
  NodaTime.Duration.System#IComparable#CompareTo*:
    name:
      CSharp:
      - id: NodaTime.Duration.System#IComparable#CompareTo*
        name: IComparable.CompareTo
        nameWithType: Duration.IComparable.CompareTo
        qualifiedName: NodaTime.Duration.System.IComparable.CompareTo
      VB:
      - id: NodaTime.Duration.System#IComparable#CompareTo*
        name: System.IComparable.CompareTo
        nameWithType: Duration.System.IComparable.CompareTo
        qualifiedName: NodaTime.Duration.System.IComparable.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.Duration.System#IComparable#CompareTo
  System.IEquatable{NodaTime.Duration}.Equals(NodaTime.Duration):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<Duration>.Equals
        qualifiedName: System.IEquatable<NodaTime.Duration>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of Duration).Equals
        qualifiedName: System.IEquatable(Of NodaTime.Duration).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.Duration}
    commentId: M:System.IEquatable{NodaTime.Duration}.Equals(NodaTime.Duration)
  NodaTime.Duration.FromStandardWeeks*:
    name:
      CSharp:
      - id: NodaTime.Duration.FromStandardWeeks*
        name: FromStandardWeeks
        nameWithType: Duration.FromStandardWeeks
        qualifiedName: NodaTime.Duration.FromStandardWeeks
      VB:
      - id: NodaTime.Duration.FromStandardWeeks*
        name: FromStandardWeeks
        nameWithType: Duration.FromStandardWeeks
        qualifiedName: NodaTime.Duration.FromStandardWeeks
    isDefinition: true
    commentId: Overload:NodaTime.Duration.FromStandardWeeks
  NodaTime.Duration.FromStandardDays*:
    name:
      CSharp:
      - id: NodaTime.Duration.FromStandardDays*
        name: FromStandardDays
        nameWithType: Duration.FromStandardDays
        qualifiedName: NodaTime.Duration.FromStandardDays
      VB:
      - id: NodaTime.Duration.FromStandardDays*
        name: FromStandardDays
        nameWithType: Duration.FromStandardDays
        qualifiedName: NodaTime.Duration.FromStandardDays
    isDefinition: true
    commentId: Overload:NodaTime.Duration.FromStandardDays
  NodaTime.Duration.FromHours*:
    name:
      CSharp:
      - id: NodaTime.Duration.FromHours*
        name: FromHours
        nameWithType: Duration.FromHours
        qualifiedName: NodaTime.Duration.FromHours
      VB:
      - id: NodaTime.Duration.FromHours*
        name: FromHours
        nameWithType: Duration.FromHours
        qualifiedName: NodaTime.Duration.FromHours
    isDefinition: true
    commentId: Overload:NodaTime.Duration.FromHours
  NodaTime.Duration.FromMinutes*:
    name:
      CSharp:
      - id: NodaTime.Duration.FromMinutes*
        name: FromMinutes
        nameWithType: Duration.FromMinutes
        qualifiedName: NodaTime.Duration.FromMinutes
      VB:
      - id: NodaTime.Duration.FromMinutes*
        name: FromMinutes
        nameWithType: Duration.FromMinutes
        qualifiedName: NodaTime.Duration.FromMinutes
    isDefinition: true
    commentId: Overload:NodaTime.Duration.FromMinutes
  NodaTime.Duration.FromSeconds*:
    name:
      CSharp:
      - id: NodaTime.Duration.FromSeconds*
        name: FromSeconds
        nameWithType: Duration.FromSeconds
        qualifiedName: NodaTime.Duration.FromSeconds
      VB:
      - id: NodaTime.Duration.FromSeconds*
        name: FromSeconds
        nameWithType: Duration.FromSeconds
        qualifiedName: NodaTime.Duration.FromSeconds
    isDefinition: true
    commentId: Overload:NodaTime.Duration.FromSeconds
  NodaTime.Duration.FromMilliseconds*:
    name:
      CSharp:
      - id: NodaTime.Duration.FromMilliseconds*
        name: FromMilliseconds
        nameWithType: Duration.FromMilliseconds
        qualifiedName: NodaTime.Duration.FromMilliseconds
      VB:
      - id: NodaTime.Duration.FromMilliseconds*
        name: FromMilliseconds
        nameWithType: Duration.FromMilliseconds
        qualifiedName: NodaTime.Duration.FromMilliseconds
    isDefinition: true
    commentId: Overload:NodaTime.Duration.FromMilliseconds
  NodaTime.Duration.FromTicks*:
    name:
      CSharp:
      - id: NodaTime.Duration.FromTicks*
        name: FromTicks
        nameWithType: Duration.FromTicks
        qualifiedName: NodaTime.Duration.FromTicks
      VB:
      - id: NodaTime.Duration.FromTicks*
        name: FromTicks
        nameWithType: Duration.FromTicks
        qualifiedName: NodaTime.Duration.FromTicks
    isDefinition: true
    commentId: Overload:NodaTime.Duration.FromTicks
  NodaTime.Duration.FromTimeSpan*:
    name:
      CSharp:
      - id: NodaTime.Duration.FromTimeSpan*
        name: FromTimeSpan
        nameWithType: Duration.FromTimeSpan
        qualifiedName: NodaTime.Duration.FromTimeSpan
      VB:
      - id: NodaTime.Duration.FromTimeSpan*
        name: FromTimeSpan
        nameWithType: Duration.FromTimeSpan
        qualifiedName: NodaTime.Duration.FromTimeSpan
    isDefinition: true
    commentId: Overload:NodaTime.Duration.FromTimeSpan
  NodaTime.Duration.ToTimeSpan*:
    name:
      CSharp:
      - id: NodaTime.Duration.ToTimeSpan*
        name: ToTimeSpan
        nameWithType: Duration.ToTimeSpan
        qualifiedName: NodaTime.Duration.ToTimeSpan
      VB:
      - id: NodaTime.Duration.ToTimeSpan*
        name: ToTimeSpan
        nameWithType: Duration.ToTimeSpan
        qualifiedName: NodaTime.Duration.ToTimeSpan
    isDefinition: true
    commentId: Overload:NodaTime.Duration.ToTimeSpan
  NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#GetSchema*:
    name:
      CSharp:
      - id: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: IXmlSerializable.GetSchema
        nameWithType: Duration.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.GetSchema
      VB:
      - id: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: System.Xml.Serialization.IXmlSerializable.GetSchema
        nameWithType: Duration.System.Xml.Serialization.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.GetSchema
    isDefinition: true
    commentId: Overload:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#GetSchema
  NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#ReadXml*:
    name:
      CSharp:
      - id: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: IXmlSerializable.ReadXml
        nameWithType: Duration.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.ReadXml
      VB:
      - id: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: System.Xml.Serialization.IXmlSerializable.ReadXml
        nameWithType: Duration.System.Xml.Serialization.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.ReadXml
    isDefinition: true
    commentId: Overload:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#ReadXml
  NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#WriteXml*:
    name:
      CSharp:
      - id: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: IXmlSerializable.WriteXml
        nameWithType: Duration.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.WriteXml
      VB:
      - id: NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: System.Xml.Serialization.IXmlSerializable.WriteXml
        nameWithType: Duration.System.Xml.Serialization.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.Duration.System.Xml.Serialization.IXmlSerializable.WriteXml
    isDefinition: true
    commentId: Overload:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#WriteXml
  NodaTime.Duration.System#Runtime#Serialization#ISerializable#GetObjectData*:
    name:
      CSharp:
      - id: NodaTime.Duration.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: ISerializable.GetObjectData
        nameWithType: Duration.ISerializable.GetObjectData
        qualifiedName: NodaTime.Duration.System.Runtime.Serialization.ISerializable.GetObjectData
      VB:
      - id: NodaTime.Duration.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: System.Runtime.Serialization.ISerializable.GetObjectData
        nameWithType: Duration.System.Runtime.Serialization.ISerializable.GetObjectData
        qualifiedName: NodaTime.Duration.System.Runtime.Serialization.ISerializable.GetObjectData
    isDefinition: true
    commentId: Overload:NodaTime.Duration.System#Runtime#Serialization#ISerializable#GetObjectData
  System.IEquatable{NodaTime.Instant}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.Instant}
  System.IComparable{NodaTime.Instant}:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1
    parent: System
    commentId: T:System.IComparable{NodaTime.Instant}
  NodaTime.Instant.FromDateTimeUtc(System.DateTime):
    commentId: M:NodaTime.Instant.FromDateTimeUtc(System.DateTime)
  NodaTime.Instant.#ctor*:
    name:
      CSharp:
      - id: NodaTime.Instant.#ctor*
        name: Instant
        nameWithType: Instant.Instant
        qualifiedName: NodaTime.Instant.Instant
      VB:
      - id: NodaTime.Instant.#ctor*
        name: Instant
        nameWithType: Instant.Instant
        qualifiedName: NodaTime.Instant.Instant
    isDefinition: true
    commentId: Overload:NodaTime.Instant.#ctor
  NodaTime.Instant.Ticks*:
    name:
      CSharp:
      - id: NodaTime.Instant.Ticks*
        name: Ticks
        nameWithType: Instant.Ticks
        qualifiedName: NodaTime.Instant.Ticks
      VB:
      - id: NodaTime.Instant.Ticks*
        name: Ticks
        nameWithType: Instant.Ticks
        qualifiedName: NodaTime.Instant.Ticks
    isDefinition: true
    commentId: Overload:NodaTime.Instant.Ticks
  NodaTime.Instant.CompareTo*:
    name:
      CSharp:
      - id: NodaTime.Instant.CompareTo*
        name: CompareTo
        nameWithType: Instant.CompareTo
        qualifiedName: NodaTime.Instant.CompareTo
      VB:
      - id: NodaTime.Instant.CompareTo*
        name: CompareTo
        nameWithType: Instant.CompareTo
        qualifiedName: NodaTime.Instant.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.Instant.CompareTo
  System.IComparable{NodaTime.Instant}.CompareTo(NodaTime.Instant):
    name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<Instant>.CompareTo
        qualifiedName: System.IComparable<NodaTime.Instant>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of Instant).CompareTo
        qualifiedName: System.IComparable(Of NodaTime.Instant).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1.CompareTo(`0)
    parent: System.IComparable{NodaTime.Instant}
    commentId: M:System.IComparable{NodaTime.Instant}.CompareTo(NodaTime.Instant)
  NodaTime.Instant.CompareTo(NodaTime.Instant):
    commentId: M:NodaTime.Instant.CompareTo(NodaTime.Instant)
  NodaTime.Instant.System#IComparable#CompareTo*:
    name:
      CSharp:
      - id: NodaTime.Instant.System#IComparable#CompareTo*
        name: IComparable.CompareTo
        nameWithType: Instant.IComparable.CompareTo
        qualifiedName: NodaTime.Instant.System.IComparable.CompareTo
      VB:
      - id: NodaTime.Instant.System#IComparable#CompareTo*
        name: System.IComparable.CompareTo
        nameWithType: Instant.System.IComparable.CompareTo
        qualifiedName: NodaTime.Instant.System.IComparable.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.Instant.System#IComparable#CompareTo
  NodaTime.Instant.Equals*:
    name:
      CSharp:
      - id: NodaTime.Instant.Equals*
        name: Equals
        nameWithType: Instant.Equals
        qualifiedName: NodaTime.Instant.Equals
      VB:
      - id: NodaTime.Instant.Equals*
        name: Equals
        nameWithType: Instant.Equals
        qualifiedName: NodaTime.Instant.Equals
    isDefinition: true
    commentId: Overload:NodaTime.Instant.Equals
  NodaTime.Instant.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.Instant.GetHashCode*
        name: GetHashCode
        nameWithType: Instant.GetHashCode
        qualifiedName: NodaTime.Instant.GetHashCode
      VB:
      - id: NodaTime.Instant.GetHashCode*
        name: GetHashCode
        nameWithType: Instant.GetHashCode
        qualifiedName: NodaTime.Instant.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.Instant.GetHashCode
  NodaTime.Instant.PlusTicks*:
    name:
      CSharp:
      - id: NodaTime.Instant.PlusTicks*
        name: PlusTicks
        nameWithType: Instant.PlusTicks
        qualifiedName: NodaTime.Instant.PlusTicks
      VB:
      - id: NodaTime.Instant.PlusTicks*
        name: PlusTicks
        nameWithType: Instant.PlusTicks
        qualifiedName: NodaTime.Instant.PlusTicks
    isDefinition: true
    commentId: Overload:NodaTime.Instant.PlusTicks
  NodaTime.Instant.op_Addition*:
    name:
      CSharp:
      - id: NodaTime.Instant.op_Addition*
        name: Addition
        nameWithType: Instant.Addition
        qualifiedName: NodaTime.Instant.Addition
      VB:
      - id: NodaTime.Instant.op_Addition*
        name: Addition
        nameWithType: Instant.Addition
        qualifiedName: NodaTime.Instant.Addition
    isDefinition: true
    commentId: Overload:NodaTime.Instant.op_Addition
  NodaTime.Instant.Add*:
    name:
      CSharp:
      - id: NodaTime.Instant.Add*
        name: Add
        nameWithType: Instant.Add
        qualifiedName: NodaTime.Instant.Add
      VB:
      - id: NodaTime.Instant.Add*
        name: Add
        nameWithType: Instant.Add
        qualifiedName: NodaTime.Instant.Add
    isDefinition: true
    commentId: Overload:NodaTime.Instant.Add
  NodaTime.Instant.Plus*:
    name:
      CSharp:
      - id: NodaTime.Instant.Plus*
        name: Plus
        nameWithType: Instant.Plus
        qualifiedName: NodaTime.Instant.Plus
      VB:
      - id: NodaTime.Instant.Plus*
        name: Plus
        nameWithType: Instant.Plus
        qualifiedName: NodaTime.Instant.Plus
    isDefinition: true
    commentId: Overload:NodaTime.Instant.Plus
  NodaTime.Instant.op_Subtraction*:
    name:
      CSharp:
      - id: NodaTime.Instant.op_Subtraction*
        name: Subtraction
        nameWithType: Instant.Subtraction
        qualifiedName: NodaTime.Instant.Subtraction
      VB:
      - id: NodaTime.Instant.op_Subtraction*
        name: Subtraction
        nameWithType: Instant.Subtraction
        qualifiedName: NodaTime.Instant.Subtraction
    isDefinition: true
    commentId: Overload:NodaTime.Instant.op_Subtraction
  NodaTime.Instant.Subtract*:
    name:
      CSharp:
      - id: NodaTime.Instant.Subtract*
        name: Subtract
        nameWithType: Instant.Subtract
        qualifiedName: NodaTime.Instant.Subtract
      VB:
      - id: NodaTime.Instant.Subtract*
        name: Subtract
        nameWithType: Instant.Subtract
        qualifiedName: NodaTime.Instant.Subtract
    isDefinition: true
    commentId: Overload:NodaTime.Instant.Subtract
  NodaTime.Instant.Minus*:
    name:
      CSharp:
      - id: NodaTime.Instant.Minus*
        name: Minus
        nameWithType: Instant.Minus
        qualifiedName: NodaTime.Instant.Minus
      VB:
      - id: NodaTime.Instant.Minus*
        name: Minus
        nameWithType: Instant.Minus
        qualifiedName: NodaTime.Instant.Minus
    isDefinition: true
    commentId: Overload:NodaTime.Instant.Minus
  NodaTime.Instant.op_Equality*:
    name:
      CSharp:
      - id: NodaTime.Instant.op_Equality*
        name: Equality
        nameWithType: Instant.Equality
        qualifiedName: NodaTime.Instant.Equality
      VB:
      - id: NodaTime.Instant.op_Equality*
        name: Equality
        nameWithType: Instant.Equality
        qualifiedName: NodaTime.Instant.Equality
    isDefinition: true
    commentId: Overload:NodaTime.Instant.op_Equality
  NodaTime.Instant.op_Inequality*:
    name:
      CSharp:
      - id: NodaTime.Instant.op_Inequality*
        name: Inequality
        nameWithType: Instant.Inequality
        qualifiedName: NodaTime.Instant.Inequality
      VB:
      - id: NodaTime.Instant.op_Inequality*
        name: Inequality
        nameWithType: Instant.Inequality
        qualifiedName: NodaTime.Instant.Inequality
    isDefinition: true
    commentId: Overload:NodaTime.Instant.op_Inequality
  NodaTime.Instant.op_LessThan*:
    name:
      CSharp:
      - id: NodaTime.Instant.op_LessThan*
        name: LessThan
        nameWithType: Instant.LessThan
        qualifiedName: NodaTime.Instant.LessThan
      VB:
      - id: NodaTime.Instant.op_LessThan*
        name: LessThan
        nameWithType: Instant.LessThan
        qualifiedName: NodaTime.Instant.LessThan
    isDefinition: true
    commentId: Overload:NodaTime.Instant.op_LessThan
  NodaTime.Instant.op_LessThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.Instant.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: Instant.LessThanOrEqual
        qualifiedName: NodaTime.Instant.LessThanOrEqual
      VB:
      - id: NodaTime.Instant.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: Instant.LessThanOrEqual
        qualifiedName: NodaTime.Instant.LessThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.Instant.op_LessThanOrEqual
  NodaTime.Instant.op_GreaterThan*:
    name:
      CSharp:
      - id: NodaTime.Instant.op_GreaterThan*
        name: GreaterThan
        nameWithType: Instant.GreaterThan
        qualifiedName: NodaTime.Instant.GreaterThan
      VB:
      - id: NodaTime.Instant.op_GreaterThan*
        name: GreaterThan
        nameWithType: Instant.GreaterThan
        qualifiedName: NodaTime.Instant.GreaterThan
    isDefinition: true
    commentId: Overload:NodaTime.Instant.op_GreaterThan
  NodaTime.Instant.op_GreaterThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.Instant.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: Instant.GreaterThanOrEqual
        qualifiedName: NodaTime.Instant.GreaterThanOrEqual
      VB:
      - id: NodaTime.Instant.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: Instant.GreaterThanOrEqual
        qualifiedName: NodaTime.Instant.GreaterThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.Instant.op_GreaterThanOrEqual
  NodaTime.Instant.FromUtc*:
    name:
      CSharp:
      - id: NodaTime.Instant.FromUtc*
        name: FromUtc
        nameWithType: Instant.FromUtc
        qualifiedName: NodaTime.Instant.FromUtc
      VB:
      - id: NodaTime.Instant.FromUtc*
        name: FromUtc
        nameWithType: Instant.FromUtc
        qualifiedName: NodaTime.Instant.FromUtc
    isDefinition: true
    commentId: Overload:NodaTime.Instant.FromUtc
  NodaTime.Instant.Max*:
    name:
      CSharp:
      - id: NodaTime.Instant.Max*
        name: Max
        nameWithType: Instant.Max
        qualifiedName: NodaTime.Instant.Max
      VB:
      - id: NodaTime.Instant.Max*
        name: Max
        nameWithType: Instant.Max
        qualifiedName: NodaTime.Instant.Max
    isDefinition: true
    commentId: Overload:NodaTime.Instant.Max
  NodaTime.Instant.Min*:
    name:
      CSharp:
      - id: NodaTime.Instant.Min*
        name: Min
        nameWithType: Instant.Min
        qualifiedName: NodaTime.Instant.Min
      VB:
      - id: NodaTime.Instant.Min*
        name: Min
        nameWithType: Instant.Min
        qualifiedName: NodaTime.Instant.Min
    isDefinition: true
    commentId: Overload:NodaTime.Instant.Min
  NodaTime.Instant.ToString*:
    name:
      CSharp:
      - id: NodaTime.Instant.ToString*
        name: ToString
        nameWithType: Instant.ToString
        qualifiedName: NodaTime.Instant.ToString
      VB:
      - id: NodaTime.Instant.ToString*
        name: ToString
        nameWithType: Instant.ToString
        qualifiedName: NodaTime.Instant.ToString
    isDefinition: true
    commentId: Overload:NodaTime.Instant.ToString
  System.IEquatable{NodaTime.Instant}.Equals(NodaTime.Instant):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<Instant>.Equals
        qualifiedName: System.IEquatable<NodaTime.Instant>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of Instant).Equals
        qualifiedName: System.IEquatable(Of NodaTime.Instant).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.Instant}
    commentId: M:System.IEquatable{NodaTime.Instant}.Equals(NodaTime.Instant)
  NodaTime.Instant.ToDateTimeUtc*:
    name:
      CSharp:
      - id: NodaTime.Instant.ToDateTimeUtc*
        name: ToDateTimeUtc
        nameWithType: Instant.ToDateTimeUtc
        qualifiedName: NodaTime.Instant.ToDateTimeUtc
      VB:
      - id: NodaTime.Instant.ToDateTimeUtc*
        name: ToDateTimeUtc
        nameWithType: Instant.ToDateTimeUtc
        qualifiedName: NodaTime.Instant.ToDateTimeUtc
    isDefinition: true
    commentId: Overload:NodaTime.Instant.ToDateTimeUtc
  NodaTime.Instant.ToDateTimeOffset*:
    name:
      CSharp:
      - id: NodaTime.Instant.ToDateTimeOffset*
        name: ToDateTimeOffset
        nameWithType: Instant.ToDateTimeOffset
        qualifiedName: NodaTime.Instant.ToDateTimeOffset
      VB:
      - id: NodaTime.Instant.ToDateTimeOffset*
        name: ToDateTimeOffset
        nameWithType: Instant.ToDateTimeOffset
        qualifiedName: NodaTime.Instant.ToDateTimeOffset
    isDefinition: true
    commentId: Overload:NodaTime.Instant.ToDateTimeOffset
  NodaTime.Instant.FromDateTimeOffset*:
    name:
      CSharp:
      - id: NodaTime.Instant.FromDateTimeOffset*
        name: FromDateTimeOffset
        nameWithType: Instant.FromDateTimeOffset
        qualifiedName: NodaTime.Instant.FromDateTimeOffset
      VB:
      - id: NodaTime.Instant.FromDateTimeOffset*
        name: FromDateTimeOffset
        nameWithType: Instant.FromDateTimeOffset
        qualifiedName: NodaTime.Instant.FromDateTimeOffset
    isDefinition: true
    commentId: Overload:NodaTime.Instant.FromDateTimeOffset
  NodaTime.Instant.FromDateTimeUtc*:
    name:
      CSharp:
      - id: NodaTime.Instant.FromDateTimeUtc*
        name: FromDateTimeUtc
        nameWithType: Instant.FromDateTimeUtc
        qualifiedName: NodaTime.Instant.FromDateTimeUtc
      VB:
      - id: NodaTime.Instant.FromDateTimeUtc*
        name: FromDateTimeUtc
        nameWithType: Instant.FromDateTimeUtc
        qualifiedName: NodaTime.Instant.FromDateTimeUtc
    isDefinition: true
    commentId: Overload:NodaTime.Instant.FromDateTimeUtc
  NodaTime.Instant.FromSecondsSinceUnixEpoch*:
    name:
      CSharp:
      - id: NodaTime.Instant.FromSecondsSinceUnixEpoch*
        name: FromSecondsSinceUnixEpoch
        nameWithType: Instant.FromSecondsSinceUnixEpoch
        qualifiedName: NodaTime.Instant.FromSecondsSinceUnixEpoch
      VB:
      - id: NodaTime.Instant.FromSecondsSinceUnixEpoch*
        name: FromSecondsSinceUnixEpoch
        nameWithType: Instant.FromSecondsSinceUnixEpoch
        qualifiedName: NodaTime.Instant.FromSecondsSinceUnixEpoch
    isDefinition: true
    commentId: Overload:NodaTime.Instant.FromSecondsSinceUnixEpoch
  NodaTime.Instant.FromMillisecondsSinceUnixEpoch*:
    name:
      CSharp:
      - id: NodaTime.Instant.FromMillisecondsSinceUnixEpoch*
        name: FromMillisecondsSinceUnixEpoch
        nameWithType: Instant.FromMillisecondsSinceUnixEpoch
        qualifiedName: NodaTime.Instant.FromMillisecondsSinceUnixEpoch
      VB:
      - id: NodaTime.Instant.FromMillisecondsSinceUnixEpoch*
        name: FromMillisecondsSinceUnixEpoch
        nameWithType: Instant.FromMillisecondsSinceUnixEpoch
        qualifiedName: NodaTime.Instant.FromMillisecondsSinceUnixEpoch
    isDefinition: true
    commentId: Overload:NodaTime.Instant.FromMillisecondsSinceUnixEpoch
  NodaTime.Instant.FromTicksSinceUnixEpoch*:
    name:
      CSharp:
      - id: NodaTime.Instant.FromTicksSinceUnixEpoch*
        name: FromTicksSinceUnixEpoch
        nameWithType: Instant.FromTicksSinceUnixEpoch
        qualifiedName: NodaTime.Instant.FromTicksSinceUnixEpoch
      VB:
      - id: NodaTime.Instant.FromTicksSinceUnixEpoch*
        name: FromTicksSinceUnixEpoch
        nameWithType: Instant.FromTicksSinceUnixEpoch
        qualifiedName: NodaTime.Instant.FromTicksSinceUnixEpoch
    isDefinition: true
    commentId: Overload:NodaTime.Instant.FromTicksSinceUnixEpoch
  NodaTime.Instant.InZone(NodaTime.DateTimeZone):
    commentId: M:NodaTime.Instant.InZone(NodaTime.DateTimeZone)
  NodaTime.Instant.InUtc*:
    name:
      CSharp:
      - id: NodaTime.Instant.InUtc*
        name: InUtc
        nameWithType: Instant.InUtc
        qualifiedName: NodaTime.Instant.InUtc
      VB:
      - id: NodaTime.Instant.InUtc*
        name: InUtc
        nameWithType: Instant.InUtc
        qualifiedName: NodaTime.Instant.InUtc
    isDefinition: true
    commentId: Overload:NodaTime.Instant.InUtc
  NodaTime.Instant.InZone*:
    name:
      CSharp:
      - id: NodaTime.Instant.InZone*
        name: InZone
        nameWithType: Instant.InZone
        qualifiedName: NodaTime.Instant.InZone
      VB:
      - id: NodaTime.Instant.InZone*
        name: InZone
        nameWithType: Instant.InZone
        qualifiedName: NodaTime.Instant.InZone
    isDefinition: true
    commentId: Overload:NodaTime.Instant.InZone
  NodaTime.Instant.WithOffset*:
    name:
      CSharp:
      - id: NodaTime.Instant.WithOffset*
        name: WithOffset
        nameWithType: Instant.WithOffset
        qualifiedName: NodaTime.Instant.WithOffset
      VB:
      - id: NodaTime.Instant.WithOffset*
        name: WithOffset
        nameWithType: Instant.WithOffset
        qualifiedName: NodaTime.Instant.WithOffset
    isDefinition: true
    commentId: Overload:NodaTime.Instant.WithOffset
  NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#GetSchema*:
    name:
      CSharp:
      - id: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: IXmlSerializable.GetSchema
        nameWithType: Instant.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.GetSchema
      VB:
      - id: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: System.Xml.Serialization.IXmlSerializable.GetSchema
        nameWithType: Instant.System.Xml.Serialization.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.GetSchema
    isDefinition: true
    commentId: Overload:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#GetSchema
  NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#ReadXml*:
    name:
      CSharp:
      - id: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: IXmlSerializable.ReadXml
        nameWithType: Instant.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.ReadXml
      VB:
      - id: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: System.Xml.Serialization.IXmlSerializable.ReadXml
        nameWithType: Instant.System.Xml.Serialization.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.ReadXml
    isDefinition: true
    commentId: Overload:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#ReadXml
  NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#WriteXml*:
    name:
      CSharp:
      - id: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: IXmlSerializable.WriteXml
        nameWithType: Instant.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.WriteXml
      VB:
      - id: NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: System.Xml.Serialization.IXmlSerializable.WriteXml
        nameWithType: Instant.System.Xml.Serialization.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.Instant.System.Xml.Serialization.IXmlSerializable.WriteXml
    isDefinition: true
    commentId: Overload:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#WriteXml
  NodaTime.Instant.System#Runtime#Serialization#ISerializable#GetObjectData*:
    name:
      CSharp:
      - id: NodaTime.Instant.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: ISerializable.GetObjectData
        nameWithType: Instant.ISerializable.GetObjectData
        qualifiedName: NodaTime.Instant.System.Runtime.Serialization.ISerializable.GetObjectData
      VB:
      - id: NodaTime.Instant.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: System.Runtime.Serialization.ISerializable.GetObjectData
        nameWithType: Instant.System.Runtime.Serialization.ISerializable.GetObjectData
        qualifiedName: NodaTime.Instant.System.Runtime.Serialization.ISerializable.GetObjectData
    isDefinition: true
    commentId: Overload:NodaTime.Instant.System#Runtime#Serialization#ISerializable#GetObjectData
  NodaTime.Instant.MaxValue:
    commentId: F:NodaTime.Instant.MaxValue
  System.IEquatable{NodaTime.Interval}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Interval
        name: Interval
        nameWithType: Interval
        qualifiedName: NodaTime.Interval
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Interval
        name: Interval
        nameWithType: Interval
        qualifiedName: NodaTime.Interval
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.Interval}
  NodaTime.Interval.#ctor*:
    name:
      CSharp:
      - id: NodaTime.Interval.#ctor*
        name: Interval
        nameWithType: Interval.Interval
        qualifiedName: NodaTime.Interval.Interval
      VB:
      - id: NodaTime.Interval.#ctor*
        name: Interval
        nameWithType: Interval.Interval
        qualifiedName: NodaTime.Interval.Interval
    isDefinition: true
    commentId: Overload:NodaTime.Interval.#ctor
  NodaTime.Interval.End:
    commentId: P:NodaTime.Interval.End
  NodaTime.Interval.Start*:
    name:
      CSharp:
      - id: NodaTime.Interval.Start*
        name: Start
        nameWithType: Interval.Start
        qualifiedName: NodaTime.Interval.Start
      VB:
      - id: NodaTime.Interval.Start*
        name: Start
        nameWithType: Interval.Start
        qualifiedName: NodaTime.Interval.Start
    isDefinition: true
    commentId: Overload:NodaTime.Interval.Start
  NodaTime.Interval.Start:
    commentId: P:NodaTime.Interval.Start
  NodaTime.Interval.End*:
    name:
      CSharp:
      - id: NodaTime.Interval.End*
        name: End
        nameWithType: Interval.End
        qualifiedName: NodaTime.Interval.End
      VB:
      - id: NodaTime.Interval.End*
        name: End
        nameWithType: Interval.End
        qualifiedName: NodaTime.Interval.End
    isDefinition: true
    commentId: Overload:NodaTime.Interval.End
  NodaTime.Interval.Duration*:
    name:
      CSharp:
      - id: NodaTime.Interval.Duration*
        name: Duration
        nameWithType: Interval.Duration
        qualifiedName: NodaTime.Interval.Duration
      VB:
      - id: NodaTime.Interval.Duration*
        name: Duration
        nameWithType: Interval.Duration
        qualifiedName: NodaTime.Interval.Duration
    isDefinition: true
    commentId: Overload:NodaTime.Interval.Duration
  NodaTime.Interval.Contains*:
    name:
      CSharp:
      - id: NodaTime.Interval.Contains*
        name: Contains
        nameWithType: Interval.Contains
        qualifiedName: NodaTime.Interval.Contains
      VB:
      - id: NodaTime.Interval.Contains*
        name: Contains
        nameWithType: Interval.Contains
        qualifiedName: NodaTime.Interval.Contains
    isDefinition: true
    commentId: Overload:NodaTime.Interval.Contains
  NodaTime.Interval.Equals*:
    name:
      CSharp:
      - id: NodaTime.Interval.Equals*
        name: Equals
        nameWithType: Interval.Equals
        qualifiedName: NodaTime.Interval.Equals
      VB:
      - id: NodaTime.Interval.Equals*
        name: Equals
        nameWithType: Interval.Equals
        qualifiedName: NodaTime.Interval.Equals
    isDefinition: true
    commentId: Overload:NodaTime.Interval.Equals
  System.IEquatable{NodaTime.Interval}.Equals(NodaTime.Interval):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<Interval>.Equals
        qualifiedName: System.IEquatable<NodaTime.Interval>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Interval
        name: Interval
        nameWithType: Interval
        qualifiedName: NodaTime.Interval
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of Interval).Equals
        qualifiedName: System.IEquatable(Of NodaTime.Interval).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Interval
        name: Interval
        nameWithType: Interval
        qualifiedName: NodaTime.Interval
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.Interval}
    commentId: M:System.IEquatable{NodaTime.Interval}.Equals(NodaTime.Interval)
  NodaTime.Interval.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.Interval.GetHashCode*
        name: GetHashCode
        nameWithType: Interval.GetHashCode
        qualifiedName: NodaTime.Interval.GetHashCode
      VB:
      - id: NodaTime.Interval.GetHashCode*
        name: GetHashCode
        nameWithType: Interval.GetHashCode
        qualifiedName: NodaTime.Interval.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.Interval.GetHashCode
  NodaTime.Interval.ToString*:
    name:
      CSharp:
      - id: NodaTime.Interval.ToString*
        name: ToString
        nameWithType: Interval.ToString
        qualifiedName: NodaTime.Interval.ToString
      VB:
      - id: NodaTime.Interval.ToString*
        name: ToString
        nameWithType: Interval.ToString
        qualifiedName: NodaTime.Interval.ToString
    isDefinition: true
    commentId: Overload:NodaTime.Interval.ToString
  NodaTime.Interval.op_Equality*:
    name:
      CSharp:
      - id: NodaTime.Interval.op_Equality*
        name: Equality
        nameWithType: Interval.Equality
        qualifiedName: NodaTime.Interval.Equality
      VB:
      - id: NodaTime.Interval.op_Equality*
        name: Equality
        nameWithType: Interval.Equality
        qualifiedName: NodaTime.Interval.Equality
    isDefinition: true
    commentId: Overload:NodaTime.Interval.op_Equality
  NodaTime.Interval.op_Inequality*:
    name:
      CSharp:
      - id: NodaTime.Interval.op_Inequality*
        name: Inequality
        nameWithType: Interval.Inequality
        qualifiedName: NodaTime.Interval.Inequality
      VB:
      - id: NodaTime.Interval.op_Inequality*
        name: Inequality
        nameWithType: Interval.Inequality
        qualifiedName: NodaTime.Interval.Inequality
    isDefinition: true
    commentId: Overload:NodaTime.Interval.op_Inequality
  NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#GetSchema*:
    name:
      CSharp:
      - id: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: IXmlSerializable.GetSchema
        nameWithType: Interval.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.GetSchema
      VB:
      - id: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: System.Xml.Serialization.IXmlSerializable.GetSchema
        nameWithType: Interval.System.Xml.Serialization.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.GetSchema
    isDefinition: true
    commentId: Overload:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#GetSchema
  NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#ReadXml*:
    name:
      CSharp:
      - id: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: IXmlSerializable.ReadXml
        nameWithType: Interval.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.ReadXml
      VB:
      - id: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: System.Xml.Serialization.IXmlSerializable.ReadXml
        nameWithType: Interval.System.Xml.Serialization.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.ReadXml
    isDefinition: true
    commentId: Overload:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#ReadXml
  NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#WriteXml*:
    name:
      CSharp:
      - id: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: IXmlSerializable.WriteXml
        nameWithType: Interval.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.WriteXml
      VB:
      - id: NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: System.Xml.Serialization.IXmlSerializable.WriteXml
        nameWithType: Interval.System.Xml.Serialization.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.Interval.System.Xml.Serialization.IXmlSerializable.WriteXml
    isDefinition: true
    commentId: Overload:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#WriteXml
  NodaTime.Interval.System#Runtime#Serialization#ISerializable#GetObjectData*:
    name:
      CSharp:
      - id: NodaTime.Interval.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: ISerializable.GetObjectData
        nameWithType: Interval.ISerializable.GetObjectData
        qualifiedName: NodaTime.Interval.System.Runtime.Serialization.ISerializable.GetObjectData
      VB:
      - id: NodaTime.Interval.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: System.Runtime.Serialization.ISerializable.GetObjectData
        nameWithType: Interval.System.Runtime.Serialization.ISerializable.GetObjectData
        qualifiedName: NodaTime.Interval.System.Runtime.Serialization.ISerializable.GetObjectData
    isDefinition: true
    commentId: Overload:NodaTime.Interval.System#Runtime#Serialization#ISerializable#GetObjectData
  NodaTime.Instant.Ticks:
    commentId: P:NodaTime.Instant.Ticks
  NodaTime.NodaConstants:
    name:
      CSharp:
      - id: NodaTime.NodaConstants
        name: NodaConstants
        nameWithType: NodaConstants
        qualifiedName: NodaTime.NodaConstants
      VB:
      - id: NodaTime.NodaConstants
        name: NodaConstants
        nameWithType: NodaConstants
        qualifiedName: NodaTime.NodaConstants
    isDefinition: true
    commentId: T:NodaTime.NodaConstants
  NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime):
    commentId: M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)
  NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime):
    commentId: M:NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
  NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime):
    commentId: M:NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)
  System.IEquatable{NodaTime.ZonedDateTime}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.ZonedDateTime}
  System.IComparable{NodaTime.ZonedDateTime}:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1
    parent: System
    commentId: T:System.IComparable{NodaTime.ZonedDateTime}
  NodaTime.ZonedDateTime.#ctor*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.#ctor*
        name: ZonedDateTime
        nameWithType: ZonedDateTime.ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime.ZonedDateTime
      VB:
      - id: NodaTime.ZonedDateTime.#ctor*
        name: ZonedDateTime
        nameWithType: ZonedDateTime.ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime.ZonedDateTime
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.#ctor
  NodaTime.ZonedDateTime.Offset*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Offset*
        name: Offset
        nameWithType: ZonedDateTime.Offset
        qualifiedName: NodaTime.ZonedDateTime.Offset
      VB:
      - id: NodaTime.ZonedDateTime.Offset*
        name: Offset
        nameWithType: ZonedDateTime.Offset
        qualifiedName: NodaTime.ZonedDateTime.Offset
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Offset
  NodaTime.ZonedDateTime.Zone*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Zone*
        name: Zone
        nameWithType: ZonedDateTime.Zone
        qualifiedName: NodaTime.ZonedDateTime.Zone
      VB:
      - id: NodaTime.ZonedDateTime.Zone*
        name: Zone
        nameWithType: ZonedDateTime.Zone
        qualifiedName: NodaTime.ZonedDateTime.Zone
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Zone
  NodaTime.ZonedDateTime.LocalDateTime*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.LocalDateTime*
        name: LocalDateTime
        nameWithType: ZonedDateTime.LocalDateTime
        qualifiedName: NodaTime.ZonedDateTime.LocalDateTime
      VB:
      - id: NodaTime.ZonedDateTime.LocalDateTime*
        name: LocalDateTime
        nameWithType: ZonedDateTime.LocalDateTime
        qualifiedName: NodaTime.ZonedDateTime.LocalDateTime
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.LocalDateTime
  NodaTime.ZonedDateTime.Calendar*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Calendar*
        name: Calendar
        nameWithType: ZonedDateTime.Calendar
        qualifiedName: NodaTime.ZonedDateTime.Calendar
      VB:
      - id: NodaTime.ZonedDateTime.Calendar*
        name: Calendar
        nameWithType: ZonedDateTime.Calendar
        qualifiedName: NodaTime.ZonedDateTime.Calendar
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Calendar
  NodaTime.ZonedDateTime.Date*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Date*
        name: Date
        nameWithType: ZonedDateTime.Date
        qualifiedName: NodaTime.ZonedDateTime.Date
      VB:
      - id: NodaTime.ZonedDateTime.Date*
        name: Date
        nameWithType: ZonedDateTime.Date
        qualifiedName: NodaTime.ZonedDateTime.Date
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Date
  NodaTime.ZonedDateTime.TimeOfDay*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.TimeOfDay*
        name: TimeOfDay
        nameWithType: ZonedDateTime.TimeOfDay
        qualifiedName: NodaTime.ZonedDateTime.TimeOfDay
      VB:
      - id: NodaTime.ZonedDateTime.TimeOfDay*
        name: TimeOfDay
        nameWithType: ZonedDateTime.TimeOfDay
        qualifiedName: NodaTime.ZonedDateTime.TimeOfDay
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.TimeOfDay
  NodaTime.ZonedDateTime.Era*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Era*
        name: Era
        nameWithType: ZonedDateTime.Era
        qualifiedName: NodaTime.ZonedDateTime.Era
      VB:
      - id: NodaTime.ZonedDateTime.Era*
        name: Era
        nameWithType: ZonedDateTime.Era
        qualifiedName: NodaTime.ZonedDateTime.Era
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Era
  NodaTime.ZonedDateTime.CenturyOfEra*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.CenturyOfEra*
        name: CenturyOfEra
        nameWithType: ZonedDateTime.CenturyOfEra
        qualifiedName: NodaTime.ZonedDateTime.CenturyOfEra
      VB:
      - id: NodaTime.ZonedDateTime.CenturyOfEra*
        name: CenturyOfEra
        nameWithType: ZonedDateTime.CenturyOfEra
        qualifiedName: NodaTime.ZonedDateTime.CenturyOfEra
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.CenturyOfEra
  NodaTime.ZonedDateTime.Year*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Year*
        name: Year
        nameWithType: ZonedDateTime.Year
        qualifiedName: NodaTime.ZonedDateTime.Year
      VB:
      - id: NodaTime.ZonedDateTime.Year*
        name: Year
        nameWithType: ZonedDateTime.Year
        qualifiedName: NodaTime.ZonedDateTime.Year
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Year
  NodaTime.ZonedDateTime.YearOfCentury*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.YearOfCentury*
        name: YearOfCentury
        nameWithType: ZonedDateTime.YearOfCentury
        qualifiedName: NodaTime.ZonedDateTime.YearOfCentury
      VB:
      - id: NodaTime.ZonedDateTime.YearOfCentury*
        name: YearOfCentury
        nameWithType: ZonedDateTime.YearOfCentury
        qualifiedName: NodaTime.ZonedDateTime.YearOfCentury
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.YearOfCentury
  NodaTime.ZonedDateTime.YearOfEra*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.YearOfEra*
        name: YearOfEra
        nameWithType: ZonedDateTime.YearOfEra
        qualifiedName: NodaTime.ZonedDateTime.YearOfEra
      VB:
      - id: NodaTime.ZonedDateTime.YearOfEra*
        name: YearOfEra
        nameWithType: ZonedDateTime.YearOfEra
        qualifiedName: NodaTime.ZonedDateTime.YearOfEra
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.YearOfEra
  NodaTime.ZonedDateTime.WeekOfWeekYear:
    commentId: P:NodaTime.ZonedDateTime.WeekOfWeekYear
  NodaTime.ZonedDateTime.WeekYear*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.WeekYear*
        name: WeekYear
        nameWithType: ZonedDateTime.WeekYear
        qualifiedName: NodaTime.ZonedDateTime.WeekYear
      VB:
      - id: NodaTime.ZonedDateTime.WeekYear*
        name: WeekYear
        nameWithType: ZonedDateTime.WeekYear
        qualifiedName: NodaTime.ZonedDateTime.WeekYear
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.WeekYear
  NodaTime.ZonedDateTime.Month*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Month*
        name: Month
        nameWithType: ZonedDateTime.Month
        qualifiedName: NodaTime.ZonedDateTime.Month
      VB:
      - id: NodaTime.ZonedDateTime.Month*
        name: Month
        nameWithType: ZonedDateTime.Month
        qualifiedName: NodaTime.ZonedDateTime.Month
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Month
  NodaTime.ZonedDateTime.WeekYear:
    commentId: P:NodaTime.ZonedDateTime.WeekYear
  NodaTime.ZonedDateTime.WeekOfWeekYear*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.WeekOfWeekYear*
        name: WeekOfWeekYear
        nameWithType: ZonedDateTime.WeekOfWeekYear
        qualifiedName: NodaTime.ZonedDateTime.WeekOfWeekYear
      VB:
      - id: NodaTime.ZonedDateTime.WeekOfWeekYear*
        name: WeekOfWeekYear
        nameWithType: ZonedDateTime.WeekOfWeekYear
        qualifiedName: NodaTime.ZonedDateTime.WeekOfWeekYear
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.WeekOfWeekYear
  NodaTime.ZonedDateTime.DayOfYear*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.DayOfYear*
        name: DayOfYear
        nameWithType: ZonedDateTime.DayOfYear
        qualifiedName: NodaTime.ZonedDateTime.DayOfYear
      VB:
      - id: NodaTime.ZonedDateTime.DayOfYear*
        name: DayOfYear
        nameWithType: ZonedDateTime.DayOfYear
        qualifiedName: NodaTime.ZonedDateTime.DayOfYear
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.DayOfYear
  NodaTime.ZonedDateTime.Day*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Day*
        name: Day
        nameWithType: ZonedDateTime.Day
        qualifiedName: NodaTime.ZonedDateTime.Day
      VB:
      - id: NodaTime.ZonedDateTime.Day*
        name: Day
        nameWithType: ZonedDateTime.Day
        qualifiedName: NodaTime.ZonedDateTime.Day
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Day
  NodaTime.ZonedDateTime.DayOfWeek:
    commentId: P:NodaTime.ZonedDateTime.DayOfWeek
  NodaTime.ZonedDateTime.IsoDayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.IsoDayOfWeek*
        name: IsoDayOfWeek
        nameWithType: ZonedDateTime.IsoDayOfWeek
        qualifiedName: NodaTime.ZonedDateTime.IsoDayOfWeek
      VB:
      - id: NodaTime.ZonedDateTime.IsoDayOfWeek*
        name: IsoDayOfWeek
        nameWithType: ZonedDateTime.IsoDayOfWeek
        qualifiedName: NodaTime.ZonedDateTime.IsoDayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.IsoDayOfWeek
  NodaTime.ZonedDateTime.IsoDayOfWeek:
    commentId: P:NodaTime.ZonedDateTime.IsoDayOfWeek
  NodaTime.ZonedDateTime.DayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.DayOfWeek*
        name: DayOfWeek
        nameWithType: ZonedDateTime.DayOfWeek
        qualifiedName: NodaTime.ZonedDateTime.DayOfWeek
      VB:
      - id: NodaTime.ZonedDateTime.DayOfWeek*
        name: DayOfWeek
        nameWithType: ZonedDateTime.DayOfWeek
        qualifiedName: NodaTime.ZonedDateTime.DayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.DayOfWeek
  NodaTime.ZonedDateTime.Hour*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Hour*
        name: Hour
        nameWithType: ZonedDateTime.Hour
        qualifiedName: NodaTime.ZonedDateTime.Hour
      VB:
      - id: NodaTime.ZonedDateTime.Hour*
        name: Hour
        nameWithType: ZonedDateTime.Hour
        qualifiedName: NodaTime.ZonedDateTime.Hour
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Hour
  NodaTime.ZonedDateTime.ClockHourOfHalfDay*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.ClockHourOfHalfDay*
        name: ClockHourOfHalfDay
        nameWithType: ZonedDateTime.ClockHourOfHalfDay
        qualifiedName: NodaTime.ZonedDateTime.ClockHourOfHalfDay
      VB:
      - id: NodaTime.ZonedDateTime.ClockHourOfHalfDay*
        name: ClockHourOfHalfDay
        nameWithType: ZonedDateTime.ClockHourOfHalfDay
        qualifiedName: NodaTime.ZonedDateTime.ClockHourOfHalfDay
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.ClockHourOfHalfDay
  NodaTime.ZonedDateTime.Minute*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Minute*
        name: Minute
        nameWithType: ZonedDateTime.Minute
        qualifiedName: NodaTime.ZonedDateTime.Minute
      VB:
      - id: NodaTime.ZonedDateTime.Minute*
        name: Minute
        nameWithType: ZonedDateTime.Minute
        qualifiedName: NodaTime.ZonedDateTime.Minute
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Minute
  NodaTime.ZonedDateTime.Second*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Second*
        name: Second
        nameWithType: ZonedDateTime.Second
        qualifiedName: NodaTime.ZonedDateTime.Second
      VB:
      - id: NodaTime.ZonedDateTime.Second*
        name: Second
        nameWithType: ZonedDateTime.Second
        qualifiedName: NodaTime.ZonedDateTime.Second
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Second
  NodaTime.ZonedDateTime.Millisecond*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Millisecond*
        name: Millisecond
        nameWithType: ZonedDateTime.Millisecond
        qualifiedName: NodaTime.ZonedDateTime.Millisecond
      VB:
      - id: NodaTime.ZonedDateTime.Millisecond*
        name: Millisecond
        nameWithType: ZonedDateTime.Millisecond
        qualifiedName: NodaTime.ZonedDateTime.Millisecond
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Millisecond
  NodaTime.ZonedDateTime.TickOfSecond*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.TickOfSecond*
        name: TickOfSecond
        nameWithType: ZonedDateTime.TickOfSecond
        qualifiedName: NodaTime.ZonedDateTime.TickOfSecond
      VB:
      - id: NodaTime.ZonedDateTime.TickOfSecond*
        name: TickOfSecond
        nameWithType: ZonedDateTime.TickOfSecond
        qualifiedName: NodaTime.ZonedDateTime.TickOfSecond
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.TickOfSecond
  NodaTime.ZonedDateTime.TickOfDay*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.TickOfDay*
        name: TickOfDay
        nameWithType: ZonedDateTime.TickOfDay
        qualifiedName: NodaTime.ZonedDateTime.TickOfDay
      VB:
      - id: NodaTime.ZonedDateTime.TickOfDay*
        name: TickOfDay
        nameWithType: ZonedDateTime.TickOfDay
        qualifiedName: NodaTime.ZonedDateTime.TickOfDay
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.TickOfDay
  NodaTime.ZonedDateTime.ToInstant*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.ToInstant*
        name: ToInstant
        nameWithType: ZonedDateTime.ToInstant
        qualifiedName: NodaTime.ZonedDateTime.ToInstant
      VB:
      - id: NodaTime.ZonedDateTime.ToInstant*
        name: ToInstant
        nameWithType: ZonedDateTime.ToInstant
        qualifiedName: NodaTime.ZonedDateTime.ToInstant
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.ToInstant
  NodaTime.ZonedDateTime.WithZone*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.WithZone*
        name: WithZone
        nameWithType: ZonedDateTime.WithZone
        qualifiedName: NodaTime.ZonedDateTime.WithZone
      VB:
      - id: NodaTime.ZonedDateTime.WithZone*
        name: WithZone
        nameWithType: ZonedDateTime.WithZone
        qualifiedName: NodaTime.ZonedDateTime.WithZone
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.WithZone
  NodaTime.ZonedDateTime.Equals*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Equals*
        name: Equals
        nameWithType: ZonedDateTime.Equals
        qualifiedName: NodaTime.ZonedDateTime.Equals
      VB:
      - id: NodaTime.ZonedDateTime.Equals*
        name: Equals
        nameWithType: ZonedDateTime.Equals
        qualifiedName: NodaTime.ZonedDateTime.Equals
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Equals
  System.IEquatable{NodaTime.ZonedDateTime}.Equals(NodaTime.ZonedDateTime):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<ZonedDateTime>.Equals
        qualifiedName: System.IEquatable<NodaTime.ZonedDateTime>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of ZonedDateTime).Equals
        qualifiedName: System.IEquatable(Of NodaTime.ZonedDateTime).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.ZonedDateTime}
    commentId: M:System.IEquatable{NodaTime.ZonedDateTime}.Equals(NodaTime.ZonedDateTime)
  NodaTime.ZonedDateTime.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.GetHashCode*
        name: GetHashCode
        nameWithType: ZonedDateTime.GetHashCode
        qualifiedName: NodaTime.ZonedDateTime.GetHashCode
      VB:
      - id: NodaTime.ZonedDateTime.GetHashCode*
        name: GetHashCode
        nameWithType: ZonedDateTime.GetHashCode
        qualifiedName: NodaTime.ZonedDateTime.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.GetHashCode
  NodaTime.ZonedDateTime.op_Equality*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.op_Equality*
        name: Equality
        nameWithType: ZonedDateTime.Equality
        qualifiedName: NodaTime.ZonedDateTime.Equality
      VB:
      - id: NodaTime.ZonedDateTime.op_Equality*
        name: Equality
        nameWithType: ZonedDateTime.Equality
        qualifiedName: NodaTime.ZonedDateTime.Equality
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.op_Equality
  NodaTime.ZonedDateTime.op_Inequality*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.op_Inequality*
        name: Inequality
        nameWithType: ZonedDateTime.Inequality
        qualifiedName: NodaTime.ZonedDateTime.Inequality
      VB:
      - id: NodaTime.ZonedDateTime.op_Inequality*
        name: Inequality
        nameWithType: ZonedDateTime.Inequality
        qualifiedName: NodaTime.ZonedDateTime.Inequality
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.op_Inequality
  NodaTime.ZonedDateTime.op_LessThan*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.op_LessThan*
        name: LessThan
        nameWithType: ZonedDateTime.LessThan
        qualifiedName: NodaTime.ZonedDateTime.LessThan
      VB:
      - id: NodaTime.ZonedDateTime.op_LessThan*
        name: LessThan
        nameWithType: ZonedDateTime.LessThan
        qualifiedName: NodaTime.ZonedDateTime.LessThan
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.op_LessThan
  NodaTime.ZonedDateTime.op_LessThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: ZonedDateTime.LessThanOrEqual
        qualifiedName: NodaTime.ZonedDateTime.LessThanOrEqual
      VB:
      - id: NodaTime.ZonedDateTime.op_LessThanOrEqual*
        name: LessThanOrEqual
        nameWithType: ZonedDateTime.LessThanOrEqual
        qualifiedName: NodaTime.ZonedDateTime.LessThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.op_LessThanOrEqual
  NodaTime.ZonedDateTime.op_GreaterThan*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.op_GreaterThan*
        name: GreaterThan
        nameWithType: ZonedDateTime.GreaterThan
        qualifiedName: NodaTime.ZonedDateTime.GreaterThan
      VB:
      - id: NodaTime.ZonedDateTime.op_GreaterThan*
        name: GreaterThan
        nameWithType: ZonedDateTime.GreaterThan
        qualifiedName: NodaTime.ZonedDateTime.GreaterThan
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.op_GreaterThan
  NodaTime.ZonedDateTime.op_GreaterThanOrEqual*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: ZonedDateTime.GreaterThanOrEqual
        qualifiedName: NodaTime.ZonedDateTime.GreaterThanOrEqual
      VB:
      - id: NodaTime.ZonedDateTime.op_GreaterThanOrEqual*
        name: GreaterThanOrEqual
        nameWithType: ZonedDateTime.GreaterThanOrEqual
        qualifiedName: NodaTime.ZonedDateTime.GreaterThanOrEqual
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.op_GreaterThanOrEqual
  NodaTime.ZonedDateTime.CompareTo*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.CompareTo*
        name: CompareTo
        nameWithType: ZonedDateTime.CompareTo
        qualifiedName: NodaTime.ZonedDateTime.CompareTo
      VB:
      - id: NodaTime.ZonedDateTime.CompareTo*
        name: CompareTo
        nameWithType: ZonedDateTime.CompareTo
        qualifiedName: NodaTime.ZonedDateTime.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.CompareTo
  System.IComparable{NodaTime.ZonedDateTime}.CompareTo(NodaTime.ZonedDateTime):
    name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<ZonedDateTime>.CompareTo
        qualifiedName: System.IComparable<NodaTime.ZonedDateTime>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of ZonedDateTime).CompareTo
        qualifiedName: System.IComparable(Of NodaTime.ZonedDateTime).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1.CompareTo(`0)
    parent: System.IComparable{NodaTime.ZonedDateTime}
    commentId: M:System.IComparable{NodaTime.ZonedDateTime}.CompareTo(NodaTime.ZonedDateTime)
  NodaTime.ZonedDateTime.System#IComparable#CompareTo*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.System#IComparable#CompareTo*
        name: IComparable.CompareTo
        nameWithType: ZonedDateTime.IComparable.CompareTo
        qualifiedName: NodaTime.ZonedDateTime.System.IComparable.CompareTo
      VB:
      - id: NodaTime.ZonedDateTime.System#IComparable#CompareTo*
        name: System.IComparable.CompareTo
        nameWithType: ZonedDateTime.System.IComparable.CompareTo
        qualifiedName: NodaTime.ZonedDateTime.System.IComparable.CompareTo
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.System#IComparable#CompareTo
  NodaTime.ZonedDateTime.op_Addition*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.op_Addition*
        name: Addition
        nameWithType: ZonedDateTime.Addition
        qualifiedName: NodaTime.ZonedDateTime.Addition
      VB:
      - id: NodaTime.ZonedDateTime.op_Addition*
        name: Addition
        nameWithType: ZonedDateTime.Addition
        qualifiedName: NodaTime.ZonedDateTime.Addition
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.op_Addition
  NodaTime.ZonedDateTime.Add*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Add*
        name: Add
        nameWithType: ZonedDateTime.Add
        qualifiedName: NodaTime.ZonedDateTime.Add
      VB:
      - id: NodaTime.ZonedDateTime.Add*
        name: Add
        nameWithType: ZonedDateTime.Add
        qualifiedName: NodaTime.ZonedDateTime.Add
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Add
  NodaTime.ZonedDateTime.Plus*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Plus*
        name: Plus
        nameWithType: ZonedDateTime.Plus
        qualifiedName: NodaTime.ZonedDateTime.Plus
      VB:
      - id: NodaTime.ZonedDateTime.Plus*
        name: Plus
        nameWithType: ZonedDateTime.Plus
        qualifiedName: NodaTime.ZonedDateTime.Plus
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Plus
  NodaTime.ZonedDateTime.Subtract*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Subtract*
        name: Subtract
        nameWithType: ZonedDateTime.Subtract
        qualifiedName: NodaTime.ZonedDateTime.Subtract
      VB:
      - id: NodaTime.ZonedDateTime.Subtract*
        name: Subtract
        nameWithType: ZonedDateTime.Subtract
        qualifiedName: NodaTime.ZonedDateTime.Subtract
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Subtract
  NodaTime.ZonedDateTime.Minus*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Minus*
        name: Minus
        nameWithType: ZonedDateTime.Minus
        qualifiedName: NodaTime.ZonedDateTime.Minus
      VB:
      - id: NodaTime.ZonedDateTime.Minus*
        name: Minus
        nameWithType: ZonedDateTime.Minus
        qualifiedName: NodaTime.ZonedDateTime.Minus
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Minus
  NodaTime.ZonedDateTime.op_Subtraction*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.op_Subtraction*
        name: Subtraction
        nameWithType: ZonedDateTime.Subtraction
        qualifiedName: NodaTime.ZonedDateTime.Subtraction
      VB:
      - id: NodaTime.ZonedDateTime.op_Subtraction*
        name: Subtraction
        nameWithType: ZonedDateTime.Subtraction
        qualifiedName: NodaTime.ZonedDateTime.Subtraction
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.op_Subtraction
  NodaTime.ZonedDateTime.GetZoneInterval*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.GetZoneInterval*
        name: GetZoneInterval
        nameWithType: ZonedDateTime.GetZoneInterval
        qualifiedName: NodaTime.ZonedDateTime.GetZoneInterval
      VB:
      - id: NodaTime.ZonedDateTime.GetZoneInterval*
        name: GetZoneInterval
        nameWithType: ZonedDateTime.GetZoneInterval
        qualifiedName: NodaTime.ZonedDateTime.GetZoneInterval
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.GetZoneInterval
  NodaTime.ZonedDateTime.ToString*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.ToString*
        name: ToString
        nameWithType: ZonedDateTime.ToString
        qualifiedName: NodaTime.ZonedDateTime.ToString
      VB:
      - id: NodaTime.ZonedDateTime.ToString*
        name: ToString
        nameWithType: ZonedDateTime.ToString
        qualifiedName: NodaTime.ZonedDateTime.ToString
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.ToString
  NodaTime.ZonedDateTime.ToDateTimeOffset*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.ToDateTimeOffset*
        name: ToDateTimeOffset
        nameWithType: ZonedDateTime.ToDateTimeOffset
        qualifiedName: NodaTime.ZonedDateTime.ToDateTimeOffset
      VB:
      - id: NodaTime.ZonedDateTime.ToDateTimeOffset*
        name: ToDateTimeOffset
        nameWithType: ZonedDateTime.ToDateTimeOffset
        qualifiedName: NodaTime.ZonedDateTime.ToDateTimeOffset
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.ToDateTimeOffset
  NodaTime.ZonedDateTime.FromDateTimeOffset*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.FromDateTimeOffset*
        name: FromDateTimeOffset
        nameWithType: ZonedDateTime.FromDateTimeOffset
        qualifiedName: NodaTime.ZonedDateTime.FromDateTimeOffset
      VB:
      - id: NodaTime.ZonedDateTime.FromDateTimeOffset*
        name: FromDateTimeOffset
        nameWithType: ZonedDateTime.FromDateTimeOffset
        qualifiedName: NodaTime.ZonedDateTime.FromDateTimeOffset
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.FromDateTimeOffset
  NodaTime.ZonedDateTime.ToDateTimeUtc*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.ToDateTimeUtc*
        name: ToDateTimeUtc
        nameWithType: ZonedDateTime.ToDateTimeUtc
        qualifiedName: NodaTime.ZonedDateTime.ToDateTimeUtc
      VB:
      - id: NodaTime.ZonedDateTime.ToDateTimeUtc*
        name: ToDateTimeUtc
        nameWithType: ZonedDateTime.ToDateTimeUtc
        qualifiedName: NodaTime.ZonedDateTime.ToDateTimeUtc
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.ToDateTimeUtc
  NodaTime.ZonedDateTime.ToDateTimeUnspecified*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.ToDateTimeUnspecified*
        name: ToDateTimeUnspecified
        nameWithType: ZonedDateTime.ToDateTimeUnspecified
        qualifiedName: NodaTime.ZonedDateTime.ToDateTimeUnspecified
      VB:
      - id: NodaTime.ZonedDateTime.ToDateTimeUnspecified*
        name: ToDateTimeUnspecified
        nameWithType: ZonedDateTime.ToDateTimeUnspecified
        qualifiedName: NodaTime.ZonedDateTime.ToDateTimeUnspecified
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.ToDateTimeUnspecified
  NodaTime.ZonedDateTime.ToOffsetDateTime*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.ToOffsetDateTime*
        name: ToOffsetDateTime
        nameWithType: ZonedDateTime.ToOffsetDateTime
        qualifiedName: NodaTime.ZonedDateTime.ToOffsetDateTime
      VB:
      - id: NodaTime.ZonedDateTime.ToOffsetDateTime*
        name: ToOffsetDateTime
        nameWithType: ZonedDateTime.ToOffsetDateTime
        qualifiedName: NodaTime.ZonedDateTime.ToOffsetDateTime
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.ToOffsetDateTime
  NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: IXmlSerializable.GetSchema
        nameWithType: ZonedDateTime.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema
      VB:
      - id: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema*
        name: System.Xml.Serialization.IXmlSerializable.GetSchema
        nameWithType: ZonedDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema
        qualifiedName: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.GetSchema
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema
  NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: IXmlSerializable.ReadXml
        nameWithType: ZonedDateTime.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml
      VB:
      - id: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml*
        name: System.Xml.Serialization.IXmlSerializable.ReadXml
        nameWithType: ZonedDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml
        qualifiedName: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.ReadXml
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml
  NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: IXmlSerializable.WriteXml
        nameWithType: ZonedDateTime.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml
      VB:
      - id: NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml*
        name: System.Xml.Serialization.IXmlSerializable.WriteXml
        nameWithType: ZonedDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml
        qualifiedName: NodaTime.ZonedDateTime.System.Xml.Serialization.IXmlSerializable.WriteXml
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml
  NodaTime.ZonedDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: ISerializable.GetObjectData
        nameWithType: ZonedDateTime.ISerializable.GetObjectData
        qualifiedName: NodaTime.ZonedDateTime.System.Runtime.Serialization.ISerializable.GetObjectData
      VB:
      - id: NodaTime.ZonedDateTime.System#Runtime#Serialization#ISerializable#GetObjectData*
        name: System.Runtime.Serialization.ISerializable.GetObjectData
        nameWithType: ZonedDateTime.System.Runtime.Serialization.ISerializable.GetObjectData
        qualifiedName: NodaTime.ZonedDateTime.System.Runtime.Serialization.ISerializable.GetObjectData
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.System#Runtime#Serialization#ISerializable#GetObjectData
  System.Collections.Generic.IComparer{NodaTime.ZonedDateTime}:
    name:
      CSharp:
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IComparer`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IComparer{NodaTime.ZonedDateTime}
  NodaTime.ZonedDateTime.Comparer:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Comparer
        name: ZonedDateTime.Comparer
        nameWithType: ZonedDateTime.Comparer
        qualifiedName: NodaTime.ZonedDateTime.Comparer
      VB:
      - id: NodaTime.ZonedDateTime.Comparer
        name: ZonedDateTime.Comparer
        nameWithType: ZonedDateTime.Comparer
        qualifiedName: NodaTime.ZonedDateTime.Comparer
    isDefinition: true
    parent: NodaTime
    commentId: T:NodaTime.ZonedDateTime.Comparer
  NodaTime.ZonedDateTime.Comparer.Local*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Comparer.Local*
        name: Local
        nameWithType: ZonedDateTime.Comparer.Local
        qualifiedName: NodaTime.ZonedDateTime.Comparer.Local
      VB:
      - id: NodaTime.ZonedDateTime.Comparer.Local*
        name: Local
        nameWithType: ZonedDateTime.Comparer.Local
        qualifiedName: NodaTime.ZonedDateTime.Comparer.Local
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Comparer.Local
  NodaTime.ZonedDateTime.Comparer.Local:
    commentId: P:NodaTime.ZonedDateTime.Comparer.Local
  NodaTime.ZonedDateTime.Comparer.Instant*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Comparer.Instant*
        name: Instant
        nameWithType: ZonedDateTime.Comparer.Instant
        qualifiedName: NodaTime.ZonedDateTime.Comparer.Instant
      VB:
      - id: NodaTime.ZonedDateTime.Comparer.Instant*
        name: Instant
        nameWithType: ZonedDateTime.Comparer.Instant
        qualifiedName: NodaTime.ZonedDateTime.Comparer.Instant
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Comparer.Instant
  NodaTime.ZonedDateTime.Comparer.Compare*:
    name:
      CSharp:
      - id: NodaTime.ZonedDateTime.Comparer.Compare*
        name: Compare
        nameWithType: ZonedDateTime.Comparer.Compare
        qualifiedName: NodaTime.ZonedDateTime.Comparer.Compare
      VB:
      - id: NodaTime.ZonedDateTime.Comparer.Compare*
        name: Compare
        nameWithType: ZonedDateTime.Comparer.Compare
        qualifiedName: NodaTime.ZonedDateTime.Comparer.Compare
    isDefinition: true
    commentId: Overload:NodaTime.ZonedDateTime.Comparer.Compare
  System.Collections.Generic.IComparer{NodaTime.ZonedDateTime}.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime):
    name:
      CSharp:
      - id: System.Collections.Generic.IComparer`1.Compare(`0,`0)
        name: Compare
        nameWithType: IComparer<ZonedDateTime>.Compare
        qualifiedName: System.Collections.Generic.IComparer<NodaTime.ZonedDateTime>.Compare
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.IComparer`1.Compare(`0,`0)
        name: Compare
        nameWithType: IComparer(Of ZonedDateTime).Compare
        qualifiedName: System.Collections.Generic.IComparer(Of NodaTime.ZonedDateTime).Compare
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IComparer`1.Compare(`0,`0)
    parent: System.Collections.Generic.IComparer{NodaTime.ZonedDateTime}
    commentId: M:System.Collections.Generic.IComparer{NodaTime.ZonedDateTime}.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)
  NodaTime.Calendars.Era.Name*:
    name:
      CSharp:
      - id: NodaTime.Calendars.Era.Name*
        name: Name
        nameWithType: Era.Name
        qualifiedName: NodaTime.Calendars.Era.Name
      VB:
      - id: NodaTime.Calendars.Era.Name*
        name: Name
        nameWithType: Era.Name
        qualifiedName: NodaTime.Calendars.Era.Name
    isDefinition: true
    commentId: Overload:NodaTime.Calendars.Era.Name
  NodaTime.Calendars.Era.ToString*:
    name:
      CSharp:
      - id: NodaTime.Calendars.Era.ToString*
        name: ToString
        nameWithType: Era.ToString
        qualifiedName: NodaTime.Calendars.Era.ToString
      VB:
      - id: NodaTime.Calendars.Era.ToString*
        name: ToString
        nameWithType: Era.ToString
        qualifiedName: NodaTime.Calendars.Era.ToString
    isDefinition: true
    commentId: Overload:NodaTime.Calendars.Era.ToString
  NodaTime.Calendars.IslamicLeapYearPattern.Base16:
    commentId: F:NodaTime.Calendars.IslamicLeapYearPattern.Base16
  NodaTime.Calendars.IslamicLeapYearPattern.Base15:
    commentId: F:NodaTime.Calendars.IslamicLeapYearPattern.Base15
  System.Globalization.CultureInfo:
    name:
      CSharp:
      - id: System.Globalization.CultureInfo
        name: CultureInfo
        nameWithType: CultureInfo
        qualifiedName: System.Globalization.CultureInfo
        isExternal: true
      VB:
      - id: System.Globalization.CultureInfo
        name: CultureInfo
        nameWithType: CultureInfo
        qualifiedName: System.Globalization.CultureInfo
        isExternal: true
    isDefinition: true
    parent: System.Globalization
    commentId: T:System.Globalization.CultureInfo
  NodaTime.Text.IPattern`1:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:NodaTime.Text.IPattern`1
  NodaTime.Text:
    name:
      CSharp:
      - name: NodaTime.Text
        nameWithType: NodaTime.Text
        qualifiedName: NodaTime.Text
      VB:
      - name: NodaTime.Text
        nameWithType: NodaTime.Text
        qualifiedName: NodaTime.Text
    isDefinition: true
    commentId: N:NodaTime.Text
  NodaTime.Text.IPattern{NodaTime.Duration}:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.IPattern{NodaTime.Duration}
  NodaTime.Text.DurationPattern:
    name:
      CSharp:
      - id: NodaTime.Text.DurationPattern
        name: DurationPattern
        nameWithType: DurationPattern
        qualifiedName: NodaTime.Text.DurationPattern
      VB:
      - id: NodaTime.Text.DurationPattern
        name: DurationPattern
        nameWithType: DurationPattern
        qualifiedName: NodaTime.Text.DurationPattern
    isDefinition: true
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.DurationPattern
  NodaTime.Text.DurationPattern.RoundtripPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.DurationPattern.RoundtripPattern*
        name: RoundtripPattern
        nameWithType: DurationPattern.RoundtripPattern
        qualifiedName: NodaTime.Text.DurationPattern.RoundtripPattern
      VB:
      - id: NodaTime.Text.DurationPattern.RoundtripPattern*
        name: RoundtripPattern
        nameWithType: DurationPattern.RoundtripPattern
        qualifiedName: NodaTime.Text.DurationPattern.RoundtripPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.DurationPattern.RoundtripPattern
  NodaTime.Text.DurationPattern.PatternText*:
    name:
      CSharp:
      - id: NodaTime.Text.DurationPattern.PatternText*
        name: PatternText
        nameWithType: DurationPattern.PatternText
        qualifiedName: NodaTime.Text.DurationPattern.PatternText
      VB:
      - id: NodaTime.Text.DurationPattern.PatternText*
        name: PatternText
        nameWithType: DurationPattern.PatternText
        qualifiedName: NodaTime.Text.DurationPattern.PatternText
    isDefinition: true
    commentId: Overload:NodaTime.Text.DurationPattern.PatternText
  NodaTime.Text.ParseResult`1:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:NodaTime.Text.ParseResult`1
  NodaTime.Text.ParseResult{NodaTime.Duration}:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.ParseResult`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ParseResult{NodaTime.Duration}
  NodaTime.Text.DurationPattern.Parse*:
    name:
      CSharp:
      - id: NodaTime.Text.DurationPattern.Parse*
        name: Parse
        nameWithType: DurationPattern.Parse
        qualifiedName: NodaTime.Text.DurationPattern.Parse
      VB:
      - id: NodaTime.Text.DurationPattern.Parse*
        name: Parse
        nameWithType: DurationPattern.Parse
        qualifiedName: NodaTime.Text.DurationPattern.Parse
    isDefinition: true
    commentId: Overload:NodaTime.Text.DurationPattern.Parse
  NodaTime.Text.IPattern`1.Parse(System.String):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern<T>.Parse
        qualifiedName: NodaTime.Text.IPattern<T>.Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern(Of T).Parse
        qualifiedName: NodaTime.Text.IPattern(Of T).Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:NodaTime.Text.IPattern`1.Parse(System.String)
  NodaTime.Text.IPattern{NodaTime.Duration}.Parse(System.String):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern<Duration>.Parse
        qualifiedName: NodaTime.Text.IPattern<NodaTime.Duration>.Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern(Of Duration).Parse
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.Duration).Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Parse(System.String)
    parent: NodaTime.Text.IPattern{NodaTime.Duration}
    commentId: M:NodaTime.Text.IPattern{NodaTime.Duration}.Parse(System.String)
  NodaTime.Text.DurationPattern.Format*:
    name:
      CSharp:
      - id: NodaTime.Text.DurationPattern.Format*
        name: Format
        nameWithType: DurationPattern.Format
        qualifiedName: NodaTime.Text.DurationPattern.Format
      VB:
      - id: NodaTime.Text.DurationPattern.Format*
        name: Format
        nameWithType: DurationPattern.Format
        qualifiedName: NodaTime.Text.DurationPattern.Format
    isDefinition: true
    commentId: Overload:NodaTime.Text.DurationPattern.Format
  NodaTime.Text.IPattern`1.Format(`0):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern<T>.Format
        qualifiedName: NodaTime.Text.IPattern<T>.Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern(Of T).Format
        qualifiedName: NodaTime.Text.IPattern(Of T).Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:NodaTime.Text.IPattern`1.Format(`0)
  NodaTime.Text.IPattern{NodaTime.Duration}.Format(NodaTime.Duration):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern<Duration>.Format
        qualifiedName: NodaTime.Text.IPattern<NodaTime.Duration>.Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern(Of Duration).Format
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.Duration).Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Duration
        name: Duration
        nameWithType: Duration
        qualifiedName: NodaTime.Duration
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Format(`0)
    parent: NodaTime.Text.IPattern{NodaTime.Duration}
    commentId: M:NodaTime.Text.IPattern{NodaTime.Duration}.Format(NodaTime.Duration)
  NodaTime.Text.InvalidPatternException:
    name:
      CSharp:
      - id: NodaTime.Text.InvalidPatternException
        name: InvalidPatternException
        nameWithType: InvalidPatternException
        qualifiedName: NodaTime.Text.InvalidPatternException
      VB:
      - id: NodaTime.Text.InvalidPatternException
        name: InvalidPatternException
        nameWithType: InvalidPatternException
        qualifiedName: NodaTime.Text.InvalidPatternException
    isDefinition: true
    commentId: T:NodaTime.Text.InvalidPatternException
  System.Globalization:
    name:
      CSharp:
      - name: System.Globalization
        nameWithType: System.Globalization
        qualifiedName: System.Globalization
      VB:
      - name: System.Globalization
        nameWithType: System.Globalization
        qualifiedName: System.Globalization
    isDefinition: true
    commentId: N:System.Globalization
  NodaTime.Text.DurationPattern.Create*:
    name:
      CSharp:
      - id: NodaTime.Text.DurationPattern.Create*
        name: Create
        nameWithType: DurationPattern.Create
        qualifiedName: NodaTime.Text.DurationPattern.Create
      VB:
      - id: NodaTime.Text.DurationPattern.Create*
        name: Create
        nameWithType: DurationPattern.Create
        qualifiedName: NodaTime.Text.DurationPattern.Create
    isDefinition: true
    commentId: Overload:NodaTime.Text.DurationPattern.Create
  NodaTime.Text.DurationPattern.CreateWithCurrentCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.DurationPattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: DurationPattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.DurationPattern.CreateWithCurrentCulture
      VB:
      - id: NodaTime.Text.DurationPattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: DurationPattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.DurationPattern.CreateWithCurrentCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.DurationPattern.CreateWithCurrentCulture
  NodaTime.Text.DurationPattern.CreateWithInvariantCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.DurationPattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: DurationPattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.DurationPattern.CreateWithInvariantCulture
      VB:
      - id: NodaTime.Text.DurationPattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: DurationPattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.DurationPattern.CreateWithInvariantCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.DurationPattern.CreateWithInvariantCulture
  NodaTime.Text.DurationPattern.WithCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.DurationPattern.WithCulture*
        name: WithCulture
        nameWithType: DurationPattern.WithCulture
        qualifiedName: NodaTime.Text.DurationPattern.WithCulture
      VB:
      - id: NodaTime.Text.DurationPattern.WithCulture*
        name: WithCulture
        nameWithType: DurationPattern.WithCulture
        qualifiedName: NodaTime.Text.DurationPattern.WithCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.DurationPattern.WithCulture
  NodaTime.Text.IPattern{NodaTime.OffsetDateTime}:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.IPattern{NodaTime.OffsetDateTime}
  NodaTime.Text.OffsetDateTimePattern:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern
        name: OffsetDateTimePattern
        nameWithType: OffsetDateTimePattern
        qualifiedName: NodaTime.Text.OffsetDateTimePattern
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern
        name: OffsetDateTimePattern
        nameWithType: OffsetDateTimePattern
        qualifiedName: NodaTime.Text.OffsetDateTimePattern
    isDefinition: true
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.OffsetDateTimePattern
  NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern*
        name: GeneralIsoPattern
        nameWithType: OffsetDateTimePattern.GeneralIsoPattern
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern*
        name: GeneralIsoPattern
        nameWithType: OffsetDateTimePattern.GeneralIsoPattern
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern
  NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern*
        name: ExtendedIsoPattern
        nameWithType: OffsetDateTimePattern.ExtendedIsoPattern
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern*
        name: ExtendedIsoPattern
        nameWithType: OffsetDateTimePattern.ExtendedIsoPattern
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern
  NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern*
        name: FullRoundtripPattern
        nameWithType: OffsetDateTimePattern.FullRoundtripPattern
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern*
        name: FullRoundtripPattern
        nameWithType: OffsetDateTimePattern.FullRoundtripPattern
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern
  NodaTime.Text.OffsetDateTimePattern.PatternText*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.PatternText*
        name: PatternText
        nameWithType: OffsetDateTimePattern.PatternText
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.PatternText
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.PatternText*
        name: PatternText
        nameWithType: OffsetDateTimePattern.PatternText
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.PatternText
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.PatternText
  NodaTime.Text.OffsetDateTimePattern.TemplateValue*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.TemplateValue*
        name: TemplateValue
        nameWithType: OffsetDateTimePattern.TemplateValue
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.TemplateValue
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.TemplateValue*
        name: TemplateValue
        nameWithType: OffsetDateTimePattern.TemplateValue
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.TemplateValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.TemplateValue
  NodaTime.Text.ParseResult{NodaTime.OffsetDateTime}:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.ParseResult`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ParseResult{NodaTime.OffsetDateTime}
  NodaTime.Text.OffsetDateTimePattern.Parse*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.Parse*
        name: Parse
        nameWithType: OffsetDateTimePattern.Parse
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.Parse
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.Parse*
        name: Parse
        nameWithType: OffsetDateTimePattern.Parse
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.Parse
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.Parse
  NodaTime.Text.IPattern{NodaTime.OffsetDateTime}.Parse(System.String):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern<OffsetDateTime>.Parse
        qualifiedName: NodaTime.Text.IPattern<NodaTime.OffsetDateTime>.Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern(Of OffsetDateTime).Parse
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.OffsetDateTime).Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Parse(System.String)
    parent: NodaTime.Text.IPattern{NodaTime.OffsetDateTime}
    commentId: M:NodaTime.Text.IPattern{NodaTime.OffsetDateTime}.Parse(System.String)
  NodaTime.Text.OffsetDateTimePattern.Format*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.Format*
        name: Format
        nameWithType: OffsetDateTimePattern.Format
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.Format
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.Format*
        name: Format
        nameWithType: OffsetDateTimePattern.Format
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.Format
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.Format
  NodaTime.Text.IPattern{NodaTime.OffsetDateTime}.Format(NodaTime.OffsetDateTime):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern<OffsetDateTime>.Format
        qualifiedName: NodaTime.Text.IPattern<NodaTime.OffsetDateTime>.Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern(Of OffsetDateTime).Format
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.OffsetDateTime).Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.OffsetDateTime
        name: OffsetDateTime
        nameWithType: OffsetDateTime
        qualifiedName: NodaTime.OffsetDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Format(`0)
    parent: NodaTime.Text.IPattern{NodaTime.OffsetDateTime}
    commentId: M:NodaTime.Text.IPattern{NodaTime.OffsetDateTime}.Format(NodaTime.OffsetDateTime)
  NodaTime.Text.OffsetDateTimePattern.Create*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.Create*
        name: Create
        nameWithType: OffsetDateTimePattern.Create
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.Create
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.Create*
        name: Create
        nameWithType: OffsetDateTimePattern.Create
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.Create
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.Create
  NodaTime.Text.OffsetDateTimePattern.WithPatternText*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.WithPatternText*
        name: WithPatternText
        nameWithType: OffsetDateTimePattern.WithPatternText
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.WithPatternText
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.WithPatternText*
        name: WithPatternText
        nameWithType: OffsetDateTimePattern.WithPatternText
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.WithPatternText
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.WithPatternText
  NodaTime.Text.OffsetDateTimePattern.WithCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.WithCulture*
        name: WithCulture
        nameWithType: OffsetDateTimePattern.WithCulture
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.WithCulture
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.WithCulture*
        name: WithCulture
        nameWithType: OffsetDateTimePattern.WithCulture
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.WithCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.WithCulture
  NodaTime.Text.OffsetDateTimePattern.WithTemplateValue*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetDateTimePattern.WithTemplateValue*
        name: WithTemplateValue
        nameWithType: OffsetDateTimePattern.WithTemplateValue
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.WithTemplateValue
      VB:
      - id: NodaTime.Text.OffsetDateTimePattern.WithTemplateValue*
        name: WithTemplateValue
        nameWithType: OffsetDateTimePattern.WithTemplateValue
        qualifiedName: NodaTime.Text.OffsetDateTimePattern.WithTemplateValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetDateTimePattern.WithTemplateValue
  NodaTime.Text.IPattern{NodaTime.ZonedDateTime}:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.IPattern{NodaTime.ZonedDateTime}
  NodaTime.Text.ZonedDateTimePattern:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern
        name: ZonedDateTimePattern
        nameWithType: ZonedDateTimePattern
        qualifiedName: NodaTime.Text.ZonedDateTimePattern
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern
        name: ZonedDateTimePattern
        nameWithType: ZonedDateTimePattern
        qualifiedName: NodaTime.Text.ZonedDateTimePattern
    isDefinition: true
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ZonedDateTimePattern
  NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern*
        name: GeneralFormatOnlyIsoPattern
        nameWithType: ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern*
        name: GeneralFormatOnlyIsoPattern
        nameWithType: ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern
  NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern*
        name: ExtendedFormatOnlyIsoPattern
        nameWithType: ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern*
        name: ExtendedFormatOnlyIsoPattern
        nameWithType: ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern
  NodaTime.Text.ZonedDateTimePattern.PatternText*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.PatternText*
        name: PatternText
        nameWithType: ZonedDateTimePattern.PatternText
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.PatternText
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.PatternText*
        name: PatternText
        nameWithType: ZonedDateTimePattern.PatternText
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.PatternText
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.PatternText
  NodaTime.Text.ZonedDateTimePattern.TemplateValue*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.TemplateValue*
        name: TemplateValue
        nameWithType: ZonedDateTimePattern.TemplateValue
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.TemplateValue
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.TemplateValue*
        name: TemplateValue
        nameWithType: ZonedDateTimePattern.TemplateValue
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.TemplateValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.TemplateValue
  NodaTime.Text.ZonedDateTimePattern.Resolver*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.Resolver*
        name: Resolver
        nameWithType: ZonedDateTimePattern.Resolver
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.Resolver
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.Resolver*
        name: Resolver
        nameWithType: ZonedDateTimePattern.Resolver
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.Resolver
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.Resolver
  NodaTime.Text.ZonedDateTimePattern.ZoneProvider*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.ZoneProvider*
        name: ZoneProvider
        nameWithType: ZonedDateTimePattern.ZoneProvider
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.ZoneProvider
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.ZoneProvider*
        name: ZoneProvider
        nameWithType: ZonedDateTimePattern.ZoneProvider
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.ZoneProvider
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.ZoneProvider
  NodaTime.Text.ParseResult{NodaTime.ZonedDateTime}:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.ParseResult`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ParseResult{NodaTime.ZonedDateTime}
  NodaTime.Text.ZonedDateTimePattern.Parse*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.Parse*
        name: Parse
        nameWithType: ZonedDateTimePattern.Parse
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.Parse
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.Parse*
        name: Parse
        nameWithType: ZonedDateTimePattern.Parse
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.Parse
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.Parse
  NodaTime.Text.IPattern{NodaTime.ZonedDateTime}.Parse(System.String):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern<ZonedDateTime>.Parse
        qualifiedName: NodaTime.Text.IPattern<NodaTime.ZonedDateTime>.Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern(Of ZonedDateTime).Parse
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.ZonedDateTime).Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Parse(System.String)
    parent: NodaTime.Text.IPattern{NodaTime.ZonedDateTime}
    commentId: M:NodaTime.Text.IPattern{NodaTime.ZonedDateTime}.Parse(System.String)
  NodaTime.Text.ZonedDateTimePattern.Format*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.Format*
        name: Format
        nameWithType: ZonedDateTimePattern.Format
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.Format
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.Format*
        name: Format
        nameWithType: ZonedDateTimePattern.Format
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.Format
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.Format
  NodaTime.Text.IPattern{NodaTime.ZonedDateTime}.Format(NodaTime.ZonedDateTime):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern<ZonedDateTime>.Format
        qualifiedName: NodaTime.Text.IPattern<NodaTime.ZonedDateTime>.Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern(Of ZonedDateTime).Format
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.ZonedDateTime).Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.ZonedDateTime
        name: ZonedDateTime
        nameWithType: ZonedDateTime
        qualifiedName: NodaTime.ZonedDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Format(`0)
    parent: NodaTime.Text.IPattern{NodaTime.ZonedDateTime}
    commentId: M:NodaTime.Text.IPattern{NodaTime.ZonedDateTime}.Format(NodaTime.ZonedDateTime)
  NodaTime.Text.ZonedDateTimePattern.Create*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.Create*
        name: Create
        nameWithType: ZonedDateTimePattern.Create
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.Create
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.Create*
        name: Create
        nameWithType: ZonedDateTimePattern.Create
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.Create
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.Create
  NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: ZonedDateTimePattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: ZonedDateTimePattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture
  NodaTime.Text.ZonedDateTimePattern.WithPatternText*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.WithPatternText*
        name: WithPatternText
        nameWithType: ZonedDateTimePattern.WithPatternText
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.WithPatternText
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.WithPatternText*
        name: WithPatternText
        nameWithType: ZonedDateTimePattern.WithPatternText
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.WithPatternText
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.WithPatternText
  NodaTime.Text.ZonedDateTimePattern.WithCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.WithCulture*
        name: WithCulture
        nameWithType: ZonedDateTimePattern.WithCulture
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.WithCulture
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.WithCulture*
        name: WithCulture
        nameWithType: ZonedDateTimePattern.WithCulture
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.WithCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.WithCulture
  NodaTime.Text.ZonedDateTimePattern.WithResolver*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.WithResolver*
        name: WithResolver
        nameWithType: ZonedDateTimePattern.WithResolver
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.WithResolver
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.WithResolver*
        name: WithResolver
        nameWithType: ZonedDateTimePattern.WithResolver
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.WithResolver
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.WithResolver
  NodaTime.Text.ZonedDateTimePattern.WithZoneProvider*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.WithZoneProvider*
        name: WithZoneProvider
        nameWithType: ZonedDateTimePattern.WithZoneProvider
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.WithZoneProvider
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.WithZoneProvider*
        name: WithZoneProvider
        nameWithType: ZonedDateTimePattern.WithZoneProvider
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.WithZoneProvider
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider
  NodaTime.Text.ZonedDateTimePattern.WithTemplateValue*:
    name:
      CSharp:
      - id: NodaTime.Text.ZonedDateTimePattern.WithTemplateValue*
        name: WithTemplateValue
        nameWithType: ZonedDateTimePattern.WithTemplateValue
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.WithTemplateValue
      VB:
      - id: NodaTime.Text.ZonedDateTimePattern.WithTemplateValue*
        name: WithTemplateValue
        nameWithType: ZonedDateTimePattern.WithTemplateValue
        qualifiedName: NodaTime.Text.ZonedDateTimePattern.WithTemplateValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.ZonedDateTimePattern.WithTemplateValue
  NodaTime.Text.IPattern{NodaTime.Instant}:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.IPattern{NodaTime.Instant}
  NodaTime.Text.InstantPattern:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern
        name: InstantPattern
        nameWithType: InstantPattern
        qualifiedName: NodaTime.Text.InstantPattern
      VB:
      - id: NodaTime.Text.InstantPattern
        name: InstantPattern
        nameWithType: InstantPattern
        qualifiedName: NodaTime.Text.InstantPattern
    isDefinition: true
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.InstantPattern
  NodaTime.Text.InstantPattern.GeneralPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.GeneralPattern*
        name: GeneralPattern
        nameWithType: InstantPattern.GeneralPattern
        qualifiedName: NodaTime.Text.InstantPattern.GeneralPattern
      VB:
      - id: NodaTime.Text.InstantPattern.GeneralPattern*
        name: GeneralPattern
        nameWithType: InstantPattern.GeneralPattern
        qualifiedName: NodaTime.Text.InstantPattern.GeneralPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.GeneralPattern
  NodaTime.Text.InstantPattern.ExtendedIsoPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.ExtendedIsoPattern*
        name: ExtendedIsoPattern
        nameWithType: InstantPattern.ExtendedIsoPattern
        qualifiedName: NodaTime.Text.InstantPattern.ExtendedIsoPattern
      VB:
      - id: NodaTime.Text.InstantPattern.ExtendedIsoPattern*
        name: ExtendedIsoPattern
        nameWithType: InstantPattern.ExtendedIsoPattern
        qualifiedName: NodaTime.Text.InstantPattern.ExtendedIsoPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.ExtendedIsoPattern
  NodaTime.Text.InstantPattern.PatternText*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.PatternText*
        name: PatternText
        nameWithType: InstantPattern.PatternText
        qualifiedName: NodaTime.Text.InstantPattern.PatternText
      VB:
      - id: NodaTime.Text.InstantPattern.PatternText*
        name: PatternText
        nameWithType: InstantPattern.PatternText
        qualifiedName: NodaTime.Text.InstantPattern.PatternText
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.PatternText
  NodaTime.Text.ParseResult{NodaTime.Instant}:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.ParseResult`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ParseResult{NodaTime.Instant}
  NodaTime.Text.InstantPattern.Parse*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.Parse*
        name: Parse
        nameWithType: InstantPattern.Parse
        qualifiedName: NodaTime.Text.InstantPattern.Parse
      VB:
      - id: NodaTime.Text.InstantPattern.Parse*
        name: Parse
        nameWithType: InstantPattern.Parse
        qualifiedName: NodaTime.Text.InstantPattern.Parse
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.Parse
  NodaTime.Text.IPattern{NodaTime.Instant}.Parse(System.String):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern<Instant>.Parse
        qualifiedName: NodaTime.Text.IPattern<NodaTime.Instant>.Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern(Of Instant).Parse
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.Instant).Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Parse(System.String)
    parent: NodaTime.Text.IPattern{NodaTime.Instant}
    commentId: M:NodaTime.Text.IPattern{NodaTime.Instant}.Parse(System.String)
  NodaTime.Text.InstantPattern.Format*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.Format*
        name: Format
        nameWithType: InstantPattern.Format
        qualifiedName: NodaTime.Text.InstantPattern.Format
      VB:
      - id: NodaTime.Text.InstantPattern.Format*
        name: Format
        nameWithType: InstantPattern.Format
        qualifiedName: NodaTime.Text.InstantPattern.Format
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.Format
  NodaTime.Text.IPattern{NodaTime.Instant}.Format(NodaTime.Instant):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern<Instant>.Format
        qualifiedName: NodaTime.Text.IPattern<NodaTime.Instant>.Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern(Of Instant).Format
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.Instant).Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Format(`0)
    parent: NodaTime.Text.IPattern{NodaTime.Instant}
    commentId: M:NodaTime.Text.IPattern{NodaTime.Instant}.Format(NodaTime.Instant)
  NodaTime.Text.InstantPattern.Create*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.Create*
        name: Create
        nameWithType: InstantPattern.Create
        qualifiedName: NodaTime.Text.InstantPattern.Create
      VB:
      - id: NodaTime.Text.InstantPattern.Create*
        name: Create
        nameWithType: InstantPattern.Create
        qualifiedName: NodaTime.Text.InstantPattern.Create
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.Create
  NodaTime.Text.InstantPattern.CreateWithCurrentCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: InstantPattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.InstantPattern.CreateWithCurrentCulture
      VB:
      - id: NodaTime.Text.InstantPattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: InstantPattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.InstantPattern.CreateWithCurrentCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.CreateWithCurrentCulture
  NodaTime.Text.InstantPattern.CreateWithInvariantCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: InstantPattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.InstantPattern.CreateWithInvariantCulture
      VB:
      - id: NodaTime.Text.InstantPattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: InstantPattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.InstantPattern.CreateWithInvariantCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.CreateWithInvariantCulture
  NodaTime.Text.InstantPattern.CreateNumericPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.CreateNumericPattern*
        name: CreateNumericPattern
        nameWithType: InstantPattern.CreateNumericPattern
        qualifiedName: NodaTime.Text.InstantPattern.CreateNumericPattern
      VB:
      - id: NodaTime.Text.InstantPattern.CreateNumericPattern*
        name: CreateNumericPattern
        nameWithType: InstantPattern.CreateNumericPattern
        qualifiedName: NodaTime.Text.InstantPattern.CreateNumericPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.CreateNumericPattern
  NodaTime.Text.InstantPattern.WithCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.WithCulture*
        name: WithCulture
        nameWithType: InstantPattern.WithCulture
        qualifiedName: NodaTime.Text.InstantPattern.WithCulture
      VB:
      - id: NodaTime.Text.InstantPattern.WithCulture*
        name: WithCulture
        nameWithType: InstantPattern.WithCulture
        qualifiedName: NodaTime.Text.InstantPattern.WithCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.WithCulture
  NodaTime.Instant.MinValue:
    commentId: F:NodaTime.Instant.MinValue
  NodaTime.Text.InstantPattern.WithMinMaxLabels*:
    name:
      CSharp:
      - id: NodaTime.Text.InstantPattern.WithMinMaxLabels*
        name: WithMinMaxLabels
        nameWithType: InstantPattern.WithMinMaxLabels
        qualifiedName: NodaTime.Text.InstantPattern.WithMinMaxLabels
      VB:
      - id: NodaTime.Text.InstantPattern.WithMinMaxLabels*
        name: WithMinMaxLabels
        nameWithType: InstantPattern.WithMinMaxLabels
        qualifiedName: NodaTime.Text.InstantPattern.WithMinMaxLabels
    isDefinition: true
    commentId: Overload:NodaTime.Text.InstantPattern.WithMinMaxLabels
  System.FormatException:
    name:
      CSharp:
      - id: System.FormatException
        name: FormatException
        nameWithType: FormatException
        qualifiedName: System.FormatException
        isExternal: true
      VB:
      - id: System.FormatException
        name: FormatException
        nameWithType: FormatException
        qualifiedName: System.FormatException
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.FormatException
  System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext):
    name:
      CSharp:
      - id: System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        name: GetObjectData
        nameWithType: Exception.GetObjectData
        qualifiedName: System.Exception.GetObjectData
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        name: GetObjectData
        nameWithType: Exception.GetObjectData
        qualifiedName: System.Exception.GetObjectData
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Exception
    commentId: M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  System.Exception.Message:
    name:
      CSharp:
      - id: System.Exception.Message
        name: Message
        nameWithType: Exception.Message
        qualifiedName: System.Exception.Message
        isExternal: true
      VB:
      - id: System.Exception.Message
        name: Message
        nameWithType: Exception.Message
        qualifiedName: System.Exception.Message
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.Message
  NodaTime.Text.InvalidPatternException.#ctor*:
    name:
      CSharp:
      - id: NodaTime.Text.InvalidPatternException.#ctor*
        name: InvalidPatternException
        nameWithType: InvalidPatternException.InvalidPatternException
        qualifiedName: NodaTime.Text.InvalidPatternException.InvalidPatternException
      VB:
      - id: NodaTime.Text.InvalidPatternException.#ctor*
        name: InvalidPatternException
        nameWithType: InvalidPatternException.InvalidPatternException
        qualifiedName: NodaTime.Text.InvalidPatternException.InvalidPatternException
    isDefinition: true
    commentId: Overload:NodaTime.Text.InvalidPatternException.#ctor
  NodaTime.Text.ParseResult{{T}}:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.ParseResult`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ParseResult{`0}
  NodaTime.Text.IPattern`1.Parse*:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse*
        name: Parse
        nameWithType: IPattern<T>.Parse
        qualifiedName: NodaTime.Text.IPattern<T>.Parse
      VB:
      - id: NodaTime.Text.IPattern`1.Parse*
        name: Parse
        nameWithType: IPattern(Of T).Parse
        qualifiedName: NodaTime.Text.IPattern(Of T).Parse
    isDefinition: true
    commentId: Overload:NodaTime.Text.IPattern`1.Parse
  T:
    name:
      CSharp:
      - name: T
        nameWithType: T
        qualifiedName: T
      VB:
      - name: T
        nameWithType: T
        qualifiedName: T
    isDefinition: true
  '{T}':
    name:
      CSharp:
      - name: T
        nameWithType: T
        qualifiedName: T
      VB:
      - name: T
        nameWithType: T
        qualifiedName: T
    isDefinition: false
    definition: T
    commentId: '!:T'
  NodaTime.Text.IPattern`1.Format*:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format*
        name: Format
        nameWithType: IPattern<T>.Format
        qualifiedName: NodaTime.Text.IPattern<T>.Format
      VB:
      - id: NodaTime.Text.IPattern`1.Format*
        name: Format
        nameWithType: IPattern(Of T).Format
        qualifiedName: NodaTime.Text.IPattern(Of T).Format
    isDefinition: true
    commentId: Overload:NodaTime.Text.IPattern`1.Format
  NodaTime.Text.IPattern{NodaTime.LocalDate}:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.IPattern{NodaTime.LocalDate}
  NodaTime.Text.LocalDatePattern:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern
        name: LocalDatePattern
        nameWithType: LocalDatePattern
        qualifiedName: NodaTime.Text.LocalDatePattern
      VB:
      - id: NodaTime.Text.LocalDatePattern
        name: LocalDatePattern
        nameWithType: LocalDatePattern
        qualifiedName: NodaTime.Text.LocalDatePattern
    isDefinition: true
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.LocalDatePattern
  NodaTime.Text.LocalDatePattern.IsoPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern.IsoPattern*
        name: IsoPattern
        nameWithType: LocalDatePattern.IsoPattern
        qualifiedName: NodaTime.Text.LocalDatePattern.IsoPattern
      VB:
      - id: NodaTime.Text.LocalDatePattern.IsoPattern*
        name: IsoPattern
        nameWithType: LocalDatePattern.IsoPattern
        qualifiedName: NodaTime.Text.LocalDatePattern.IsoPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDatePattern.IsoPattern
  NodaTime.Text.LocalDatePattern.PatternText*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern.PatternText*
        name: PatternText
        nameWithType: LocalDatePattern.PatternText
        qualifiedName: NodaTime.Text.LocalDatePattern.PatternText
      VB:
      - id: NodaTime.Text.LocalDatePattern.PatternText*
        name: PatternText
        nameWithType: LocalDatePattern.PatternText
        qualifiedName: NodaTime.Text.LocalDatePattern.PatternText
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDatePattern.PatternText
  NodaTime.Text.LocalDatePattern.TemplateValue*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern.TemplateValue*
        name: TemplateValue
        nameWithType: LocalDatePattern.TemplateValue
        qualifiedName: NodaTime.Text.LocalDatePattern.TemplateValue
      VB:
      - id: NodaTime.Text.LocalDatePattern.TemplateValue*
        name: TemplateValue
        nameWithType: LocalDatePattern.TemplateValue
        qualifiedName: NodaTime.Text.LocalDatePattern.TemplateValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDatePattern.TemplateValue
  NodaTime.Text.ParseResult{NodaTime.LocalDate}:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.ParseResult`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ParseResult{NodaTime.LocalDate}
  NodaTime.Text.LocalDatePattern.Parse*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern.Parse*
        name: Parse
        nameWithType: LocalDatePattern.Parse
        qualifiedName: NodaTime.Text.LocalDatePattern.Parse
      VB:
      - id: NodaTime.Text.LocalDatePattern.Parse*
        name: Parse
        nameWithType: LocalDatePattern.Parse
        qualifiedName: NodaTime.Text.LocalDatePattern.Parse
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDatePattern.Parse
  NodaTime.Text.IPattern{NodaTime.LocalDate}.Parse(System.String):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern<LocalDate>.Parse
        qualifiedName: NodaTime.Text.IPattern<NodaTime.LocalDate>.Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern(Of LocalDate).Parse
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.LocalDate).Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Parse(System.String)
    parent: NodaTime.Text.IPattern{NodaTime.LocalDate}
    commentId: M:NodaTime.Text.IPattern{NodaTime.LocalDate}.Parse(System.String)
  NodaTime.Text.LocalDatePattern.Format*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern.Format*
        name: Format
        nameWithType: LocalDatePattern.Format
        qualifiedName: NodaTime.Text.LocalDatePattern.Format
      VB:
      - id: NodaTime.Text.LocalDatePattern.Format*
        name: Format
        nameWithType: LocalDatePattern.Format
        qualifiedName: NodaTime.Text.LocalDatePattern.Format
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDatePattern.Format
  NodaTime.Text.IPattern{NodaTime.LocalDate}.Format(NodaTime.LocalDate):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern<LocalDate>.Format
        qualifiedName: NodaTime.Text.IPattern<NodaTime.LocalDate>.Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern(Of LocalDate).Format
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.LocalDate).Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Format(`0)
    parent: NodaTime.Text.IPattern{NodaTime.LocalDate}
    commentId: M:NodaTime.Text.IPattern{NodaTime.LocalDate}.Format(NodaTime.LocalDate)
  NodaTime.Text.LocalDatePattern.Create*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern.Create*
        name: Create
        nameWithType: LocalDatePattern.Create
        qualifiedName: NodaTime.Text.LocalDatePattern.Create
      VB:
      - id: NodaTime.Text.LocalDatePattern.Create*
        name: Create
        nameWithType: LocalDatePattern.Create
        qualifiedName: NodaTime.Text.LocalDatePattern.Create
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDatePattern.Create
  NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: LocalDatePattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture
      VB:
      - id: NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: LocalDatePattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture
  NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: LocalDatePattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture
      VB:
      - id: NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: LocalDatePattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture
  NodaTime.Text.LocalDatePattern.WithCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern.WithCulture*
        name: WithCulture
        nameWithType: LocalDatePattern.WithCulture
        qualifiedName: NodaTime.Text.LocalDatePattern.WithCulture
      VB:
      - id: NodaTime.Text.LocalDatePattern.WithCulture*
        name: WithCulture
        nameWithType: LocalDatePattern.WithCulture
        qualifiedName: NodaTime.Text.LocalDatePattern.WithCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDatePattern.WithCulture
  NodaTime.Text.LocalDatePattern.WithTemplateValue*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDatePattern.WithTemplateValue*
        name: WithTemplateValue
        nameWithType: LocalDatePattern.WithTemplateValue
        qualifiedName: NodaTime.Text.LocalDatePattern.WithTemplateValue
      VB:
      - id: NodaTime.Text.LocalDatePattern.WithTemplateValue*
        name: WithTemplateValue
        nameWithType: LocalDatePattern.WithTemplateValue
        qualifiedName: NodaTime.Text.LocalDatePattern.WithTemplateValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDatePattern.WithTemplateValue
  NodaTime.Text.IPattern{NodaTime.LocalDateTime}:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.IPattern{NodaTime.LocalDateTime}
  NodaTime.Text.LocalDateTimePattern:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern
        name: LocalDateTimePattern
        nameWithType: LocalDateTimePattern
        qualifiedName: NodaTime.Text.LocalDateTimePattern
      VB:
      - id: NodaTime.Text.LocalDateTimePattern
        name: LocalDateTimePattern
        nameWithType: LocalDateTimePattern
        qualifiedName: NodaTime.Text.LocalDateTimePattern
    isDefinition: true
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.LocalDateTimePattern
  NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern*
        name: GeneralIsoPattern
        nameWithType: LocalDateTimePattern.GeneralIsoPattern
        qualifiedName: NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern*
        name: GeneralIsoPattern
        nameWithType: LocalDateTimePattern.GeneralIsoPattern
        qualifiedName: NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern
  NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern*
        name: ExtendedIsoPattern
        nameWithType: LocalDateTimePattern.ExtendedIsoPattern
        qualifiedName: NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern*
        name: ExtendedIsoPattern
        nameWithType: LocalDateTimePattern.ExtendedIsoPattern
        qualifiedName: NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern
  NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern*
        name: BclRoundtripPattern
        nameWithType: LocalDateTimePattern.BclRoundtripPattern
        qualifiedName: NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern*
        name: BclRoundtripPattern
        nameWithType: LocalDateTimePattern.BclRoundtripPattern
        qualifiedName: NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern
  NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern*
        name: FullRoundtripPattern
        nameWithType: LocalDateTimePattern.FullRoundtripPattern
        qualifiedName: NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern*
        name: FullRoundtripPattern
        nameWithType: LocalDateTimePattern.FullRoundtripPattern
        qualifiedName: NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern
  NodaTime.Text.LocalDateTimePattern.PatternText*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.PatternText*
        name: PatternText
        nameWithType: LocalDateTimePattern.PatternText
        qualifiedName: NodaTime.Text.LocalDateTimePattern.PatternText
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.PatternText*
        name: PatternText
        nameWithType: LocalDateTimePattern.PatternText
        qualifiedName: NodaTime.Text.LocalDateTimePattern.PatternText
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.PatternText
  NodaTime.Text.LocalDateTimePattern.TemplateValue*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.TemplateValue*
        name: TemplateValue
        nameWithType: LocalDateTimePattern.TemplateValue
        qualifiedName: NodaTime.Text.LocalDateTimePattern.TemplateValue
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.TemplateValue*
        name: TemplateValue
        nameWithType: LocalDateTimePattern.TemplateValue
        qualifiedName: NodaTime.Text.LocalDateTimePattern.TemplateValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.TemplateValue
  NodaTime.Text.ParseResult{NodaTime.LocalDateTime}:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.ParseResult`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ParseResult{NodaTime.LocalDateTime}
  NodaTime.Text.LocalDateTimePattern.Parse*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.Parse*
        name: Parse
        nameWithType: LocalDateTimePattern.Parse
        qualifiedName: NodaTime.Text.LocalDateTimePattern.Parse
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.Parse*
        name: Parse
        nameWithType: LocalDateTimePattern.Parse
        qualifiedName: NodaTime.Text.LocalDateTimePattern.Parse
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.Parse
  NodaTime.Text.IPattern{NodaTime.LocalDateTime}.Parse(System.String):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern<LocalDateTime>.Parse
        qualifiedName: NodaTime.Text.IPattern<NodaTime.LocalDateTime>.Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern(Of LocalDateTime).Parse
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.LocalDateTime).Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Parse(System.String)
    parent: NodaTime.Text.IPattern{NodaTime.LocalDateTime}
    commentId: M:NodaTime.Text.IPattern{NodaTime.LocalDateTime}.Parse(System.String)
  NodaTime.Text.LocalDateTimePattern.Format*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.Format*
        name: Format
        nameWithType: LocalDateTimePattern.Format
        qualifiedName: NodaTime.Text.LocalDateTimePattern.Format
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.Format*
        name: Format
        nameWithType: LocalDateTimePattern.Format
        qualifiedName: NodaTime.Text.LocalDateTimePattern.Format
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.Format
  NodaTime.Text.IPattern{NodaTime.LocalDateTime}.Format(NodaTime.LocalDateTime):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern<LocalDateTime>.Format
        qualifiedName: NodaTime.Text.IPattern<NodaTime.LocalDateTime>.Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern(Of LocalDateTime).Format
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.LocalDateTime).Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDateTime
        name: LocalDateTime
        nameWithType: LocalDateTime
        qualifiedName: NodaTime.LocalDateTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Format(`0)
    parent: NodaTime.Text.IPattern{NodaTime.LocalDateTime}
    commentId: M:NodaTime.Text.IPattern{NodaTime.LocalDateTime}.Format(NodaTime.LocalDateTime)
  NodaTime.Text.LocalDateTimePattern.Create*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.Create*
        name: Create
        nameWithType: LocalDateTimePattern.Create
        qualifiedName: NodaTime.Text.LocalDateTimePattern.Create
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.Create*
        name: Create
        nameWithType: LocalDateTimePattern.Create
        qualifiedName: NodaTime.Text.LocalDateTimePattern.Create
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.Create
  NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: LocalDateTimePattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: LocalDateTimePattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture
  NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: LocalDateTimePattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: LocalDateTimePattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture
  NodaTime.Text.LocalDateTimePattern.WithCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.WithCulture*
        name: WithCulture
        nameWithType: LocalDateTimePattern.WithCulture
        qualifiedName: NodaTime.Text.LocalDateTimePattern.WithCulture
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.WithCulture*
        name: WithCulture
        nameWithType: LocalDateTimePattern.WithCulture
        qualifiedName: NodaTime.Text.LocalDateTimePattern.WithCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.WithCulture
  NodaTime.Text.LocalDateTimePattern.WithTemplateValue*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalDateTimePattern.WithTemplateValue*
        name: WithTemplateValue
        nameWithType: LocalDateTimePattern.WithTemplateValue
        qualifiedName: NodaTime.Text.LocalDateTimePattern.WithTemplateValue
      VB:
      - id: NodaTime.Text.LocalDateTimePattern.WithTemplateValue*
        name: WithTemplateValue
        nameWithType: LocalDateTimePattern.WithTemplateValue
        qualifiedName: NodaTime.Text.LocalDateTimePattern.WithTemplateValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalDateTimePattern.WithTemplateValue
  NodaTime.Text.IPattern{NodaTime.LocalTime}:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.IPattern{NodaTime.LocalTime}
  NodaTime.Text.LocalTimePattern:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern
        name: LocalTimePattern
        nameWithType: LocalTimePattern
        qualifiedName: NodaTime.Text.LocalTimePattern
      VB:
      - id: NodaTime.Text.LocalTimePattern
        name: LocalTimePattern
        nameWithType: LocalTimePattern
        qualifiedName: NodaTime.Text.LocalTimePattern
    isDefinition: true
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.LocalTimePattern
  NodaTime.Text.LocalTimePattern.ExtendedIsoPattern*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern.ExtendedIsoPattern*
        name: ExtendedIsoPattern
        nameWithType: LocalTimePattern.ExtendedIsoPattern
        qualifiedName: NodaTime.Text.LocalTimePattern.ExtendedIsoPattern
      VB:
      - id: NodaTime.Text.LocalTimePattern.ExtendedIsoPattern*
        name: ExtendedIsoPattern
        nameWithType: LocalTimePattern.ExtendedIsoPattern
        qualifiedName: NodaTime.Text.LocalTimePattern.ExtendedIsoPattern
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalTimePattern.ExtendedIsoPattern
  NodaTime.Text.LocalTimePattern.PatternText*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern.PatternText*
        name: PatternText
        nameWithType: LocalTimePattern.PatternText
        qualifiedName: NodaTime.Text.LocalTimePattern.PatternText
      VB:
      - id: NodaTime.Text.LocalTimePattern.PatternText*
        name: PatternText
        nameWithType: LocalTimePattern.PatternText
        qualifiedName: NodaTime.Text.LocalTimePattern.PatternText
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalTimePattern.PatternText
  NodaTime.Text.LocalTimePattern.TemplateValue*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern.TemplateValue*
        name: TemplateValue
        nameWithType: LocalTimePattern.TemplateValue
        qualifiedName: NodaTime.Text.LocalTimePattern.TemplateValue
      VB:
      - id: NodaTime.Text.LocalTimePattern.TemplateValue*
        name: TemplateValue
        nameWithType: LocalTimePattern.TemplateValue
        qualifiedName: NodaTime.Text.LocalTimePattern.TemplateValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalTimePattern.TemplateValue
  NodaTime.Text.ParseResult{NodaTime.LocalTime}:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.ParseResult`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ParseResult{NodaTime.LocalTime}
  NodaTime.Text.LocalTimePattern.Parse*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern.Parse*
        name: Parse
        nameWithType: LocalTimePattern.Parse
        qualifiedName: NodaTime.Text.LocalTimePattern.Parse
      VB:
      - id: NodaTime.Text.LocalTimePattern.Parse*
        name: Parse
        nameWithType: LocalTimePattern.Parse
        qualifiedName: NodaTime.Text.LocalTimePattern.Parse
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalTimePattern.Parse
  NodaTime.Text.IPattern{NodaTime.LocalTime}.Parse(System.String):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern<LocalTime>.Parse
        qualifiedName: NodaTime.Text.IPattern<NodaTime.LocalTime>.Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern(Of LocalTime).Parse
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.LocalTime).Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Parse(System.String)
    parent: NodaTime.Text.IPattern{NodaTime.LocalTime}
    commentId: M:NodaTime.Text.IPattern{NodaTime.LocalTime}.Parse(System.String)
  NodaTime.Text.LocalTimePattern.Format*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern.Format*
        name: Format
        nameWithType: LocalTimePattern.Format
        qualifiedName: NodaTime.Text.LocalTimePattern.Format
      VB:
      - id: NodaTime.Text.LocalTimePattern.Format*
        name: Format
        nameWithType: LocalTimePattern.Format
        qualifiedName: NodaTime.Text.LocalTimePattern.Format
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalTimePattern.Format
  NodaTime.Text.IPattern{NodaTime.LocalTime}.Format(NodaTime.LocalTime):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern<LocalTime>.Format
        qualifiedName: NodaTime.Text.IPattern<NodaTime.LocalTime>.Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern(Of LocalTime).Format
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.LocalTime).Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalTime
        name: LocalTime
        nameWithType: LocalTime
        qualifiedName: NodaTime.LocalTime
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Format(`0)
    parent: NodaTime.Text.IPattern{NodaTime.LocalTime}
    commentId: M:NodaTime.Text.IPattern{NodaTime.LocalTime}.Format(NodaTime.LocalTime)
  NodaTime.Text.LocalTimePattern.Create*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern.Create*
        name: Create
        nameWithType: LocalTimePattern.Create
        qualifiedName: NodaTime.Text.LocalTimePattern.Create
      VB:
      - id: NodaTime.Text.LocalTimePattern.Create*
        name: Create
        nameWithType: LocalTimePattern.Create
        qualifiedName: NodaTime.Text.LocalTimePattern.Create
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalTimePattern.Create
  NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: LocalTimePattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture
      VB:
      - id: NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: LocalTimePattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture
  NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: LocalTimePattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture
      VB:
      - id: NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: LocalTimePattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture
  NodaTime.Text.LocalTimePattern.WithCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern.WithCulture*
        name: WithCulture
        nameWithType: LocalTimePattern.WithCulture
        qualifiedName: NodaTime.Text.LocalTimePattern.WithCulture
      VB:
      - id: NodaTime.Text.LocalTimePattern.WithCulture*
        name: WithCulture
        nameWithType: LocalTimePattern.WithCulture
        qualifiedName: NodaTime.Text.LocalTimePattern.WithCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalTimePattern.WithCulture
  NodaTime.Text.LocalTimePattern.WithTemplateValue*:
    name:
      CSharp:
      - id: NodaTime.Text.LocalTimePattern.WithTemplateValue*
        name: WithTemplateValue
        nameWithType: LocalTimePattern.WithTemplateValue
        qualifiedName: NodaTime.Text.LocalTimePattern.WithTemplateValue
      VB:
      - id: NodaTime.Text.LocalTimePattern.WithTemplateValue*
        name: WithTemplateValue
        nameWithType: LocalTimePattern.WithTemplateValue
        qualifiedName: NodaTime.Text.LocalTimePattern.WithTemplateValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.LocalTimePattern.WithTemplateValue
  NodaTime.Text.IPattern{NodaTime.Offset}:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.IPattern{NodaTime.Offset}
  NodaTime.Text.OffsetPattern:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetPattern
        name: OffsetPattern
        nameWithType: OffsetPattern
        qualifiedName: NodaTime.Text.OffsetPattern
      VB:
      - id: NodaTime.Text.OffsetPattern
        name: OffsetPattern
        nameWithType: OffsetPattern
        qualifiedName: NodaTime.Text.OffsetPattern
    isDefinition: true
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.OffsetPattern
  NodaTime.Text.OffsetPattern.PatternText*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetPattern.PatternText*
        name: PatternText
        nameWithType: OffsetPattern.PatternText
        qualifiedName: NodaTime.Text.OffsetPattern.PatternText
      VB:
      - id: NodaTime.Text.OffsetPattern.PatternText*
        name: PatternText
        nameWithType: OffsetPattern.PatternText
        qualifiedName: NodaTime.Text.OffsetPattern.PatternText
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetPattern.PatternText
  NodaTime.Text.ParseResult{NodaTime.Offset}:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.ParseResult`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ParseResult{NodaTime.Offset}
  NodaTime.Text.OffsetPattern.Parse*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetPattern.Parse*
        name: Parse
        nameWithType: OffsetPattern.Parse
        qualifiedName: NodaTime.Text.OffsetPattern.Parse
      VB:
      - id: NodaTime.Text.OffsetPattern.Parse*
        name: Parse
        nameWithType: OffsetPattern.Parse
        qualifiedName: NodaTime.Text.OffsetPattern.Parse
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetPattern.Parse
  NodaTime.Text.IPattern{NodaTime.Offset}.Parse(System.String):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern<Offset>.Parse
        qualifiedName: NodaTime.Text.IPattern<NodaTime.Offset>.Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern(Of Offset).Parse
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.Offset).Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Parse(System.String)
    parent: NodaTime.Text.IPattern{NodaTime.Offset}
    commentId: M:NodaTime.Text.IPattern{NodaTime.Offset}.Parse(System.String)
  NodaTime.Text.OffsetPattern.Format*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetPattern.Format*
        name: Format
        nameWithType: OffsetPattern.Format
        qualifiedName: NodaTime.Text.OffsetPattern.Format
      VB:
      - id: NodaTime.Text.OffsetPattern.Format*
        name: Format
        nameWithType: OffsetPattern.Format
        qualifiedName: NodaTime.Text.OffsetPattern.Format
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetPattern.Format
  NodaTime.Text.IPattern{NodaTime.Offset}.Format(NodaTime.Offset):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern<Offset>.Format
        qualifiedName: NodaTime.Text.IPattern<NodaTime.Offset>.Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern(Of Offset).Format
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.Offset).Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Offset
        name: Offset
        nameWithType: Offset
        qualifiedName: NodaTime.Offset
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Format(`0)
    parent: NodaTime.Text.IPattern{NodaTime.Offset}
    commentId: M:NodaTime.Text.IPattern{NodaTime.Offset}.Format(NodaTime.Offset)
  NodaTime.Text.OffsetPattern.Create*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetPattern.Create*
        name: Create
        nameWithType: OffsetPattern.Create
        qualifiedName: NodaTime.Text.OffsetPattern.Create
      VB:
      - id: NodaTime.Text.OffsetPattern.Create*
        name: Create
        nameWithType: OffsetPattern.Create
        qualifiedName: NodaTime.Text.OffsetPattern.Create
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetPattern.Create
  NodaTime.Text.OffsetPattern.CreateWithCurrentCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetPattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: OffsetPattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.OffsetPattern.CreateWithCurrentCulture
      VB:
      - id: NodaTime.Text.OffsetPattern.CreateWithCurrentCulture*
        name: CreateWithCurrentCulture
        nameWithType: OffsetPattern.CreateWithCurrentCulture
        qualifiedName: NodaTime.Text.OffsetPattern.CreateWithCurrentCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetPattern.CreateWithCurrentCulture
  NodaTime.Text.OffsetPattern.CreateWithInvariantCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetPattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: OffsetPattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.OffsetPattern.CreateWithInvariantCulture
      VB:
      - id: NodaTime.Text.OffsetPattern.CreateWithInvariantCulture*
        name: CreateWithInvariantCulture
        nameWithType: OffsetPattern.CreateWithInvariantCulture
        qualifiedName: NodaTime.Text.OffsetPattern.CreateWithInvariantCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetPattern.CreateWithInvariantCulture
  NodaTime.Text.OffsetPattern.WithCulture*:
    name:
      CSharp:
      - id: NodaTime.Text.OffsetPattern.WithCulture*
        name: WithCulture
        nameWithType: OffsetPattern.WithCulture
        qualifiedName: NodaTime.Text.OffsetPattern.WithCulture
      VB:
      - id: NodaTime.Text.OffsetPattern.WithCulture*
        name: WithCulture
        nameWithType: OffsetPattern.WithCulture
        qualifiedName: NodaTime.Text.OffsetPattern.WithCulture
    isDefinition: true
    commentId: Overload:NodaTime.Text.OffsetPattern.WithCulture
  NodaTime.Text.IPattern{NodaTime.Period}:
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.IPattern`1
        name: IPattern
        nameWithType: IPattern
        qualifiedName: NodaTime.Text.IPattern
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.IPattern{NodaTime.Period}
  NodaTime.Text.PeriodPattern:
    name:
      CSharp:
      - id: NodaTime.Text.PeriodPattern
        name: PeriodPattern
        nameWithType: PeriodPattern
        qualifiedName: NodaTime.Text.PeriodPattern
      VB:
      - id: NodaTime.Text.PeriodPattern
        name: PeriodPattern
        nameWithType: PeriodPattern
        qualifiedName: NodaTime.Text.PeriodPattern
    isDefinition: true
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.PeriodPattern
  NodaTime.Text.ParseResult{NodaTime.Period}:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: NodaTime.Text.ParseResult`1
        name: ParseResult
        nameWithType: ParseResult
        qualifiedName: NodaTime.Text.ParseResult
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.ParseResult`1
    parent: NodaTime.Text
    commentId: T:NodaTime.Text.ParseResult{NodaTime.Period}
  NodaTime.Text.PeriodPattern.Parse*:
    name:
      CSharp:
      - id: NodaTime.Text.PeriodPattern.Parse*
        name: Parse
        nameWithType: PeriodPattern.Parse
        qualifiedName: NodaTime.Text.PeriodPattern.Parse
      VB:
      - id: NodaTime.Text.PeriodPattern.Parse*
        name: Parse
        nameWithType: PeriodPattern.Parse
        qualifiedName: NodaTime.Text.PeriodPattern.Parse
    isDefinition: true
    commentId: Overload:NodaTime.Text.PeriodPattern.Parse
  NodaTime.Text.IPattern{NodaTime.Period}.Parse(System.String):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern<Period>.Parse
        qualifiedName: NodaTime.Text.IPattern<NodaTime.Period>.Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Parse(System.String)
        name: Parse
        nameWithType: IPattern(Of Period).Parse
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.Period).Parse
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Parse(System.String)
    parent: NodaTime.Text.IPattern{NodaTime.Period}
    commentId: M:NodaTime.Text.IPattern{NodaTime.Period}.Parse(System.String)
  NodaTime.Text.PeriodPattern.Format*:
    name:
      CSharp:
      - id: NodaTime.Text.PeriodPattern.Format*
        name: Format
        nameWithType: PeriodPattern.Format
        qualifiedName: NodaTime.Text.PeriodPattern.Format
      VB:
      - id: NodaTime.Text.PeriodPattern.Format*
        name: Format
        nameWithType: PeriodPattern.Format
        qualifiedName: NodaTime.Text.PeriodPattern.Format
    isDefinition: true
    commentId: Overload:NodaTime.Text.PeriodPattern.Format
  NodaTime.Text.IPattern{NodaTime.Period}.Format(NodaTime.Period):
    name:
      CSharp:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern<Period>.Format
        qualifiedName: NodaTime.Text.IPattern<NodaTime.Period>.Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.Text.IPattern`1.Format(`0)
        name: Format
        nameWithType: IPattern(Of Period).Format
        qualifiedName: NodaTime.Text.IPattern(Of NodaTime.Period).Format
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Period
        name: Period
        nameWithType: Period
        qualifiedName: NodaTime.Period
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: NodaTime.Text.IPattern`1.Format(`0)
    parent: NodaTime.Text.IPattern{NodaTime.Period}
    commentId: M:NodaTime.Text.IPattern{NodaTime.Period}.Format(NodaTime.Period)
  NodaTime.Text.ParseResult`1.GetValueOrThrow:
    commentId: M:NodaTime.Text.ParseResult`1.GetValueOrThrow
  NodaTime.Text.ParseResult`1.Value*:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1.Value*
        name: Value
        nameWithType: ParseResult<T>.Value
        qualifiedName: NodaTime.Text.ParseResult<T>.Value
      VB:
      - id: NodaTime.Text.ParseResult`1.Value*
        name: Value
        nameWithType: ParseResult(Of T).Value
        qualifiedName: NodaTime.Text.ParseResult(Of T).Value
    isDefinition: true
    commentId: Overload:NodaTime.Text.ParseResult`1.Value
  NodaTime.Text.ParseResult`1.Exception*:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1.Exception*
        name: Exception
        nameWithType: ParseResult<T>.Exception
        qualifiedName: NodaTime.Text.ParseResult<T>.Exception
      VB:
      - id: NodaTime.Text.ParseResult`1.Exception*
        name: Exception
        nameWithType: ParseResult(Of T).Exception
        qualifiedName: NodaTime.Text.ParseResult(Of T).Exception
    isDefinition: true
    commentId: Overload:NodaTime.Text.ParseResult`1.Exception
  NodaTime.Text.ParseResult`1.Value:
    commentId: P:NodaTime.Text.ParseResult`1.Value
  NodaTime.Text.ParseResult`1.GetValueOrThrow*:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1.GetValueOrThrow*
        name: GetValueOrThrow
        nameWithType: ParseResult<T>.GetValueOrThrow
        qualifiedName: NodaTime.Text.ParseResult<T>.GetValueOrThrow
      VB:
      - id: NodaTime.Text.ParseResult`1.GetValueOrThrow*
        name: GetValueOrThrow
        nameWithType: ParseResult(Of T).GetValueOrThrow
        qualifiedName: NodaTime.Text.ParseResult(Of T).GetValueOrThrow
    isDefinition: true
    commentId: Overload:NodaTime.Text.ParseResult`1.GetValueOrThrow
  NodaTime.Text.ParseResult`1.TryGetValue*:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1.TryGetValue*
        name: TryGetValue
        nameWithType: ParseResult<T>.TryGetValue
        qualifiedName: NodaTime.Text.ParseResult<T>.TryGetValue
      VB:
      - id: NodaTime.Text.ParseResult`1.TryGetValue*
        name: TryGetValue
        nameWithType: ParseResult(Of T).TryGetValue
        qualifiedName: NodaTime.Text.ParseResult(Of T).TryGetValue
    isDefinition: true
    commentId: Overload:NodaTime.Text.ParseResult`1.TryGetValue
  NodaTime.Text.ParseResult`1.Success*:
    name:
      CSharp:
      - id: NodaTime.Text.ParseResult`1.Success*
        name: Success
        nameWithType: ParseResult<T>.Success
        qualifiedName: NodaTime.Text.ParseResult<T>.Success
      VB:
      - id: NodaTime.Text.ParseResult`1.Success*
        name: Success
        nameWithType: ParseResult(Of T).Success
        qualifiedName: NodaTime.Text.ParseResult(Of T).Success
    isDefinition: true
    commentId: Overload:NodaTime.Text.ParseResult`1.Success
  NodaTime.Text.UnparsableValueException.#ctor*:
    name:
      CSharp:
      - id: NodaTime.Text.UnparsableValueException.#ctor*
        name: UnparsableValueException
        nameWithType: UnparsableValueException.UnparsableValueException
        qualifiedName: NodaTime.Text.UnparsableValueException.UnparsableValueException
      VB:
      - id: NodaTime.Text.UnparsableValueException.#ctor*
        name: UnparsableValueException
        nameWithType: UnparsableValueException.UnparsableValueException
        qualifiedName: NodaTime.Text.UnparsableValueException.UnparsableValueException
    isDefinition: true
    commentId: Overload:NodaTime.Text.UnparsableValueException.#ctor
  NodaTime.Text.UnparsableValueException:
    name:
      CSharp:
      - id: NodaTime.Text.UnparsableValueException
        name: UnparsableValueException
        nameWithType: UnparsableValueException
        qualifiedName: NodaTime.Text.UnparsableValueException
      VB:
      - id: NodaTime.Text.UnparsableValueException
        name: UnparsableValueException
        nameWithType: UnparsableValueException
        qualifiedName: NodaTime.Text.UnparsableValueException
    isDefinition: true
    commentId: T:NodaTime.Text.UnparsableValueException
  NodaTime.DateTimeZone.Id:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.Id
        name: Id
        nameWithType: DateTimeZone.Id
        qualifiedName: NodaTime.DateTimeZone.Id
      VB:
      - id: NodaTime.DateTimeZone.Id
        name: Id
        nameWithType: DateTimeZone.Id
        qualifiedName: NodaTime.DateTimeZone.Id
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: P:NodaTime.DateTimeZone.Id
  NodaTime.DateTimeZone.MinOffset:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.MinOffset
        name: MinOffset
        nameWithType: DateTimeZone.MinOffset
        qualifiedName: NodaTime.DateTimeZone.MinOffset
      VB:
      - id: NodaTime.DateTimeZone.MinOffset
        name: MinOffset
        nameWithType: DateTimeZone.MinOffset
        qualifiedName: NodaTime.DateTimeZone.MinOffset
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: P:NodaTime.DateTimeZone.MinOffset
  NodaTime.DateTimeZone.MaxOffset:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.MaxOffset
        name: MaxOffset
        nameWithType: DateTimeZone.MaxOffset
        qualifiedName: NodaTime.DateTimeZone.MaxOffset
      VB:
      - id: NodaTime.DateTimeZone.MaxOffset
        name: MaxOffset
        nameWithType: DateTimeZone.MaxOffset
        qualifiedName: NodaTime.DateTimeZone.MaxOffset
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: P:NodaTime.DateTimeZone.MaxOffset
  NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)
        name: GetUtcOffset
        nameWithType: DateTimeZone.GetUtcOffset
        qualifiedName: NodaTime.DateTimeZone.GetUtcOffset
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)
        name: GetUtcOffset
        nameWithType: DateTimeZone.GetUtcOffset
        qualifiedName: NodaTime.DateTimeZone.GetUtcOffset
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)
  NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)
        name: AtStartOfDay
        nameWithType: DateTimeZone.AtStartOfDay
        qualifiedName: NodaTime.DateTimeZone.AtStartOfDay
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)
        name: AtStartOfDay
        nameWithType: DateTimeZone.AtStartOfDay
        qualifiedName: NodaTime.DateTimeZone.AtStartOfDay
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.LocalDate
        name: LocalDate
        nameWithType: LocalDate
        qualifiedName: NodaTime.LocalDate
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)
  NodaTime.DateTimeZone.ToString:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.ToString
        name: ToString
        nameWithType: DateTimeZone.ToString
        qualifiedName: NodaTime.DateTimeZone.ToString
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.ToString
        name: ToString
        nameWithType: DateTimeZone.ToString
        qualifiedName: NodaTime.DateTimeZone.ToString
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.ToString
  NodaTime.DateTimeZone.Equals(System.Object):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.Equals(System.Object)
        name: Equals
        nameWithType: DateTimeZone.Equals
        qualifiedName: NodaTime.DateTimeZone.Equals
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.Equals(System.Object)
        name: Equals
        nameWithType: DateTimeZone.Equals
        qualifiedName: NodaTime.DateTimeZone.Equals
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.Equals(System.Object)
  NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant,NodaTime.Instant):
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant,NodaTime.Instant)
        name: GetZoneIntervals
        nameWithType: DateTimeZone.GetZoneIntervals
        qualifiedName: NodaTime.DateTimeZone.GetZoneIntervals
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant,NodaTime.Instant)
        name: GetZoneIntervals
        nameWithType: DateTimeZone.GetZoneIntervals
        qualifiedName: NodaTime.DateTimeZone.GetZoneIntervals
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: NodaTime.Instant
        name: Instant
        nameWithType: Instant
        qualifiedName: NodaTime.Instant
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant,NodaTime.Instant)
  NodaTime.TimeZones.BclDateTimeZone.OriginalZone*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZone.OriginalZone*
        name: OriginalZone
        nameWithType: BclDateTimeZone.OriginalZone
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.OriginalZone
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZone.OriginalZone*
        name: OriginalZone
        nameWithType: BclDateTimeZone.OriginalZone
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.OriginalZone
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZone.OriginalZone
  NodaTime.TimeZones.BclDateTimeZone.DisplayName*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZone.DisplayName*
        name: DisplayName
        nameWithType: BclDateTimeZone.DisplayName
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.DisplayName
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZone.DisplayName*
        name: DisplayName
        nameWithType: BclDateTimeZone.DisplayName
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.DisplayName
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZone.DisplayName
  NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval*
        name: GetZoneInterval
        nameWithType: BclDateTimeZone.GetZoneInterval
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval*
        name: GetZoneInterval
        nameWithType: BclDateTimeZone.GetZoneInterval
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval
  NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo*
        name: FromTimeZoneInfo
        nameWithType: BclDateTimeZone.FromTimeZoneInfo
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo*
        name: FromTimeZoneInfo
        nameWithType: BclDateTimeZone.FromTimeZoneInfo
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo
  NodaTime.DateTimeZoneProviders.Bcl:
    commentId: P:NodaTime.DateTimeZoneProviders.Bcl
  System.TimeZoneInfo.Local:
    commentId: P:System.TimeZoneInfo.Local
  NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault*
        name: ForSystemDefault
        nameWithType: BclDateTimeZone.ForSystemDefault
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault*
        name: ForSystemDefault
        nameWithType: BclDateTimeZone.ForSystemDefault
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault
  System.NotImplementedException:
    commentId: T:System.NotImplementedException
  NodaTime.TimeZones.BclDateTimeZone.EqualsImpl*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZone.EqualsImpl*
        name: EqualsImpl
        nameWithType: BclDateTimeZone.EqualsImpl
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.EqualsImpl
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZone.EqualsImpl*
        name: EqualsImpl
        nameWithType: BclDateTimeZone.EqualsImpl
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.EqualsImpl
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZone.EqualsImpl
  NodaTime.DateTimeZone.GetHashCode:
    name:
      CSharp:
      - id: NodaTime.DateTimeZone.GetHashCode
        name: GetHashCode
        nameWithType: DateTimeZone.GetHashCode
        qualifiedName: NodaTime.DateTimeZone.GetHashCode
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.DateTimeZone.GetHashCode
        name: GetHashCode
        nameWithType: DateTimeZone.GetHashCode
        qualifiedName: NodaTime.DateTimeZone.GetHashCode
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.DateTimeZone
    commentId: M:NodaTime.DateTimeZone.GetHashCode
  NodaTime.TimeZones.BclDateTimeZone.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZone.GetHashCode*
        name: GetHashCode
        nameWithType: BclDateTimeZone.GetHashCode
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.GetHashCode
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZone.GetHashCode*
        name: GetHashCode
        nameWithType: BclDateTimeZone.GetHashCode
        qualifiedName: NodaTime.TimeZones.BclDateTimeZone.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZone.GetHashCode
  NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String):
    commentId: M:NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)
  NodaTime.TimeZones.BclDateTimeZoneSource.GetIds*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource.GetIds*
        name: GetIds
        nameWithType: BclDateTimeZoneSource.GetIds
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource.GetIds
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource.GetIds*
        name: GetIds
        nameWithType: BclDateTimeZoneSource.GetIds
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource.GetIds
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZoneSource.GetIds
  NodaTime.TimeZones.IDateTimeZoneSource.GetIds:
    name:
      CSharp:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.GetIds
        name: GetIds
        nameWithType: IDateTimeZoneSource.GetIds
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.GetIds
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.GetIds
        name: GetIds
        nameWithType: IDateTimeZoneSource.GetIds
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.GetIds
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.TimeZones.IDateTimeZoneSource
    commentId: M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds
  NodaTime.TimeZones.BclDateTimeZoneSource.VersionId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource.VersionId*
        name: VersionId
        nameWithType: BclDateTimeZoneSource.VersionId
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource.VersionId
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource.VersionId*
        name: VersionId
        nameWithType: BclDateTimeZoneSource.VersionId
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource.VersionId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZoneSource.VersionId
  NodaTime.TimeZones.IDateTimeZoneSource.VersionId:
    name:
      CSharp:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.VersionId
        name: VersionId
        nameWithType: IDateTimeZoneSource.VersionId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.VersionId
      VB:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.VersionId
        name: VersionId
        nameWithType: IDateTimeZoneSource.VersionId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.VersionId
    isDefinition: true
    parent: NodaTime.TimeZones.IDateTimeZoneSource
    commentId: P:NodaTime.TimeZones.IDateTimeZoneSource.VersionId
  NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String):
    name:
      CSharp:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
        name: ForId
        nameWithType: IDateTimeZoneSource.ForId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.ForId
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
        name: ForId
        nameWithType: IDateTimeZoneSource.ForId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.ForId
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.TimeZones.IDateTimeZoneSource
    commentId: M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)
  NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime#TimeZones#IDateTimeZoneSource#ForId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime#TimeZones#IDateTimeZoneSource#ForId*
        name: IDateTimeZoneSource.ForId
        nameWithType: BclDateTimeZoneSource.IDateTimeZoneSource.ForId
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime.TimeZones.IDateTimeZoneSource.ForId
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime#TimeZones#IDateTimeZoneSource#ForId*
        name: NodaTime.TimeZones.IDateTimeZoneSource.ForId
        nameWithType: BclDateTimeZoneSource.NodaTime.TimeZones.IDateTimeZoneSource.ForId
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime.TimeZones.IDateTimeZoneSource.ForId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime#TimeZones#IDateTimeZoneSource#ForId
  NodaTime.TimeZones.BclDateTimeZoneSource.ForId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource.ForId*
        name: ForId
        nameWithType: BclDateTimeZoneSource.ForId
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource.ForId
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource.ForId*
        name: ForId
        nameWithType: BclDateTimeZoneSource.ForId
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource.ForId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZoneSource.ForId
  NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId*
        name: MapTimeZoneId
        nameWithType: BclDateTimeZoneSource.MapTimeZoneId
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId
      VB:
      - id: NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId*
        name: MapTimeZoneId
        nameWithType: BclDateTimeZoneSource.MapTimeZoneId
        qualifiedName: NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId
  NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo):
    name:
      CSharp:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
        name: MapTimeZoneId
        nameWithType: IDateTimeZoneSource.MapTimeZoneId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.TimeZoneInfo
        name: TimeZoneInfo
        nameWithType: TimeZoneInfo
        qualifiedName: System.TimeZoneInfo
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
        name: MapTimeZoneId
        nameWithType: IDateTimeZoneSource.MapTimeZoneId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.TimeZoneInfo
        name: TimeZoneInfo
        nameWithType: TimeZoneInfo
        qualifiedName: System.TimeZoneInfo
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.TimeZones.IDateTimeZoneSource
    commentId: M:NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)
  NodaTime.TimeZones.InvalidDateTimeZoneSourceException:
    name:
      CSharp:
      - id: NodaTime.TimeZones.InvalidDateTimeZoneSourceException
        name: InvalidDateTimeZoneSourceException
        nameWithType: InvalidDateTimeZoneSourceException
        qualifiedName: NodaTime.TimeZones.InvalidDateTimeZoneSourceException
      VB:
      - id: NodaTime.TimeZones.InvalidDateTimeZoneSourceException
        name: InvalidDateTimeZoneSourceException
        nameWithType: InvalidDateTimeZoneSourceException
        qualifiedName: NodaTime.TimeZones.InvalidDateTimeZoneSourceException
    isDefinition: true
    commentId: T:NodaTime.TimeZones.InvalidDateTimeZoneSourceException
  NodaTime.TimeZones.DateTimeZoneCache.#ctor*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.DateTimeZoneCache.#ctor*
        name: DateTimeZoneCache
        nameWithType: DateTimeZoneCache.DateTimeZoneCache
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.DateTimeZoneCache
      VB:
      - id: NodaTime.TimeZones.DateTimeZoneCache.#ctor*
        name: DateTimeZoneCache
        nameWithType: DateTimeZoneCache.DateTimeZoneCache
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.DateTimeZoneCache
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.DateTimeZoneCache.#ctor
  NodaTime.TimeZones.DateTimeZoneCache.VersionId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.DateTimeZoneCache.VersionId*
        name: VersionId
        nameWithType: DateTimeZoneCache.VersionId
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.VersionId
      VB:
      - id: NodaTime.TimeZones.DateTimeZoneCache.VersionId*
        name: VersionId
        nameWithType: DateTimeZoneCache.VersionId
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.VersionId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.DateTimeZoneCache.VersionId
  NodaTime.IDateTimeZoneProvider.VersionId:
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider.VersionId
        name: VersionId
        nameWithType: IDateTimeZoneProvider.VersionId
        qualifiedName: NodaTime.IDateTimeZoneProvider.VersionId
      VB:
      - id: NodaTime.IDateTimeZoneProvider.VersionId
        name: VersionId
        nameWithType: IDateTimeZoneProvider.VersionId
        qualifiedName: NodaTime.IDateTimeZoneProvider.VersionId
    isDefinition: true
    parent: NodaTime.IDateTimeZoneProvider
    commentId: P:NodaTime.IDateTimeZoneProvider.VersionId
  NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault*
        name: GetSystemDefault
        nameWithType: DateTimeZoneCache.GetSystemDefault
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault
      VB:
      - id: NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault*
        name: GetSystemDefault
        nameWithType: DateTimeZoneCache.GetSystemDefault
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault
  NodaTime.TimeZones.DateTimeZoneCache.Ids*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.DateTimeZoneCache.Ids*
        name: Ids
        nameWithType: DateTimeZoneCache.Ids
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.Ids
      VB:
      - id: NodaTime.TimeZones.DateTimeZoneCache.Ids*
        name: Ids
        nameWithType: DateTimeZoneCache.Ids
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.Ids
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.DateTimeZoneCache.Ids
  NodaTime.IDateTimeZoneProvider.Ids:
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider.Ids
        name: Ids
        nameWithType: IDateTimeZoneProvider.Ids
        qualifiedName: NodaTime.IDateTimeZoneProvider.Ids
      VB:
      - id: NodaTime.IDateTimeZoneProvider.Ids
        name: Ids
        nameWithType: IDateTimeZoneProvider.Ids
        qualifiedName: NodaTime.IDateTimeZoneProvider.Ids
    isDefinition: true
    parent: NodaTime.IDateTimeZoneProvider
    commentId: P:NodaTime.IDateTimeZoneProvider.Ids
  NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull*
        name: GetZoneOrNull
        nameWithType: DateTimeZoneCache.GetZoneOrNull
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull
      VB:
      - id: NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull*
        name: GetZoneOrNull
        nameWithType: DateTimeZoneCache.GetZoneOrNull
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull
  NodaTime.TimeZones.DateTimeZoneCache.Item*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.DateTimeZoneCache.Item*
        name: Item
        nameWithType: DateTimeZoneCache.Item
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.Item
      VB:
      - id: NodaTime.TimeZones.DateTimeZoneCache.Item*
        name: Item
        nameWithType: DateTimeZoneCache.Item
        qualifiedName: NodaTime.TimeZones.DateTimeZoneCache.Item
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.DateTimeZoneCache.Item
  NodaTime.IDateTimeZoneProvider.Item(System.String):
    name:
      CSharp:
      - id: NodaTime.IDateTimeZoneProvider.Item(System.String)
        name: Item
        nameWithType: IDateTimeZoneProvider.Item
        qualifiedName: NodaTime.IDateTimeZoneProvider.Item
      - name: '['
        nameWithType: '['
        qualifiedName: '['
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ']'
        nameWithType: ']'
        qualifiedName: ']'
      VB:
      - id: NodaTime.IDateTimeZoneProvider.Item(System.String)
        name: Item
        nameWithType: IDateTimeZoneProvider.Item
        qualifiedName: NodaTime.IDateTimeZoneProvider.Item
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: NodaTime.IDateTimeZoneProvider
    commentId: P:NodaTime.IDateTimeZoneProvider.Item(System.String)
  System.TimeZoneNotFoundException:
    name:
      CSharp:
      - id: System.TimeZoneNotFoundException
        name: TimeZoneNotFoundException
        nameWithType: TimeZoneNotFoundException
        qualifiedName: System.TimeZoneNotFoundException
        isExternal: true
      VB:
      - id: System.TimeZoneNotFoundException
        name: TimeZoneNotFoundException
        nameWithType: TimeZoneNotFoundException
        qualifiedName: System.TimeZoneNotFoundException
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.TimeZoneNotFoundException
  NodaTime.TimeZones.DateTimeZoneNotFoundException.#ctor*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.DateTimeZoneNotFoundException.#ctor*
        name: DateTimeZoneNotFoundException
        nameWithType: DateTimeZoneNotFoundException.DateTimeZoneNotFoundException
        qualifiedName: NodaTime.TimeZones.DateTimeZoneNotFoundException.DateTimeZoneNotFoundException
      VB:
      - id: NodaTime.TimeZones.DateTimeZoneNotFoundException.#ctor*
        name: DateTimeZoneNotFoundException
        nameWithType: DateTimeZoneNotFoundException.DateTimeZoneNotFoundException
        qualifiedName: NodaTime.TimeZones.DateTimeZoneNotFoundException.DateTimeZoneNotFoundException
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.DateTimeZoneNotFoundException.#ctor
  ? NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)
  : commentId: M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)
  NodaTime.TimeZones.AmbiguousTimeResolver:
    name:
      CSharp:
      - id: NodaTime.TimeZones.AmbiguousTimeResolver
        name: AmbiguousTimeResolver
        nameWithType: AmbiguousTimeResolver
        qualifiedName: NodaTime.TimeZones.AmbiguousTimeResolver
      VB:
      - id: NodaTime.TimeZones.AmbiguousTimeResolver
        name: AmbiguousTimeResolver
        nameWithType: AmbiguousTimeResolver
        qualifiedName: NodaTime.TimeZones.AmbiguousTimeResolver
    isDefinition: true
    parent: NodaTime.TimeZones
    commentId: T:NodaTime.TimeZones.AmbiguousTimeResolver
  NodaTime.TimeZones.SkippedTimeResolver:
    name:
      CSharp:
      - id: NodaTime.TimeZones.SkippedTimeResolver
        name: SkippedTimeResolver
        nameWithType: SkippedTimeResolver
        qualifiedName: NodaTime.TimeZones.SkippedTimeResolver
      VB:
      - id: NodaTime.TimeZones.SkippedTimeResolver
        name: SkippedTimeResolver
        nameWithType: SkippedTimeResolver
        qualifiedName: NodaTime.TimeZones.SkippedTimeResolver
    isDefinition: true
    parent: NodaTime.TimeZones
    commentId: T:NodaTime.TimeZones.SkippedTimeResolver
  NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver):
    commentId: M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)
  System.Double:
    name:
      CSharp:
      - id: System.Double
        name: Double
        nameWithType: Double
        qualifiedName: System.Double
        isExternal: true
      VB:
      - id: System.Double
        name: Double
        nameWithType: Double
        qualifiedName: System.Double
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Double
  NodaTime.TimeZones.TzdbZoneLocation.Latitude*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbZoneLocation.Latitude*
        name: Latitude
        nameWithType: TzdbZoneLocation.Latitude
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.Latitude
      VB:
      - id: NodaTime.TimeZones.TzdbZoneLocation.Latitude*
        name: Latitude
        nameWithType: TzdbZoneLocation.Latitude
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.Latitude
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbZoneLocation.Latitude
  NodaTime.TimeZones.TzdbZoneLocation.Longitude*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbZoneLocation.Longitude*
        name: Longitude
        nameWithType: TzdbZoneLocation.Longitude
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.Longitude
      VB:
      - id: NodaTime.TimeZones.TzdbZoneLocation.Longitude*
        name: Longitude
        nameWithType: TzdbZoneLocation.Longitude
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.Longitude
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbZoneLocation.Longitude
  NodaTime.TimeZones.TzdbZoneLocation.CountryName*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbZoneLocation.CountryName*
        name: CountryName
        nameWithType: TzdbZoneLocation.CountryName
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.CountryName
      VB:
      - id: NodaTime.TimeZones.TzdbZoneLocation.CountryName*
        name: CountryName
        nameWithType: TzdbZoneLocation.CountryName
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.CountryName
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbZoneLocation.CountryName
  NodaTime.TimeZones.TzdbZoneLocation.CountryCode*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbZoneLocation.CountryCode*
        name: CountryCode
        nameWithType: TzdbZoneLocation.CountryCode
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.CountryCode
      VB:
      - id: NodaTime.TimeZones.TzdbZoneLocation.CountryCode*
        name: CountryCode
        nameWithType: TzdbZoneLocation.CountryCode
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.CountryCode
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbZoneLocation.CountryCode
  NodaTime.TimeZones.TzdbZoneLocation.ZoneId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbZoneLocation.ZoneId*
        name: ZoneId
        nameWithType: TzdbZoneLocation.ZoneId
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.ZoneId
      VB:
      - id: NodaTime.TimeZones.TzdbZoneLocation.ZoneId*
        name: ZoneId
        nameWithType: TzdbZoneLocation.ZoneId
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.ZoneId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbZoneLocation.ZoneId
  NodaTime.TimeZones.TzdbZoneLocation.Comment*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbZoneLocation.Comment*
        name: Comment
        nameWithType: TzdbZoneLocation.Comment
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.Comment
      VB:
      - id: NodaTime.TimeZones.TzdbZoneLocation.Comment*
        name: Comment
        nameWithType: TzdbZoneLocation.Comment
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.Comment
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbZoneLocation.Comment
  NodaTime.TimeZones.TzdbZoneLocation.#ctor*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbZoneLocation.#ctor*
        name: TzdbZoneLocation
        nameWithType: TzdbZoneLocation.TzdbZoneLocation
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.TzdbZoneLocation
      VB:
      - id: NodaTime.TimeZones.TzdbZoneLocation.#ctor*
        name: TzdbZoneLocation
        nameWithType: TzdbZoneLocation.TzdbZoneLocation
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation.TzdbZoneLocation
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbZoneLocation.#ctor
  NodaTime.TimeZones.TzdbZoneLocation:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbZoneLocation
        name: TzdbZoneLocation
        nameWithType: TzdbZoneLocation
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation
      VB:
      - id: NodaTime.TimeZones.TzdbZoneLocation
        name: TzdbZoneLocation
        nameWithType: TzdbZoneLocation
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation
    isDefinition: true
    commentId: T:NodaTime.TimeZones.TzdbZoneLocation
  NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous:
    commentId: F:NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous
  NodaTime.TimeZones.Resolvers.ThrowWhenSkipped:
    commentId: F:NodaTime.TimeZones.Resolvers.ThrowWhenSkipped
  NodaTime.TimeZones.Resolvers.ReturnLater:
    commentId: F:NodaTime.TimeZones.Resolvers.ReturnLater
  NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter:
    commentId: F:NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter
  NodaTime.TimeZones.Resolvers.CreateMappingResolver*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Resolvers.CreateMappingResolver*
        name: CreateMappingResolver
        nameWithType: Resolvers.CreateMappingResolver
        qualifiedName: NodaTime.TimeZones.Resolvers.CreateMappingResolver
      VB:
      - id: NodaTime.TimeZones.Resolvers.CreateMappingResolver*
        name: CreateMappingResolver
        nameWithType: Resolvers.CreateMappingResolver
        qualifiedName: NodaTime.TimeZones.Resolvers.CreateMappingResolver
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.Resolvers.CreateMappingResolver
  NodaTime.TimeZones.InvalidDateTimeZoneSourceException.#ctor*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.InvalidDateTimeZoneSourceException.#ctor*
        name: InvalidDateTimeZoneSourceException
        nameWithType: InvalidDateTimeZoneSourceException.InvalidDateTimeZoneSourceException
        qualifiedName: NodaTime.TimeZones.InvalidDateTimeZoneSourceException.InvalidDateTimeZoneSourceException
      VB:
      - id: NodaTime.TimeZones.InvalidDateTimeZoneSourceException.#ctor*
        name: InvalidDateTimeZoneSourceException
        nameWithType: InvalidDateTimeZoneSourceException.InvalidDateTimeZoneSourceException
        qualifiedName: NodaTime.TimeZones.InvalidDateTimeZoneSourceException.InvalidDateTimeZoneSourceException
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.InvalidDateTimeZoneSourceException.#ctor
  NodaTime.TimeZones.IDateTimeZoneSource.GetIds*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.GetIds*
        name: GetIds
        nameWithType: IDateTimeZoneSource.GetIds
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.GetIds
      VB:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.GetIds*
        name: GetIds
        nameWithType: IDateTimeZoneSource.GetIds
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.GetIds
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.IDateTimeZoneSource.GetIds
  NodaTime.TimeZones.IDateTimeZoneSource.VersionId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.VersionId*
        name: VersionId
        nameWithType: IDateTimeZoneSource.VersionId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.VersionId
      VB:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.VersionId*
        name: VersionId
        nameWithType: IDateTimeZoneSource.VersionId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.VersionId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.IDateTimeZoneSource.VersionId
  NodaTime.TimeZones.IDateTimeZoneSource.ForId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.ForId*
        name: ForId
        nameWithType: IDateTimeZoneSource.ForId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.ForId
      VB:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.ForId*
        name: ForId
        nameWithType: IDateTimeZoneSource.ForId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.ForId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.IDateTimeZoneSource.ForId
  NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId*
        name: MapTimeZoneId
        nameWithType: IDateTimeZoneSource.MapTimeZoneId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId
      VB:
      - id: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId*
        name: MapTimeZoneId
        nameWithType: IDateTimeZoneSource.MapTimeZoneId
        qualifiedName: NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId
  NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options):
    commentId: M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)
  System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}:
    name:
      CSharp:
      - id: System.Collections.Generic.IEqualityComparer`1
        name: IEqualityComparer
        nameWithType: IEqualityComparer
        qualifiedName: System.Collections.Generic.IEqualityComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IEqualityComparer`1
        name: IEqualityComparer
        nameWithType: IEqualityComparer
        qualifiedName: System.Collections.Generic.IEqualityComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IEqualityComparer`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}
  NodaTime.TimeZones.ZoneEqualityComparer:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneEqualityComparer
        name: ZoneEqualityComparer
        nameWithType: ZoneEqualityComparer
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer
      VB:
      - id: NodaTime.TimeZones.ZoneEqualityComparer
        name: ZoneEqualityComparer
        nameWithType: ZoneEqualityComparer
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer
    isDefinition: true
    parent: NodaTime.TimeZones
    commentId: T:NodaTime.TimeZones.ZoneEqualityComparer
  NodaTime.TimeZones.ZoneEqualityComparer.ForInterval*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneEqualityComparer.ForInterval*
        name: ForInterval
        nameWithType: ZoneEqualityComparer.ForInterval
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer.ForInterval
      VB:
      - id: NodaTime.TimeZones.ZoneEqualityComparer.ForInterval*
        name: ForInterval
        nameWithType: ZoneEqualityComparer.ForInterval
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer.ForInterval
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneEqualityComparer.ForInterval
  NodaTime.TimeZones.ZoneEqualityComparer.Options:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneEqualityComparer.Options
        name: ZoneEqualityComparer.Options
        nameWithType: ZoneEqualityComparer.Options
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer.Options
      VB:
      - id: NodaTime.TimeZones.ZoneEqualityComparer.Options
        name: ZoneEqualityComparer.Options
        nameWithType: ZoneEqualityComparer.Options
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer.Options
    isDefinition: true
    parent: NodaTime.TimeZones
    commentId: T:NodaTime.TimeZones.ZoneEqualityComparer.Options
  NodaTime.TimeZones.ZoneEqualityComparer.WithOptions*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneEqualityComparer.WithOptions*
        name: WithOptions
        nameWithType: ZoneEqualityComparer.WithOptions
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer.WithOptions
      VB:
      - id: NodaTime.TimeZones.ZoneEqualityComparer.WithOptions*
        name: WithOptions
        nameWithType: ZoneEqualityComparer.WithOptions
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer.WithOptions
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions
  NodaTime.TimeZones.ZoneEqualityComparer.Equals*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneEqualityComparer.Equals*
        name: Equals
        nameWithType: ZoneEqualityComparer.Equals
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer.Equals
      VB:
      - id: NodaTime.TimeZones.ZoneEqualityComparer.Equals*
        name: Equals
        nameWithType: ZoneEqualityComparer.Equals
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer.Equals
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneEqualityComparer.Equals
  System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0):
    name:
      CSharp:
      - id: System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)
        name: Equals
        nameWithType: IEqualityComparer<T>.Equals
        qualifiedName: System.Collections.Generic.IEqualityComparer<T>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)
        name: Equals
        nameWithType: IEqualityComparer(Of T).Equals
        qualifiedName: System.Collections.Generic.IEqualityComparer(Of T).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)
  System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}.Equals(NodaTime.DateTimeZone,NodaTime.DateTimeZone):
    name:
      CSharp:
      - id: System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)
        name: Equals
        nameWithType: IEqualityComparer<DateTimeZone>.Equals
        qualifiedName: System.Collections.Generic.IEqualityComparer<NodaTime.DateTimeZone>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)
        name: Equals
        nameWithType: IEqualityComparer(Of DateTimeZone).Equals
        qualifiedName: System.Collections.Generic.IEqualityComparer(Of NodaTime.DateTimeZone).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)
    parent: System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}
    commentId: M:System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}.Equals(NodaTime.DateTimeZone,NodaTime.DateTimeZone)
  NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode*
        name: GetHashCode
        nameWithType: ZoneEqualityComparer.GetHashCode
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode
      VB:
      - id: NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode*
        name: GetHashCode
        nameWithType: ZoneEqualityComparer.GetHashCode
        qualifiedName: NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode
  System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0):
    name:
      CSharp:
      - id: System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)
        name: GetHashCode
        nameWithType: IEqualityComparer<T>.GetHashCode
        qualifiedName: System.Collections.Generic.IEqualityComparer<T>.GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)
        name: GetHashCode
        nameWithType: IEqualityComparer(Of T).GetHashCode
        qualifiedName: System.Collections.Generic.IEqualityComparer(Of T).GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)
  System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}.GetHashCode(NodaTime.DateTimeZone):
    name:
      CSharp:
      - id: System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)
        name: GetHashCode
        nameWithType: IEqualityComparer<DateTimeZone>.GetHashCode
        qualifiedName: System.Collections.Generic.IEqualityComparer<NodaTime.DateTimeZone>.GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)
        name: GetHashCode
        nameWithType: IEqualityComparer(Of DateTimeZone).GetHashCode
        qualifiedName: System.Collections.Generic.IEqualityComparer(Of NodaTime.DateTimeZone).GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.DateTimeZone
        name: DateTimeZone
        nameWithType: DateTimeZone
        qualifiedName: NodaTime.DateTimeZone
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)
    parent: System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}
    commentId: M:System.Collections.Generic.IEqualityComparer{NodaTime.DateTimeZone}.GetHashCode(NodaTime.DateTimeZone)
  NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset:
    commentId: F:NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset
  NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions:
    commentId: F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions
  NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions:
    commentId: F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions
  System.IEquatable{NodaTime.TimeZones.ZoneInterval}:
    name:
      CSharp:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.TimeZones.ZoneInterval
        name: ZoneInterval
        nameWithType: ZoneInterval
        qualifiedName: NodaTime.TimeZones.ZoneInterval
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IEquatable`1
        name: IEquatable
        nameWithType: IEquatable
        qualifiedName: System.IEquatable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.TimeZones.ZoneInterval
        name: ZoneInterval
        nameWithType: ZoneInterval
        qualifiedName: NodaTime.TimeZones.ZoneInterval
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1
    parent: System
    commentId: T:System.IEquatable{NodaTime.TimeZones.ZoneInterval}
  NodaTime.TimeZones.ZoneInterval.WallOffset:
    commentId: P:NodaTime.TimeZones.ZoneInterval.WallOffset
  NodaTime.TimeZones.ZoneInterval.#ctor*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.#ctor*
        name: ZoneInterval
        nameWithType: ZoneInterval.ZoneInterval
        qualifiedName: NodaTime.TimeZones.ZoneInterval.ZoneInterval
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.#ctor*
        name: ZoneInterval
        nameWithType: ZoneInterval.ZoneInterval
        qualifiedName: NodaTime.TimeZones.ZoneInterval.ZoneInterval
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.#ctor
  NodaTime.TimeZones.ZoneInterval.StandardOffset*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.StandardOffset*
        name: StandardOffset
        nameWithType: ZoneInterval.StandardOffset
        qualifiedName: NodaTime.TimeZones.ZoneInterval.StandardOffset
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.StandardOffset*
        name: StandardOffset
        nameWithType: ZoneInterval.StandardOffset
        qualifiedName: NodaTime.TimeZones.ZoneInterval.StandardOffset
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.StandardOffset
  NodaTime.TimeZones.ZoneInterval.Duration*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.Duration*
        name: Duration
        nameWithType: ZoneInterval.Duration
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Duration
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.Duration*
        name: Duration
        nameWithType: ZoneInterval.Duration
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Duration
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.Duration
  NodaTime.TimeZones.ZoneInterval.End*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.End*
        name: End
        nameWithType: ZoneInterval.End
        qualifiedName: NodaTime.TimeZones.ZoneInterval.End
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.End*
        name: End
        nameWithType: ZoneInterval.End
        qualifiedName: NodaTime.TimeZones.ZoneInterval.End
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.End
  NodaTime.TimeZones.ZoneInterval.IsoLocalStart*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.IsoLocalStart*
        name: IsoLocalStart
        nameWithType: ZoneInterval.IsoLocalStart
        qualifiedName: NodaTime.TimeZones.ZoneInterval.IsoLocalStart
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.IsoLocalStart*
        name: IsoLocalStart
        nameWithType: ZoneInterval.IsoLocalStart
        qualifiedName: NodaTime.TimeZones.ZoneInterval.IsoLocalStart
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.IsoLocalStart
  NodaTime.TimeZones.ZoneInterval.IsoLocalEnd*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.IsoLocalEnd*
        name: IsoLocalEnd
        nameWithType: ZoneInterval.IsoLocalEnd
        qualifiedName: NodaTime.TimeZones.ZoneInterval.IsoLocalEnd
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.IsoLocalEnd*
        name: IsoLocalEnd
        nameWithType: ZoneInterval.IsoLocalEnd
        qualifiedName: NodaTime.TimeZones.ZoneInterval.IsoLocalEnd
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.IsoLocalEnd
  NodaTime.TimeZones.ZoneInterval.Name*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.Name*
        name: Name
        nameWithType: ZoneInterval.Name
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Name
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.Name*
        name: Name
        nameWithType: ZoneInterval.Name
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Name
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.Name
  NodaTime.TimeZones.ZoneInterval.WallOffset*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.WallOffset*
        name: WallOffset
        nameWithType: ZoneInterval.WallOffset
        qualifiedName: NodaTime.TimeZones.ZoneInterval.WallOffset
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.WallOffset*
        name: WallOffset
        nameWithType: ZoneInterval.WallOffset
        qualifiedName: NodaTime.TimeZones.ZoneInterval.WallOffset
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.WallOffset
  NodaTime.TimeZones.ZoneInterval.Savings*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.Savings*
        name: Savings
        nameWithType: ZoneInterval.Savings
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Savings
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.Savings*
        name: Savings
        nameWithType: ZoneInterval.Savings
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Savings
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.Savings
  NodaTime.TimeZones.ZoneInterval.Start*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.Start*
        name: Start
        nameWithType: ZoneInterval.Start
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Start
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.Start*
        name: Start
        nameWithType: ZoneInterval.Start
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Start
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.Start
  NodaTime.TimeZones.ZoneInterval.Contains*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.Contains*
        name: Contains
        nameWithType: ZoneInterval.Contains
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Contains
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.Contains*
        name: Contains
        nameWithType: ZoneInterval.Contains
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Contains
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.Contains
  NodaTime.TimeZones.ZoneInterval.Equals*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.Equals*
        name: Equals
        nameWithType: ZoneInterval.Equals
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Equals
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.Equals*
        name: Equals
        nameWithType: ZoneInterval.Equals
        qualifiedName: NodaTime.TimeZones.ZoneInterval.Equals
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.Equals
  System.IEquatable{NodaTime.TimeZones.ZoneInterval}.Equals(NodaTime.TimeZones.ZoneInterval):
    name:
      CSharp:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable<ZoneInterval>.Equals
        qualifiedName: System.IEquatable<NodaTime.TimeZones.ZoneInterval>.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.TimeZones.ZoneInterval
        name: ZoneInterval
        nameWithType: ZoneInterval
        qualifiedName: NodaTime.TimeZones.ZoneInterval
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IEquatable`1.Equals(`0)
        name: Equals
        nameWithType: IEquatable(Of ZoneInterval).Equals
        qualifiedName: System.IEquatable(Of NodaTime.TimeZones.ZoneInterval).Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: NodaTime.TimeZones.ZoneInterval
        name: ZoneInterval
        nameWithType: ZoneInterval
        qualifiedName: NodaTime.TimeZones.ZoneInterval
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IEquatable`1.Equals(`0)
    parent: System.IEquatable{NodaTime.TimeZones.ZoneInterval}
    commentId: M:System.IEquatable{NodaTime.TimeZones.ZoneInterval}.Equals(NodaTime.TimeZones.ZoneInterval)
  NodaTime.TimeZones.ZoneInterval.GetHashCode*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.GetHashCode*
        name: GetHashCode
        nameWithType: ZoneInterval.GetHashCode
        qualifiedName: NodaTime.TimeZones.ZoneInterval.GetHashCode
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.GetHashCode*
        name: GetHashCode
        nameWithType: ZoneInterval.GetHashCode
        qualifiedName: NodaTime.TimeZones.ZoneInterval.GetHashCode
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.GetHashCode
  NodaTime.TimeZones.ZoneInterval.ToString*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneInterval.ToString*
        name: ToString
        nameWithType: ZoneInterval.ToString
        qualifiedName: NodaTime.TimeZones.ZoneInterval.ToString
      VB:
      - id: NodaTime.TimeZones.ZoneInterval.ToString*
        name: ToString
        nameWithType: ZoneInterval.ToString
        qualifiedName: NodaTime.TimeZones.ZoneInterval.ToString
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneInterval.ToString
  NodaTime.TimeZones.ZoneLocalMapping.Count*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneLocalMapping.Count*
        name: Count
        nameWithType: ZoneLocalMapping.Count
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.Count
      VB:
      - id: NodaTime.TimeZones.ZoneLocalMapping.Count*
        name: Count
        nameWithType: ZoneLocalMapping.Count
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.Count
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneLocalMapping.Count
  NodaTime.TimeZones.ZoneLocalMapping.Zone*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneLocalMapping.Zone*
        name: Zone
        nameWithType: ZoneLocalMapping.Zone
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.Zone
      VB:
      - id: NodaTime.TimeZones.ZoneLocalMapping.Zone*
        name: Zone
        nameWithType: ZoneLocalMapping.Zone
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.Zone
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneLocalMapping.Zone
  NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime*
        name: LocalDateTime
        nameWithType: ZoneLocalMapping.LocalDateTime
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime
      VB:
      - id: NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime*
        name: LocalDateTime
        nameWithType: ZoneLocalMapping.LocalDateTime
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime
  NodaTime.TimeZones.ZoneLocalMapping.LateInterval:
    commentId: P:NodaTime.TimeZones.ZoneLocalMapping.LateInterval
  NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval*
        name: EarlyInterval
        nameWithType: ZoneLocalMapping.EarlyInterval
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval
      VB:
      - id: NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval*
        name: EarlyInterval
        nameWithType: ZoneLocalMapping.EarlyInterval
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval
  NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval:
    commentId: P:NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval
  NodaTime.TimeZones.ZoneLocalMapping.LateInterval*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneLocalMapping.LateInterval*
        name: LateInterval
        nameWithType: ZoneLocalMapping.LateInterval
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.LateInterval
      VB:
      - id: NodaTime.TimeZones.ZoneLocalMapping.LateInterval*
        name: LateInterval
        nameWithType: ZoneLocalMapping.LateInterval
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.LateInterval
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneLocalMapping.LateInterval
  NodaTime.TimeZones.ZoneLocalMapping.Single*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneLocalMapping.Single*
        name: Single
        nameWithType: ZoneLocalMapping.Single
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.Single
      VB:
      - id: NodaTime.TimeZones.ZoneLocalMapping.Single*
        name: Single
        nameWithType: ZoneLocalMapping.Single
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.Single
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneLocalMapping.Single
  NodaTime.TimeZones.ZoneLocalMapping.First*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneLocalMapping.First*
        name: First
        nameWithType: ZoneLocalMapping.First
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.First
      VB:
      - id: NodaTime.TimeZones.ZoneLocalMapping.First*
        name: First
        nameWithType: ZoneLocalMapping.First
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.First
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneLocalMapping.First
  NodaTime.TimeZones.ZoneLocalMapping.Last*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.ZoneLocalMapping.Last*
        name: Last
        nameWithType: ZoneLocalMapping.Last
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.Last
      VB:
      - id: NodaTime.TimeZones.ZoneLocalMapping.Last*
        name: Last
        nameWithType: ZoneLocalMapping.Last
        qualifiedName: NodaTime.TimeZones.ZoneLocalMapping.Last
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.ZoneLocalMapping.Last
  NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String):
    commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)
  NodaTime.TimeZones.TzdbDateTimeZoneSource.Default*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.Default*
        name: Default
        nameWithType: TzdbDateTimeZoneSource.Default
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.Default
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.Default*
        name: Default
        nameWithType: TzdbDateTimeZoneSource.Default
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.Default
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.Default
  NodaTime.Utility.InvalidNodaDataException:
    name:
      CSharp:
      - id: NodaTime.Utility.InvalidNodaDataException
        name: InvalidNodaDataException
        nameWithType: InvalidNodaDataException
        qualifiedName: NodaTime.Utility.InvalidNodaDataException
      VB:
      - id: NodaTime.Utility.InvalidNodaDataException
        name: InvalidNodaDataException
        nameWithType: InvalidNodaDataException
        qualifiedName: NodaTime.Utility.InvalidNodaDataException
    isDefinition: true
    commentId: T:NodaTime.Utility.InvalidNodaDataException
  System.Resources.MissingManifestResourceException:
    commentId: T:System.Resources.MissingManifestResourceException
  NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor*
        name: TzdbDateTimeZoneSource
        nameWithType: TzdbDateTimeZoneSource.TzdbDateTimeZoneSource
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbDateTimeZoneSource
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor*
        name: TzdbDateTimeZoneSource
        nameWithType: TzdbDateTimeZoneSource.TzdbDateTimeZoneSource
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbDateTimeZoneSource
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor
  System.Reflection:
    name:
      CSharp:
      - name: System.Reflection
        nameWithType: System.Reflection
        qualifiedName: System.Reflection
      VB:
      - name: System.Reflection
        nameWithType: System.Reflection
        qualifiedName: System.Reflection
    isDefinition: true
    commentId: N:System.Reflection
  System.Reflection.Assembly:
    name:
      CSharp:
      - id: System.Reflection.Assembly
        name: Assembly
        nameWithType: Assembly
        qualifiedName: System.Reflection.Assembly
        isExternal: true
      VB:
      - id: System.Reflection.Assembly
        name: Assembly
        nameWithType: Assembly
        qualifiedName: System.Reflection.Assembly
        isExternal: true
    isDefinition: true
    parent: System.Reflection
    commentId: T:System.Reflection.Assembly
  System.Resources.ResourceSet:
    name:
      CSharp:
      - id: System.Resources.ResourceSet
        name: ResourceSet
        nameWithType: ResourceSet
        qualifiedName: System.Resources.ResourceSet
        isExternal: true
      VB:
      - id: System.Resources.ResourceSet
        name: ResourceSet
        nameWithType: ResourceSet
        qualifiedName: System.Resources.ResourceSet
        isExternal: true
    isDefinition: true
    parent: System.Resources
    commentId: T:System.Resources.ResourceSet
  System.Resources:
    name:
      CSharp:
      - name: System.Resources
        nameWithType: System.Resources
        qualifiedName: System.Resources
      VB:
      - name: System.Resources
        nameWithType: System.Resources
        qualifiedName: System.Resources
    isDefinition: true
    commentId: N:System.Resources
  System.Resources.ResourceManager:
    name:
      CSharp:
      - id: System.Resources.ResourceManager
        name: ResourceManager
        nameWithType: ResourceManager
        qualifiedName: System.Resources.ResourceManager
        isExternal: true
      VB:
      - id: System.Resources.ResourceManager
        name: ResourceManager
        nameWithType: ResourceManager
        qualifiedName: System.Resources.ResourceManager
        isExternal: true
    isDefinition: true
    parent: System.Resources
    commentId: T:System.Resources.ResourceManager
  System.IO.IOException:
    commentId: T:System.IO.IOException
  System.IO:
    name:
      CSharp:
      - name: System.IO
        nameWithType: System.IO
        qualifiedName: System.IO
      VB:
      - name: System.IO
        nameWithType: System.IO
        qualifiedName: System.IO
    isDefinition: true
    commentId: N:System.IO
  System.IO.Stream:
    name:
      CSharp:
      - id: System.IO.Stream
        name: Stream
        nameWithType: Stream
        qualifiedName: System.IO.Stream
        isExternal: true
      VB:
      - id: System.IO.Stream
        name: Stream
        nameWithType: Stream
        qualifiedName: System.IO.Stream
        isExternal: true
    isDefinition: true
    parent: System.IO
    commentId: T:System.IO.Stream
  NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream*
        name: FromStream
        nameWithType: TzdbDateTimeZoneSource.FromStream
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream*
        name: FromStream
        nameWithType: TzdbDateTimeZoneSource.FromStream
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream
  NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId*
        name: ForId
        nameWithType: TzdbDateTimeZoneSource.ForId
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId*
        name: ForId
        nameWithType: TzdbDateTimeZoneSource.ForId
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId
  NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds*
        name: GetIds
        nameWithType: TzdbDateTimeZoneSource.GetIds
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds*
        name: GetIds
        nameWithType: TzdbDateTimeZoneSource.GetIds
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds
  NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion:
    commentId: P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion
  NodaTime.TimeZones.Cldr.WindowsZones.Version:
    commentId: P:NodaTime.TimeZones.Cldr.WindowsZones.Version
  NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId*
        name: VersionId
        nameWithType: TzdbDateTimeZoneSource.VersionId
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId*
        name: VersionId
        nameWithType: TzdbDateTimeZoneSource.VersionId
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId
  NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId*
        name: MapTimeZoneId
        nameWithType: TzdbDateTimeZoneSource.MapTimeZoneId
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId*
        name: MapTimeZoneId
        nameWithType: TzdbDateTimeZoneSource.MapTimeZoneId
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId
  System.Linq.ILookup`2:
    name:
      CSharp:
      - id: System.Linq.ILookup`2
        name: ILookup
        nameWithType: ILookup
        qualifiedName: System.Linq.ILookup
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: TKey
        nameWithType: TKey
        qualifiedName: TKey
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: TElement
        nameWithType: TElement
        qualifiedName: TElement
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Linq.ILookup`2
        name: ILookup
        nameWithType: ILookup
        qualifiedName: System.Linq.ILookup
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: TKey
        nameWithType: TKey
        qualifiedName: TKey
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: TElement
        nameWithType: TElement
        qualifiedName: TElement
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Linq.ILookup`2
  System.Linq:
    name:
      CSharp:
      - name: System.Linq
        nameWithType: System.Linq
        qualifiedName: System.Linq
      VB:
      - name: System.Linq
        nameWithType: System.Linq
        qualifiedName: System.Linq
    isDefinition: true
    commentId: N:System.Linq
  System.Linq.ILookup{System.String,System.String}:
    name:
      CSharp:
      - id: System.Linq.ILookup`2
        name: ILookup
        nameWithType: ILookup
        qualifiedName: System.Linq.ILookup
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Linq.ILookup`2
        name: ILookup
        nameWithType: ILookup
        qualifiedName: System.Linq.ILookup
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Linq.ILookup`2
    parent: System.Linq
    commentId: T:System.Linq.ILookup{System.String,System.String}
  NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases*
        name: Aliases
        nameWithType: TzdbDateTimeZoneSource.Aliases
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases*
        name: Aliases
        nameWithType: TzdbDateTimeZoneSource.Aliases
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases
  NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds:
    commentId: M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds
  System.NotSupportedException:
    commentId: T:System.NotSupportedException
  System.Collections.Generic.IDictionary`2:
    name:
      CSharp:
      - id: System.Collections.Generic.IDictionary`2
        name: IDictionary
        nameWithType: IDictionary
        qualifiedName: System.Collections.Generic.IDictionary
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: TKey
        nameWithType: TKey
        qualifiedName: TKey
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: TValue
        nameWithType: TValue
        qualifiedName: TValue
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IDictionary`2
        name: IDictionary
        nameWithType: IDictionary
        qualifiedName: System.Collections.Generic.IDictionary
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: TKey
        nameWithType: TKey
        qualifiedName: TKey
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: TValue
        nameWithType: TValue
        qualifiedName: TValue
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.Generic.IDictionary`2
  System.Collections.Generic.IDictionary{System.String,System.String}:
    name:
      CSharp:
      - id: System.Collections.Generic.IDictionary`2
        name: IDictionary
        nameWithType: IDictionary
        qualifiedName: System.Collections.Generic.IDictionary
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IDictionary`2
        name: IDictionary
        nameWithType: IDictionary
        qualifiedName: System.Collections.Generic.IDictionary
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IDictionary`2
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IDictionary{System.String,System.String}
  NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap*
        name: CanonicalIdMap
        nameWithType: TzdbDateTimeZoneSource.CanonicalIdMap
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap*
        name: CanonicalIdMap
        nameWithType: TzdbDateTimeZoneSource.CanonicalIdMap
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap
  System.Collections.Generic.IList{NodaTime.TimeZones.TzdbZoneLocation}:
    name:
      CSharp:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.TimeZones.TzdbZoneLocation
        name: TzdbZoneLocation
        nameWithType: TzdbZoneLocation
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.TimeZones.TzdbZoneLocation
        name: TzdbZoneLocation
        nameWithType: TzdbZoneLocation
        qualifiedName: NodaTime.TimeZones.TzdbZoneLocation
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IList`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IList{NodaTime.TimeZones.TzdbZoneLocation}
  NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations*
        name: ZoneLocations
        nameWithType: TzdbDateTimeZoneSource.ZoneLocations
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations*
        name: ZoneLocations
        nameWithType: TzdbDateTimeZoneSource.ZoneLocations
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations
  NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion*
        name: TzdbVersion
        nameWithType: TzdbDateTimeZoneSource.TzdbVersion
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion*
        name: TzdbVersion
        nameWithType: TzdbDateTimeZoneSource.TzdbVersion
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion
  NodaTime.TimeZones.Cldr:
    name:
      CSharp:
      - name: NodaTime.TimeZones.Cldr
        nameWithType: NodaTime.TimeZones.Cldr
        qualifiedName: NodaTime.TimeZones.Cldr
      VB:
      - name: NodaTime.TimeZones.Cldr
        nameWithType: NodaTime.TimeZones.Cldr
        qualifiedName: NodaTime.TimeZones.Cldr
    isDefinition: true
    commentId: N:NodaTime.TimeZones.Cldr
  NodaTime.TimeZones.Cldr.WindowsZones:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.WindowsZones
        name: WindowsZones
        nameWithType: WindowsZones
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones
      VB:
      - id: NodaTime.TimeZones.Cldr.WindowsZones
        name: WindowsZones
        nameWithType: WindowsZones
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones
    isDefinition: true
    parent: NodaTime.TimeZones.Cldr
    commentId: T:NodaTime.TimeZones.Cldr.WindowsZones
  NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping*
        name: WindowsMapping
        nameWithType: TzdbDateTimeZoneSource.WindowsMapping
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping*
        name: WindowsMapping
        nameWithType: TzdbDateTimeZoneSource.WindowsMapping
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping
  NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate*
        name: Validate
        nameWithType: TzdbDateTimeZoneSource.Validate
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate
      VB:
      - id: NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate*
        name: Validate
        nameWithType: TzdbDateTimeZoneSource.Validate
        qualifiedName: NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate
  NodaTime.TimeZones.Cldr.MapZone.WindowsId*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.MapZone.WindowsId*
        name: WindowsId
        nameWithType: MapZone.WindowsId
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone.WindowsId
      VB:
      - id: NodaTime.TimeZones.Cldr.MapZone.WindowsId*
        name: WindowsId
        nameWithType: MapZone.WindowsId
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone.WindowsId
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.Cldr.MapZone.WindowsId
  NodaTime.TimeZones.Cldr.MapZone.Territory*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.MapZone.Territory*
        name: Territory
        nameWithType: MapZone.Territory
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone.Territory
      VB:
      - id: NodaTime.TimeZones.Cldr.MapZone.Territory*
        name: Territory
        nameWithType: MapZone.Territory
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone.Territory
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.Cldr.MapZone.Territory
  System.Collections.Generic.IList{System.String}:
    name:
      CSharp:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IList`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IList{System.String}
  NodaTime.TimeZones.Cldr.MapZone.TzdbIds*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.MapZone.TzdbIds*
        name: TzdbIds
        nameWithType: MapZone.TzdbIds
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone.TzdbIds
      VB:
      - id: NodaTime.TimeZones.Cldr.MapZone.TzdbIds*
        name: TzdbIds
        nameWithType: MapZone.TzdbIds
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone.TzdbIds
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.Cldr.MapZone.TzdbIds
  NodaTime.TimeZones.Cldr.MapZone.#ctor*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.MapZone.#ctor*
        name: MapZone
        nameWithType: MapZone.MapZone
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone.MapZone
      VB:
      - id: NodaTime.TimeZones.Cldr.MapZone.#ctor*
        name: MapZone
        nameWithType: MapZone.MapZone
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone.MapZone
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.Cldr.MapZone.#ctor
  NodaTime.TimeZones.Cldr.MapZone:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.MapZone
        name: MapZone
        nameWithType: MapZone
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone
      VB:
      - id: NodaTime.TimeZones.Cldr.MapZone
        name: MapZone
        nameWithType: MapZone
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone
    isDefinition: true
    commentId: T:NodaTime.TimeZones.Cldr.MapZone
  NodaTime.TimeZones.Cldr.WindowsZones.Version*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.WindowsZones.Version*
        name: Version
        nameWithType: WindowsZones.Version
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones.Version
      VB:
      - id: NodaTime.TimeZones.Cldr.WindowsZones.Version*
        name: Version
        nameWithType: WindowsZones.Version
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones.Version
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.Cldr.WindowsZones.Version
  NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion*
        name: TzdbVersion
        nameWithType: WindowsZones.TzdbVersion
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion
      VB:
      - id: NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion*
        name: TzdbVersion
        nameWithType: WindowsZones.TzdbVersion
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion
  NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion*
        name: WindowsVersion
        nameWithType: WindowsZones.WindowsVersion
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion
      VB:
      - id: NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion*
        name: WindowsVersion
        nameWithType: WindowsZones.WindowsVersion
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion
  NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory:
    commentId: F:NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory
  System.Collections.Generic.IList{NodaTime.TimeZones.Cldr.MapZone}:
    name:
      CSharp:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: NodaTime.TimeZones.Cldr.MapZone
        name: MapZone
        nameWithType: MapZone
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: NodaTime.TimeZones.Cldr.MapZone
        name: MapZone
        nameWithType: MapZone
        qualifiedName: NodaTime.TimeZones.Cldr.MapZone
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IList`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IList{NodaTime.TimeZones.Cldr.MapZone}
  NodaTime.TimeZones.Cldr.WindowsZones.MapZones*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.WindowsZones.MapZones*
        name: MapZones
        nameWithType: WindowsZones.MapZones
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones.MapZones
      VB:
      - id: NodaTime.TimeZones.Cldr.WindowsZones.MapZones*
        name: MapZones
        nameWithType: WindowsZones.MapZones
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones.MapZones
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.Cldr.WindowsZones.MapZones
  NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping*:
    name:
      CSharp:
      - id: NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping*
        name: PrimaryMapping
        nameWithType: WindowsZones.PrimaryMapping
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping
      VB:
      - id: NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping*
        name: PrimaryMapping
        nameWithType: WindowsZones.PrimaryMapping
        qualifiedName: NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping
    isDefinition: true
    commentId: Overload:NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping
  NodaTime.LocalDateTime.ToDateTimeUnspecified:
    commentId: M:NodaTime.LocalDateTime.ToDateTimeUnspecified
  NodaTime.LocalDateTime.FromDateTime(System.DateTime):
    commentId: M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)
  System.DayOfWeek:
    name:
      CSharp:
      - id: System.DayOfWeek
        name: DayOfWeek
        nameWithType: DayOfWeek
        qualifiedName: System.DayOfWeek
        isExternal: true
      VB:
      - id: System.DayOfWeek
        name: DayOfWeek
        nameWithType: DayOfWeek
        qualifiedName: System.DayOfWeek
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.DayOfWeek
  NodaTime.Utility.BclConversions.ToDayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.Utility.BclConversions.ToDayOfWeek*
        name: ToDayOfWeek
        nameWithType: BclConversions.ToDayOfWeek
        qualifiedName: NodaTime.Utility.BclConversions.ToDayOfWeek
      VB:
      - id: NodaTime.Utility.BclConversions.ToDayOfWeek*
        name: ToDayOfWeek
        nameWithType: BclConversions.ToDayOfWeek
        qualifiedName: NodaTime.Utility.BclConversions.ToDayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.Utility.BclConversions.ToDayOfWeek
  NodaTime.Utility.BclConversions.ToIsoDayOfWeek*:
    name:
      CSharp:
      - id: NodaTime.Utility.BclConversions.ToIsoDayOfWeek*
        name: ToIsoDayOfWeek
        nameWithType: BclConversions.ToIsoDayOfWeek
        qualifiedName: NodaTime.Utility.BclConversions.ToIsoDayOfWeek
      VB:
      - id: NodaTime.Utility.BclConversions.ToIsoDayOfWeek*
        name: ToIsoDayOfWeek
        nameWithType: BclConversions.ToIsoDayOfWeek
        qualifiedName: NodaTime.Utility.BclConversions.ToIsoDayOfWeek
    isDefinition: true
    commentId: Overload:NodaTime.Utility.BclConversions.ToIsoDayOfWeek
  NodaTime.Utility.BclConversions:
    name:
      CSharp:
      - id: NodaTime.Utility.BclConversions
        name: BclConversions
        nameWithType: BclConversions
        qualifiedName: NodaTime.Utility.BclConversions
      VB:
      - id: NodaTime.Utility.BclConversions
        name: BclConversions
        nameWithType: BclConversions
        qualifiedName: NodaTime.Utility.BclConversions
    isDefinition: true
    commentId: T:NodaTime.Utility.BclConversions
  NodaTime.Utility.InvalidNodaDataException.#ctor*:
    name:
      CSharp:
      - id: NodaTime.Utility.InvalidNodaDataException.#ctor*
        name: InvalidNodaDataException
        nameWithType: InvalidNodaDataException.InvalidNodaDataException
        qualifiedName: NodaTime.Utility.InvalidNodaDataException.InvalidNodaDataException
      VB:
      - id: NodaTime.Utility.InvalidNodaDataException.#ctor*
        name: InvalidNodaDataException
        nameWithType: InvalidNodaDataException.InvalidNodaDataException
        qualifiedName: NodaTime.Utility.InvalidNodaDataException.InvalidNodaDataException
    isDefinition: true
    commentId: Overload:NodaTime.Utility.InvalidNodaDataException.#ctor
  NodaTime.Utility:
    name:
      CSharp:
      - name: NodaTime.Utility
        nameWithType: NodaTime.Utility
        qualifiedName: NodaTime.Utility
      VB:
      - name: NodaTime.Utility
        nameWithType: NodaTime.Utility
        qualifiedName: NodaTime.Utility
    isDefinition: true
    commentId: N:NodaTime.Utility
